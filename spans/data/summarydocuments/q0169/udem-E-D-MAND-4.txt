dd <- data.frame(a = gl(3,4), b = gl(4,1,12))# balanced 2-way options("contrasts") # the default: "contr.treatment" sparse.model.matrix(~ a + b, dd) sparse.model.matrix(~ -1+ a + b, dd)# no intercept --> even sparser sparse.model.matrix(~ a + b, dd, contrasts = list(a="contr.sum")) sparse.model.matrix(~ a + b, dd, contrasts = list(b="contr.SAS")) ## Sparse method is equivalent to the traditional one : a + b, dd) == Matrix(model.matrix(~ a + b, dd), sparse=TRUE)), all(sparse.model.matrix(~ 0. int64 '>' with 3 stored elements in Compressed Sparse Row format > >> > M = matrix ( [ [ 1.0 , 0.0 ] , [ 0.0 , 2.0 ] ] ) >> > lil_matrix ( M ) < 2 x2 sparse matrix of type '<type ' numpy. printf("\n\nENTER THE VALUE FOR (%d*%d) MATRIX= ",m1,n1); for(i=0;inz1) printf("\n\n\nIT CAN CONVERT INTO SPARSE MATRIX\n"); else { printf("\n\nCAN'T CONVERT INTO SPARSE MATRIX\n"); exit(1); } //converting into sparse matrix printf("\n\nCONVERSION OF SPARSE MATRIX\n\n"); sm1[0][0]=m1; sm1[0][1]=n1; sm1[0][2]=nz1;
