6 References
End-user documentation
To use UMFPACK instead of SLAP, configure with the --with-umfpack=path-to-umfpack-libraries.  This requires an object file containing the Fortran bindings for UMFPACK to be compiled and placed in the same directory as the library, as this is not included automatically with the UMFPACK build.
Developer documentation
Although Fortran 90 does not support an object-oriented style of programming, we have designed the sparse matrix solving library within CISM using several insights from the paradigm.  For instance, following the principle of encapsulation the interface used to solve a sparse matrix is separated from the internal details of the solver being used.  There are many places in CISM where a sparse matrix needs to be solved: thickness evolution, higher-order velocity fields, and lithosphere temperature models, to name a few.  We have written or re-designed these routines so as to be agnostic regarding the method used to solve the sparse matrix.  However, the state of numerical sparse matrix solving is somewhat Babel-like: no two libraries conform to nearly the same interface!
One solution to the problem would have been to pepper the code with preprocessor or runtime conditionals selecting the sparse solver to run.  However, this would have quickly led to messy and unreadable code, and would present a combinatoric problem as both more solvers and more routines requiring a sparse matrix solve are added.  In order to reconcile the desire to support multiple solvers with the desire to maintain a clean code base we have applied the Adapter pattern (Gamma et. al. 1996) and defined an abstract sparse solver interface that code requiring a sparse solve can call and code providing a sparse solver can implement.
Developers interested in integrating CISM with their sparse matrix solving library of choice must be aware that the interface we have defined is a contract that all sparse solver adapters must fulfill.  If client code relies on a feature that is not implemented, it will lead to either a compile-time or run-time error.
Module Design
In order to add a new sparse matrix solver to Glimmer, create a new module file name glimmer_sparse_solvername.F90.  The module contained in this file must be named glimmer_sparse_solver in order for it to be swappable with the SLAP BCG solver.  The module must provide a number of datatypes and functions; glimmer_sparse_slap provides detailed documentation on the facilities that the module needs to expose and is a good template to follow.
Data Types
The sparse matrix type used by a sparse solver is the type defined in glimmer_sparse.F90; sparse solvers do not need to and should not implement their own sparse matrix storage scheme.  This type supports construction of a sparse matrix in triad format, consisting of three arrays that specify the row, column, and value of a sparse matrix entry.  The type also supports conversion to compressed column (a.k.a Boeing-Harwell) or compressed row (transpose of compressed column) format.  If the sparse solver being integrated requires a different format, a new routine will need to be implemented.
Each sparse matrix solver defines two different derived types: sparse_solver_workspace and sparse_solver_options.  Sparse_solver_options is a structure that incorporates any configuration that needs to be passed to the solver.  Anticipating the need to generally support iterative solvers in addition to direct solvers, sparse_solver_options must at least provide fields named maxiters and tolerance to store the maximum iterations and the error tolerance for iterative solvers.  Direct solvers may feel free to ignore these fields but must still provide them.  Additional solver-specific options may be added to this field, and client code can use them after checking whether the preprocessor definition SPARSE_SOLVER contains the solver that the options are specific to.
Most sparse solvers require internal workspace to be managed, typically through either a handle to the workspace (as is the case in UMFPACK or PARDISO) or by providing allocated memory of sufficient size (as is the case in SLAP).  Sparse solvers may also support or require pre-processing on the matrix before solving.  To support these cases, a CISM sparse solver wrapper must include a derived data type called sparse_solver_workspace.  Client code must treat this workspace as entirely opaque, declaring it and passing it to the sparse solver routines without examining or modifying its internals.  In this way, it can be thought of as analogous to the private member variables used in object-oriented design.  Even if the sparse solver being wrapped does not require any sort of workspace, an empty derived type must be declared as client code will depend on the presence of this derived type.
Functions
For efficiency, the sparse matrix adapter is designed with three tiers of operations.  This allows client code to avoid repeated operations such as memory allocation and de-allocation, sparse format conversion, matrix factorization, etc. where possible.  This leads to the following pair of operations:
Because every sparse solver's library is different, not all of the calls listed will be needed.  If a call is superfluous, the library must still implement it because client code will be written assuming that the function exists.
sparse_allocate_workspace/sparse_deallocate_workspace: Client code can call the allocate functions as soon as the the size of the matrix (both the order and an upper bound on the number of nonzeros) are known.  The deallocate function can be deferred until the memory is no longer needed.  An arbitrary number of matrix solves using the workspace may proceed between these functions as long as the amount of memory needed for the solve does not exceed the amount allocated.
sparse_solver_preprocess/sparse_solver_postprocess: Client code can call the preprocess function as soon as the matrix has been fully assembled but before the right-hand side is necessarily known.  Operations appropriate for the preprocess call include transforming a triad format matrix to compressed row/column format, as well as numeric factorization or preconditioning of the matrix.  These are separated from the main solver routine in case the same matrix needs to be used multiple times with different right-hand sides.
Integration Information
Describe how the selection of a sparse wrapper is integrated into the build system.
PARDISO
Introduction
PARDISO stands for Parallel Sparse Direct Linear Solver. PARDISO is a software for solving large sparse symmetric and nonsymmetric linear systems of equations on shared memory multiprocessors. The algorithms in PARDISO are based on a Level-3 BLAS update and pipelining parallelism and internally use OpenMP. PARDISO is availbe for use with Fortran and C.  PARDISO supports symmetric, structurally symmetirc and non-symmetric matrices. As obvious from the name PARDISO is a direct solver but also allows a combination of direct and iterative methods for better performance.
PARDISO with Glimmer
Our goal here was to replace the SLAP library used by GLIMMER to solve the systems of liner equation in sequential with PARDISO that can solve the system of equation in parallel. Because the dataset used to run the simulations can be quite large, the current partial differential equation (PDE) solver should be replaced by one that can run in parallel. We know that SLAP uses the Bbi-conjugate gradient method to solve the system of linear equations and the ILU (Incomplete LU) decomposition method for pre-conditioning. In the case of PARDISO, it is a direct parallel solver for the system of equations, which means it does not focuses on any iterative method. But, PARDISO again says that it supports a combination of direct and iterative methods in order to accelerate the linear solution process for transient simulation.[1]
when linking in PARDISO, programs are required to provide the implementation of BLAS/LAPACK via another library which is linked in as well. In order to replace SLAP with PRDISO we compiled and linked all applications and libraries with gfortran 4.3. Further, We discovered that we needed to transform the data into Compressed Sparse Row format (CSR) for use with PARDISO. Initially we thought SLAP routines already provided this functionality. However, we discovered that SLAP only provided conversions to Compressed Column format, and we would need to provide our own conversion to CSR.We wrote a subroutine to convert the data from Coordinate Format to CSR. This resulted in a new and unexpected problem. When we converted the data to CSR, initially we got identical results, but  as the solver progressed throughout the simulation, the results were wrong when compared with SLAP. What we discovered was that the data from GLIMMER was only sorted by row, and within rows columns *may* be unsorted. This resulted in creating a CSR matrix that was wrong. Thankfully, SLAP already provided routines for sorting and moving arrays, so once we made calls to sort the columns within a row, we got correct results.
PARDISO Solver
A FORTRAN module named Pardiso_solver.f90 was developed which implemented the PARDISO subroutines to solve the system of equations. The main solver routine has a signature as follows:
subroutine Pardiso_Solve ( numRowsCols, bvec, xvec, numNonZeroesA, rowsA, colsA, & valuesA, error )
numRowsCols = Order, num Variables\Equations
bvec         = The 'B' part
