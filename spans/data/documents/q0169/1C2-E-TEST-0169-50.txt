26.7
63
Table 1. Average number of non-zero entries in every row/column of assembled system matrix for various element types.
Since the number of entries per row of A is bounded from above by a constant, the total number of non-zero entries constitute a small (and decreasing with increasing the system size) fraction of all the matrix entries (nnz(A)~C*n vs. numel(A)=n2). Storing the zero entries and explicitly using them in computations is inefficient from the point of view of the memory and computational resources. For sparse matrices, dedicated storage formats have been developed that allow only the non-zero entries to be kept in the memory and used in computations. This is commonly done by keeping additional row and column index information along with every non-zero matrix entry.
Below we show how to use the sparse storage and how to assemble the global sparse matrix A in MATLAB.
How not to do it in MATLAB
Consider the most straightforward implementation of assembling local matrices A_el into the global matrix A for a FEM problem with one dof per node.
A = sparse(nnod,nnod); for iel=1:nel     indx = ELEMS(:,iel); ... %compute element stiffness matrix A_el ... A(indx,indx) = A(indx,indx) + A_el; end
In the code fragment above the sparse matrix A initially contains only zero entries, i.e., very little memory is used by the data structure. During the execution of the element loop the sparsity pattern (the positions of the non-zero entries) of the global matrix A changes as the contributions from the elements are added. The internal data structure that holds the matrix entries and the auxiliary row/column index arrays need to be constantly reallocated and updated. In practice, in the above approach the time spent on the assembly largely exceeds the time needed to compute the element matrices.
Since the sparsity pattern is determined by the mesh, the final data structure needed to hold the sparse matrix A can be
allocated before the element loop. In this approach A explicitly stores zero entries in places (row/column pairs), which can contain non-zeros after the assembly. The matrix entries can be updated in the element loop. This requires an additional work of finding the correct memory location in the sparse data structure, but the large overhead connected with constant rebuilding of the sparse storage structure is avoided. Unfortunately, this approach is not a viable option in MATLAB for two reasons:
1. It is not possible to explicitly store zero entries in sparse matrices in MATLAB, since those are automatically removed. Thus, it is not possible to initialize an empty sparse matrix with a predetermined sparsity pattern.
2. In our experience updating a small set of entries of a sparse matrix in MATLAB also involves a substantial overhead. This could be caused by the additional time MATLAB spends on verifying that a sparse matrix only contains non-zero entries, which requires reading all the matrix entries from the memory – an overhead that grows with the system size.
Overcoming the two deficiencies would require a major modification of the MATLAB sparse class.
Triplet sparse storage
A workaround solution is to compute and store all the element matrices A_el first and assemble them in one call to MATLAB sparse function, as shown in the code fragment below.
A_all = zeros(nnodel*nnodel,nel); for iel=1:nel ... %compute element stiffness matrix A_el ... A_all(:,iel) = A_all(:,iel) + A_el(:); end   indx_j = repmat(1:nnodel,nnodel,1);  indx_i = indx_j'; Ai = ELEMS(indx_i(:),:); Aj = ELEMS(indx_j(:),:);   A = sparse(Ai,Aj,A_all);
In this approach all the element matrices are first stored in A_all array. Next, the row and column indices for every entry of all the element matrices are computed (Ai, Aj). This method of representing a sparse matrix is called the triplet format: for every matrix entry the corresponding row/column information is stored explicitly. Duplicate Ai, Aj pairs exist in the triplet list. The global matrix assembly is performed in one call to a dedicated MATLAB function sparse , which adds the duplicate entries.
This implementation is much faster than the first described approach. The disadvantages are that all the element matrices need to be stored in the A_all array prior to the assembly. The memory requirements are additionally increased due to the need to store the arrays containing row/column indices. Due to the duplicates the number of entries in the triplet storage can vary between 6.3 to 1.4 times the number of non-zero entries in the assembled global matrix A. The exact amount of memory overhead depends on the element type (see the Table 2). If the matrix assembly is not followed by the much more memory intensive Cholesky factorization, the elevated memory requirements related to the (Ai, Aj, A_all) arrays might restrict the problem size that can be solved.
element type
