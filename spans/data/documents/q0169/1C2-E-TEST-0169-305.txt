src/c/a/casadi-HEAD/trunk/examples/python/superlu/test_superlu.py     casadi ( Download )
from scipy.sparse import csr_matrix from scipy.sparse.linalg import spsolve from numpy.linalg import solve, norm from numpy.random import rand from numpy import * from casadi import *  
val = (s, l, l, u, l, l, u, p, u, e, u, r)   # Solve with scipy A = csr_matrix((val,col,rowind),shape=(nrow,ncol),dtype=float) b = ones((nrow,1),dtype=float) r_scipy = spsolve(A,b)  
a problem from http://www.uc.edu/sashtml/iml/chap8/sect12.htm. """   from numpy import array, zeros, Inf from scipy.sparse import csr_matrix   from pips import qps_pips   H = csr_matrix(array([[1003.1,  4.3,     6.3,     5.9],
c = zeros(4)     A = csr_matrix(array([[   1,       1,       1,       1   ],                       [   0.17,    0.11,    0.10,    0.18]]))   l = array([1, 0.10])
src/p/y/pylon-HEAD/examples/pips/nlp.py     pylon ( Download )
the problem from http://en.wikipedia.org/wiki/Nonlinear_programming. """   from numpy import array, r_, float64, dot from scipy.sparse import csr_matrix from pips import pips   def f2(x):
def gh2(x):     h = dot(array([ [1, -1, 1], [1, 1, 1] ]), x**2) + array([-2.0, -10.0])     dh = 2 * csr_matrix( array([ [x[0], x[0]], [-x[1], x[1]], [x[2], x[2]] ]) )     g = array([])     dg = None     return h, g, dh, dg   def hess2(x, lam):     mu = lam["ineqnonlin"]     Lxx = csr_matrix( array([ r_[dot(2 * array([1, 1]), mu), -1, 0],
src/p/y/pylon-HEAD/examples/pips/cone.py     pylon ( Download )
"""   import numpy as np from scipy.sparse import csr_matrix   from pdipm import pdipm  
def hess(x, lmbda):     u = 1 - x**2     H = csr_matrix((2 * lmbda[0] * 1 + u**2 / u**2, ()))     return H   sol = pdipm(f, gh, hess, x0, A=G, l=k, u=h) print sol["x"]
src/p/y/pylon-HEAD/contrib/ipopf.py     pylon ( Download )
from numpy import \     array, polyder, polyval, exp, conj, Inf, ones, r_, zeros, asarray   from scipy.sparse import lil_matrix, csr_matrix, hstack, vstack   from pylon import REFERENCE from pylon.solver import _Solver, SFLOW, IFLOW, PFLOW
dSbus_dVm, dSbus_dVa = case.dSbus_dV(Ybus, V)   i_gbus = [gen.bus._i for gen in gn]             neg_Cg = csr_matrix((-ones(ng), (i_gbus, range(ng))), (nb, ng))   # Transposed Jacobian of the power balance equality constraints.             dg = lil_matrix((nxyz, 2 * nb))   blank = csr_matrix((nb, ng))
  i = r_[range(Pg.i1, Pg.iN + 1), range(Qg.i1, Qg.iN + 1)]   d2f = csr_matrix((vstack([d2f_dPg2, d2f_dQg2]).toarray().flatten(),                               (i, i)), shape=(nxyz, nxyz))             # TODO: Generalised cost model.             d2f = d2f * self.opt["cost_mult"]
hstack([Gpva, Gpvv])]).real +                     vstack([hstack([Gqaa, Gqav]),                             hstack([Gqva, Gqvv])]).imag,                     csr_matrix((2 * nb, nxtra))]),                 hstack([                     csr_matrix((nxtra, 2 * nb)),                     csr_matrix((nxtra, nxtra))
f = [e.from_bus._i for e in ln]                 t = [e.to_bus._i for e in ln]                 # Line-bus connection matrices.                 Cf = csr_matrix((ones(nl), (range(nl), f)), (nl, nb))                 Ct = csr_matrix((ones(nl), (range(nl), t)), (nl, nb))                 dSf_dVa, dSf_dVm, dSt_dVa, dSt_dVm, Sf, St = \                     case.dSbr_dV(Yf, Yt, V)
hstack([Hfva, Hfvv])]) +                     vstack([hstack([Htaa, Htav]),                             hstack([Htva, Htvv])]),                     csr_matrix((2 * nb, nxtra))                 ]),                 hstack([                     csr_matrix((nxtra, 2 * nb)),                     csr_matrix((nxtra, nxtra))
src/p/y/Pylon-0.4.2/pylon/opf.py     Pylon ( Download )
array, pi, diff, polyder, polyval, exp, conj, Inf, finfo, ones, r_, \     float64, zeros, diag, flatnonzero, dot, asarray   from scipy.sparse import lil_matrix, csr_matrix, hstack, vstack   from util import Named from case import REFERENCE
def _power_mismatch_dc(self, buses, generators, B, Pbusinj, base_mva): """ Returns the power mismatch constraint (B*Va + Pg = Pd). """ nb, ng = len(buses), len(generators)         # Negative bus-generator incidence matrix.         gen_bus = array([g.bus._i for g in generators])         neg_Cg = csr_matrix((-ones(ng), (gen_bus, range(ng))), (nb, ng))
jjf = array([b.from_bus._i for b in branches])[iang]                 jjt = array([b.to_bus._i for b in branches])[iang]                 jj = r_[jjf, jjt]                 Aang = csr_matrix(r_[ones(nang), -ones(nang)],                                         (ii, jj), (nang, nb))                 uang = Inf * ones(nang)                 lang = -uang
if any_pwl:             y = self.om.get_var("y")             # Sum of y vars.             Npwl = csr_matrix((ones(ny), (zeros(ny), array(ipwl) + y.i1)))             Hpwl = csr_matrix((1, 1))             Cpwl = array([1])             fparm_pwl = array([[1, 0, 0, 1]])
polycf *= diag([base_mva**2, base_mva, 1])   Pg = self.om.get_var("Pg")             Npol = csr_matrix((ones(npol), (rnpol, Pg.i1 + array(ipol))),                               (npol, nxyz))             Hpol = csr_matrix((2 * polycf[:, 0], (rnpol, rnpol)), (npol, npol))             Cpol = polycf[:, 1]
NN = vstack([n for n in [Npwl, Npol] if n is not None], "csr")   if (Hpwl is not None) and (Hpol is not None):             Hpwl = hstack([Hpwl, csr_matrix((any_pwl, npol))])             Hpol = hstack([csr_matrix((npol, any_pwl)), Hpol]) #        if H is not None: #            H = hstack([csr_matrix((nw, any_pwl+npol)), H])
def _transform_coefficients(self, NN, HHw, CCw, ffparm, polycf,                                any_pwl, npol, nw): """ Transforms quadratic coefficients for w into coefficients for X. """ nnw = any_pwl + npol + nw         M = csr_matrix((ffparm[:, 3], (range(nnw), range(nnw))))         MR = M * ffparm[:, 2]
dSbus_dVm, dSbus_dVa = case.dSbus_dV(Ybus, V)   i_gbus = [gen.bus._i for gen in gn]             neg_Cg = csr_matrix((-ones(ng), (i_gbus, range(ng))), (nb, ng))   # Transposed Jacobian of the power balance equality constraints.             dg = lil_matrix((nxyz, 2 * nb))   blank = csr_matrix((nb, ng))
#  Evaluate d2f.             #------------------------------------------------------------------   d2f_dPg2 = csr_matrix((ng, 1)) # w.r.t p.u. Pg             d2f_dQg2 = csr_matrix((ng, 1)) # w.r.t p.u. Qg   for i in ipol:
  i = r_[range(Pg.i1, Pg.iN + 1), range(Qg.i1, Qg.iN + 1)]   d2f = csr_matrix((vstack([d2f_dPg2, d2f_dQg2]).toarray().flatten(),                               (i, i)), shape=(nxyz, nxyz))             # TODO: Generalised cost model.             d2f = d2f * self.opt["cost_mult"]
hstack([Gpva, Gpvv])]).real +                     vstack([hstack([Gqaa, Gqav]),                             hstack([Gqva, Gqvv])]).imag,                     csr_matrix((2 * nb, nxtra))]),                 hstack([                     csr_matrix((nxtra, 2 * nb)),                     csr_matrix((nxtra, nxtra))
f = [e.from_bus._i for e in ln]                 t = [e.to_bus._i for e in ln]                 # Line-bus connection matrices.                 Cf = csr_matrix((ones(nl), (range(nl), f)), (nl, nb))                 Ct = csr_matrix((ones(nl), (range(nl), t)), (nl, nb))                 dSf_dVa, dSf_dVm, dSt_dVa, dSt_dVm, Sf, St = \                     case.dSbr_dV(Yf, Yt, V)
hstack([Hfva, Hfvv])]) +                     vstack([hstack([Htaa, Htav]),                             hstack([Htva, Htvv])]),                     csr_matrix((2 * nb, nxtra))                 ]),                 hstack([                     csr_matrix((nxtra, 2 * nb)),                     csr_matrix((nxtra, nxtra))
src/p/y/PYPOWER-HEAD/pypower/opf_hessfcn.py     PYPOWER ( Download )
# limitations under the License.   from numpy import array, zeros, ones, exp, nonzero, r_ from scipy.sparse import csr_matrix, vstack, hstack   from idx_gen import PG, QG from idx_brch import F_BUS, T_BUS
qcost = array([])   ## ----- evaluate d2f -----     d2f_dPg2 = csr_matrix((ng, 1))               ## w.r.t. p.u. Pg     d2f_dQg2 = csr_matrix((ng, 1))               ## w.r.t. p.u. Qg     ipolp = nonzero(pcost[:, MODEL] == POLYNOMIAL)     d2f_dPg2[ipolp] = \
baseMVA**2 * polycost(qcost[ipolq, :], Qg[ipolq] * baseMVA, 2)     i = range(vv["i1"]["Pg"], vv["iN"]["Pg"]) + \         range(vv["i1"]["Qg"], vv["iN"]["Qg"])     d2f = csr_matrix((vstack([d2f_dPg2, d2f_dQg2]).toarray().flatten(),                       (i, i)), shape=(nxyz, nxyz))   ## generalized cost
iND = r_[iLT, iEQ, iGT]         ## rows that are Not in the Dead region iL = nonzero(dd == 1)           ## rows using linear function         iQ = nonzero(dd == 2)           ## rows using quadratic function         LL = csr_matrix((1.0, (iL, iL)), (nw, nw))         QQ = csr_matrix((1.0, (iQ, iQ)), (nw, nw))         kbar = csr_matrix((r_[  ones(len(iLT), 1),                                zeros(len(iEQ), 1),                                -ones(len(iGT), 1)], (iND, iND)), nw, nw) * kk         rr = r + kbar                  ## apply non-dead zone shift         M = csr_matrix((mm[iND], (iND, iND)), (nw, nw))  ## dead zone or scale         diagrr = csr_matrix((rr, range(nw), range(nw)), (nw, nw))
HwC = H * w + Cw         AA = N.T * M * (LL + 2 * QQ * diagrr)         d2f = d2f + AA * H * AA.T + 2 * N.T * M * QQ * \                 csr_matrix((HwC, range(nw), range(nw)), (nw, nw)) * N     d2f = d2f * cost_mult   ##----- evaluate Hessian of power balance constraints -----
hstack([Gpva, Gpvv])]).real +                 vstack([hstack([Gqaa, Gqav]),                         hstack([Gqva, Gqvv])]).imag,                 csr_matrix((2 * nb, nxtra))]),             hstack([                 csr_matrix((nxtra, 2 * nb)),                 csr_matrix((nxtra, nxtra))
f = branch[il, F_BUS]    ## list of "from" buses         t = branch[il, T_BUS]    ## list of "to" buses         ## connection matrix for line & from buses         Cf = csr_matrix((ones(nl2), (range(nl2), f)), (nl2, nb))         ## connection matrix for line & to buses         Ct = csr_matrix((ones(nl2), (range(nl2), t)), (nl2, nb))         dSf_dVa, dSf_dVm, dSt_dVa, dSt_dVm, Sf, St = \
hstack([Hfva, Hfvv])]) +                 vstack([hstack([Htaa, Htav]),                         hstack([Htva, Htvv])]),                 csr_matrix((2 * nb, nxtra))             ]),             hstack([                 csr_matrix((nxtra, 2 * nb)),                 csr_matrix((nxtra, nxtra))
if 0:         nx = len(x)         step = 1e-5         num_d2f = csr_matrix((nx, nx))         num_d2G = csr_matrix((nx, nx))         num_d2H = csr_matrix((nx, nx))         for i in range(nx):
src/p/y/pyamg-1.0.0/pyamg/strength.py     pyamg ( Download )
""" if not sparse.isspmatrix_csr(A):          warn("Implicit conversion of A to csr", sparse.SparseEfficiencyWarning)         A = sparse.csr_matrix(A)   if (theta<0 or theta>1):         raise ValueError('expected theta in [0,1]')
fn = amg_core.classical_strength_of_connection     fn(A.shape[0], theta, A.indptr, A.indices, A.data, Sp, Sj, Sx)   return sparse.csr_matrix((Sx,Sj,Sp), shape=A.shape)     def symmetric_strength_of_connection(A, theta=0):
fn = amg_core.symmetric_strength_of_connection         fn(A.shape[0], theta, A.indptr, A.indices, A.data, Sp, Sj, Sx)   return sparse.csr_matrix((Sx,Sj,Sp),A.shape)   elif sparse.isspmatrix_bsr(A):         M,N = A.shape
  if theta == 0:             data = numpy.ones(len(A.indices), dtype=A.dtype)             return sparse.csr_matrix((data, A.indices, A.indptr), shape=(M/R,N/C))         else:             # the strength of connection matrix is based on the              # Frobenius norms of the blocks             data = (numpy.conjugate(A.data) * A.data).reshape(-1, R*C).sum(axis=1)              A = sparse.csr_matrix((data, A.indices, A.indptr), shape=(M/R,N/C))
if bsr_flag:         Atilde = Atilde.tobsr(blocksize=(numPDEs, numPDEs))         nblocks = Atilde.indices.shape[0]         Atilde = sparse.csr_matrix( (numpy.ones((nblocks,)), Atilde.indices, Atilde.indptr), shape=(Atilde.shape[0]/numPDEs, Atilde.shape[1]/numPDEs) )   return Atilde  
CSRdata = numpy.zeros((n_blocks,))         amg_core.min_blocks(n_blocks, blocksize, numpy.ravel(numpy.asarray(Atilde.data)), CSRdata)         #Atilde = sparse.csr_matrix((data, row, col), shape=(*,*))         Atilde = sparse.csr_matrix((CSRdata, Atilde.indices, Atilde.indptr), shape=(Atilde.shape[0]/numPDEs, Atilde.shape[1]/numPDEs) )   return Atilde  
src/p/y/pylon-HEAD/pylon/solver.py     pylon ( Download )
from numpy import \     array, pi, polyder, polyval, exp, conj, Inf, ones, r_, zeros, asarray   from scipy.sparse import lil_matrix, csr_matrix, hstack, vstack   from case import REFERENCE from generator import POLYNOMIAL, PW_LINEAR
if any_pwl:             y = self.om.get_var("y")             # Sum of y vars.             Npwl = csr_matrix((ones(ny), (zeros(ny), array(ipwl) + y.i1)))             Hpwl = csr_matrix((1, 1))             Cpwl = array([1])             fparm_pwl = array([[1., 0., 0., 1.]])
# Convert to per-unit.             polycf = polycf * array([base_mva**2, base_mva, 1])             Pg = self.om.get_var("Pg")             Npol = csr_matrix((ones(npol), (rnpol, Pg.i1 + array(ipol))),                               (npol, nxyz))             Hpol = csr_matrix((2 * polycf[:, 0], (rnpol, rnpol)), (npol, npol))             Cpol = polycf[:, 1]
NN = vstack([n for n in [Npwl, Npol] if n is not None], "csr")   if (Hpwl is not None) and (Hpol is not None):             Hpwl = hstack([Hpwl, csr_matrix((any_pwl, npol))])             Hpol = hstack([csr_matrix((npol, any_pwl)), Hpol]) #        if H is not None: #            H = hstack([csr_matrix((nw, any_pwl+npol)), H])
def _transform_coefficients(self, NN, HHw, CCw, ffparm, polycf,                                any_pwl, npol, nw): """ Transforms quadratic coefficients for w into coefficients for x. """ nnw = any_pwl + npol + nw         M = csr_matrix((ffparm[:, 3], (range(nnw), range(nnw))))         MR = M * ffparm[:, 2] # FIXME: Possibly column 1.
i = r_[range(self._Pg.i1, self._Pg.iN + 1),                range(self._Qg.i1, self._Qg.iN + 1)]   d2f = csr_matrix((vstack([d2f_dPg2, d2f_dQg2]).toarray().flatten(),                           (i, i)), shape=(self._nxyz, self._nxyz))         return d2f  
dSbus_dVm, dSbus_dVa = self.om.case.dSbus_dV(self._Ybus, V)   i_gbus = [gen.bus._i for gen in self._gn]         neg_Cg = csr_matrix((-ones(self._ng),                              (i_gbus, range(self._ng))),                              (self._nb, self._ng))   # Transposed Jacobian of the power balance equality constraints.         dg = lil_matrix((self._nxyz, 2 * self._nb))   blank = csr_matrix((self._nb, self._ng))
hstack([Gpva, Gpvv])]).real +                 vstack([hstack([Gqaa, Gqav]),                         hstack([Gqva, Gqvv])]).imag,                 csr_matrix((2 * self._nb, nxtra))]),             hstack([                 csr_matrix((nxtra, 2 * self._nb)),                 csr_matrix((nxtra, nxtra))
f = [e.from_bus._i for e in self._ln]             t = [e.to_bus._i for e in self._ln]             # Line-bus connection matrices.             Cf = csr_matrix((ones(self._nl), (range(self._nl), f)), (self._nl, self._nb))             Ct = csr_matrix((ones(self._nl), (range(self._nl), t)), (self._nl, self._nb))             dSf_dVa, dSf_dVm, dSt_dVa, dSt_dVm, Sf, St = \                 self.om.case.dSbr_dV(self._Yf, self._Yt, V)
hstack([Hfva, Hfvv])]) +                 vstack([hstack([Htaa, Htav]),                         hstack([Htva, Htvv])]),                 csr_matrix((2 * self._nb, nxtra))             ]),             hstack([                 csr_matrix((nxtra, 2 * self._nb)),                 csr_matrix((nxtra, nxtra))
src/p/y/pyamg-1.0.0/pyamg/aggregation/smooth.py     pyamg ( Download )
"""Methods to smooth tentative prolongation operators"""   __docformat__ = "restructuredtext en"   import numpy from scipy.sparse import csr_matrix, isspmatrix_csr, bsr_matrix, isspmatrix_bsr from scipy.linalg import pinv2
raise TypeError("T must be csr_matrix or bsr_matrix")   if Atilde is None:         AtildeCopy = csr_matrix( (numpy.ones(len(A.indices)), A.indices.copy(), A.indptr.copy()), shape=(A.shape[0]/A.blocksize[0], A.shape[1]/A.blocksize[1]))     else:         AtildeCopy = Atilde.copy()  
#====================================================================     # Expand the allowed sparsity pattern for P through multiplication by Atilde     T.sort_indices()     Sparsity_Pattern = csr_matrix( (numpy.ones(T.indices.shape), T.indices, T.indptr),                                      shape=(T.shape[0]/T.blocksize[0],T.shape[1]/T.blocksize[1])  )     AtildeCopy.data[:] = 1.0     for i in range(degree):
