Gunter Winkler | 1 Oct 17:07
Re: Linear algerbra element type requirements
Gunter Winkler <guwi17 <at> gmx.de>
2003-10-01 15:07:27 GMT
Am Mittwoch, 1. Oktober 2003 14:42 schrieb Michael Stevens: > Hi Joerg, > > >To get full functionality you need a field, yes. That means to > > define appropriate operators to fulfill the requirements in > > concepts.hpp and to define appropriate ublas::type_traits. For > > mixed operations one needs some more promote_traits, too. > > > >The integration of boost::interval could guide. > > > >Nevertheless there could be some useful non-standard applications. > > All a lot of work!! I think the crucuial point is that there are no > useful definitions of matrices and their operators that form a field. > Probably this is why linear algebra is considerbly harder then > ordinary algebra! > > Even if one fulfills all the type requirements, I still see many > dangers when in comes to the algebraic assumptions made by the > algorithm in uBLAS. I think it is a lot to ask of a Linear Algebra > library to work with types where no Linear Algebra exists!  I think requiring the underlying data type of ublas::matrix and  ublas::vector to form a field is to much for most operations. For most  common operators we can drop the requirement to commute. Lets look at  the list of expressions:  v = op(v) unary vector expressions are directly promoted to the value_type  v = op(v,v) binary vector expression are computed element by element, thus they are  promoted to the value_type  m = op(v,v) outer operations are computed element by element like  m(i,j)=op(v(i),v(j)), thus we need to define an outer operation mapping  two vector::value_types to the matrix::value_type.  v = op(s,v) scalar operations require s to be a scalar, which may differ from  vector::value_type. The operation is done element wise, where we need  to define op(s,v(i)). Thus scaling is promoted to the underlying  value_type.  s=op(v) vector reductions like sum and norms are really special functions that  should not be expected to work for non-scalar value_types. (sum and  norm_1 should still work, since they only require abs() and operator+()  of the value_type)  s = op(v,v) inner operations are computed as sum(v(i)*v(i)) therefore requiring an  (inner) product that maps to vector::value_type to a scalar. We could  define the operator: scalar_type operator*(vector::value_type,  vector::value_type) for a known type if necessary, but there is no  general way to fix this. Alternatively we could change the definition  of vector_inner_prod::operator()(...,abstract) to use t +=  inner_prod(e1()(i), e2()(i)) and give specializations for all  float/integer types. (Which is quite pragmatic...)  In the current implementation all these operations preserve the order of  all operands. So we only use that + is a commutative group and the  multiplication with a scalar is well defined and associative.  now matrix operations:  m = op(m) most unary operations are directly promoted to the underlying  value_type. Only trans() and herm() do not transpose the elements.  Changing matrix_unary2::operator()(...) to   const_reference operator () (size_type i, size_type j) const {     return functor_type () (trans(e_ (j, i)));    } and defining   inline double trans(const double x) { return x; } fixes both operators.  m = op(m,m) again + and - are promoted to the underlying value_type. For matrix  multiplication only sums of m(i,j)*m(j,k) which could be promoted to  the underlying type if we define  value_type operator*(value_type, value_type) or replace the product by  prod(m(i,j),m(j,k)) and define prod for all standard types as  template<class T> prod(const T& x, const T& y) { return x*y; } which is less special than prod(matrix_expression<T1>,  matrix_expression<T2>)  v = op(m,v) similar to matrix-matrix-multiplies, matrix-vector multiplies can be  implemented for more types. This already worked.  Again: The current implementation preserves the order of all operands.  using the above ideas I was able to implement all necessary operations  to solve systems of linear equations of matrix<tiny_matrix> *  vector<tiny_vector>. I did not try sparse_matrix<tiny_matrix>, yet.  This would probably require heavy modifications of the sparse_element  class. > As a side issue, I still think type_traits are a far too heavy weight > mechanism for the zero equality test mechanism. > From memory, I think one of the requirements for a field is that the > type has a Zero. Since there is a well known Zero (integer literal 0) > in C++ which is convertible to all built in types it seems sensible > to use this. I realise that this requires the scaler UDT to define a > conversion constructor from 'int'. Mathematically this seems sound to > me and a lot more logical then special type traits mechansim.  I think the default contructor is a better "zero" type because all  standard types default contruct to zero (when used like: double t =  double();) and this is extendable to "improved" scalar types like small  vectors and matrices.  regards Gunter
