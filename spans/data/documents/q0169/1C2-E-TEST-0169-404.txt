5/10/2010 
Caching the Vector Using Images
The ATI Stream SDK v2.1 contains support for OpenCL™ images, which can provide additional memory bandwidth in certain cases by using the texture caches on GPUs, coupled with texture sampling hardware for reading from these caches. In our case, the vector x is an ideal candidate for OpenCL™ images. It is heavily reused, since each work-item loads as many elements from x as there are diagonals in our matrix, and x is also fairly small. Not all OpenCL™ runtimes and devices support images. OpenCL™ image support can be detected by using clDeviceGetInfo() and examining CL_DEVICE_IMAGE_SUPPORT.
There are strict limits on the size and data types of objects which can be placed into images. In our case, the ATI Radeon 5870 GPU supports 2-D images up to 8192x8192 pixels, where each pixel is a float4 vector (in graphics, RGBA components are often used to describe each pixel). We can repurpose this machinery for holding the vector x, as long as x is less than 8192*8192*4 elements - which it obviously is, since we have limited memory on the device, and the matrix to match such a vector would be too large to fit in device memory.
The vector x is naturally a 1-D object, but we can conceive of it as a 2-D image just by imposing a 2-D coordinate system of float4 elements on the vector. The standard way to do this is to define a width, and then generate coordinates: u, v = (pos % width, pos / width). In our case, since there is no natural width to our 1-D vector, we can choose the width arbitrarily. Noting that the modulus and integer division operations are dramatically simplified to bit-masking and shifting when the denominator is a power of 2, we choose to layout the image so that it is a power of 2 pixels wide. Additionally, each pixel holds four entries of the vector, since it is an RGBA image type. This complicates addressing the image somewhat, since each work-item will be accessing four contiguous elements of the vector, but not necessarily the four elements that are held in a particular pixel. The unaligned nature of these accesses is data dependent: it depends on the location of the diagonals in the original matrix (or with our data structure, the values in the offsets array), so it is not possible to guarantee pixel-aligned accesses to the image. Instead, we must deal with four special cases: aligned, misaligned by 1 float, misaligned by 2 floats, and misaligned by 3 floats. In the misaligned cases, we perform two reads from the image, and then assemble our float4 sampling of the vector by swizzling in the appropriate elements. In this configuration, the texture sampler takes care of accesses from the image which might be out of bounds by clamping to a default value of (0, 0, 0, 0), which is exactly what we need and removes some conditionals. Below is the code needed to read our vector elements from the image representation of the vector.
float4 unaligned_read_from_image(                                 //OpenCL Image                                 __read_only image2d_t vector,                                  //how many bits to shift for division                                  //(log_2 of the image width)                                 __const int log_vector_width,                                 //Boolean mask for modulus                                 //(the image width - 1)                                __const int width_mask,                                //The unaligned index of the first element we need                                __const int col) {   const sampler_t smp = CLK_NORMALIZED_COORDS_FALSE | //Natural coordinates     CLK_ADDRESS_CLAMP | //Clamp to zeros     CLK_FILTER_NEAREST; //Don't interpolate   int alignment = col % 4;   if (alignment < 0) alignment += 4; //col may be negative   int rgbcol = col >> 2;   float4 v;   if (alignment == 0) { //Fully aligned to pixels in image     int2 coord;     coord.x = rgbcol & width_mask;     coord.y = rgbcol >> log_vector_width;     v = read_imagef(vector, smp, coord);   } else if (alignment == 1) { //Off by one pixel     int2 coord0;     coord0.x = rgbcol & width_mask;     coord0.y = rgbcol >> log_vector_width;     int2 coord1;     rgbcol++;     coord1.x = rgbcol & width_mask;     coord1.y = rgbcol >> log_vector_width;     float4 v0 = read_imagef(vector, smp, coord0);     float4 v1 = read_imagef(vector, smp, coord1);     v.xyz = v0.yzw;     v.w = v1.x;   } else if (alignment == 2) { //Off by two pixels     int2 coord0;     coord0.x = rgbcol & width_mask;     coord0.y = rgbcol >> log_vector_width;     int2 coord1;     rgbcol++;     coord1.x = rgbcol & width_mask;     coord1.y = rgbcol >> log_vector_width;     float4 v0 = read_imagef(vector, smp, coord0);     float4 v1 = read_imagef(vector, smp, coord1);     v.xy = v0.zw;     v.zw = v1.xy;   } else if (alignment == 3) { //Off by three pixels     int2 coord0;     coord0.x = rgbcol & width_mask;     coord0.y = rgbcol >> log_vector_width;     int2 coord1;     rgbcol++;     coord1.x = rgbcol & width_mask;     coord1.y = rgbcol >> log_vector_width;     float4 v0 = read_imagef(vector, smp, coord0);         float4 v1 = read_imagef(vector, smp, coord1);     v.x = v0.w;     v.yzw = v1.xyz;   }   return v; }
And here is our final code variant. It's similar to the vectorized version, except for the way we read from the vector x.
__kernel void dia_spmv(__global float *A, __const int pitch_A,    __const int rows,   __const int diags, __global int *offsets,   __readonly image2d_t *x,    __const int log_vector_width,   __const int width_mask, __global float *y) {   __local int l_offsets[256];   int local_id = get_local_id(0);   int offset_id = local_id;   while ((offset_id < diags) && (offset_id < 256)) {     l_offsets[offset_id] = offsets[offset_id];     offset_id = offset_id + get_local_size(0);   }   barrier(CLK_LOCAL_MEM_FENCE);               unsigned int row = get_global_id(0) * 4;   float4 accumulator = 0;   int d = 0;   int matrix_offset = A + row;     if (row < rows) {     while (d < diags) {       float4 m = vload4(0, matrix_offset);       int col = row + l_offsets[d];       float4 v = unaligned_read_from_image(x, log_vector_width, width_mask, col);       accumulator += m * v;       d++;       matrix_offset += pitch_A;     }     vstore4(accumulator, get_global_id(0), y);   } }
Performance of OpenCL™ C Kernel Using Images
Figure 11 shows the resulting performance, which improves by another 76%, to reach an average of 49.2 GFLOP/s. Since we moved accesses of the vector to use the image hardware, we no longer need to perform so many accesses of the vector from off-chip memory. Assuming perfect caching of the vector, we need only read one float from memory for every 2 floating-point operations. This leads us to a bound of 2 FLOP/4 Bytes * 153.6 GB/s = 76.8 GFLOP/s, putting our final code variant at 64% of its bound.
Figure 11: ATI Radeon HD 5870 GPU Performance Using Images
During the optimization process, we were able to improve the bound twice, by eliminating memory accesses to data structures that are relatively small and frequently used, but it's not possible to eliminate the final memory access, since each element of the matrix A is only used once, and the matrix itself is too large to fit into any structure we could use as an on-chip cache. At this point, we can be reasonably confident that our code is close to optimal. There may be other optimizations, like loop unrolling, etc., that we could try to apply, but since the compulsory loads from the matrix A will still need to be performed, such optimizations will only yield marginal benefits.
OpenCL™ and the OpenCL™ logo are trademarks of Apple Inc. used by permission by Khronos.
