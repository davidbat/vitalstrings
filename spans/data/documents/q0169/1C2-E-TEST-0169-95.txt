Operations on Sparse Matrices
 
As implied earlier, there are tricks that can be used to speed up matrix multiplication if the matrices are known to have particular properties.
One kind of matrix that can be multiplied quickly is a sparse matrix.  A sparse matrix, like a sparse array, is a matrix where most of the elements are the same value.  In most cases, the common value is zero, but this is not necessarily the case.  In this section, we'll begin by exploring how sparse matrices that are mostly zero can be multiplied quickly, but at the end we will see how the principles for handling these matrices can also be used to speed up operations on other kinds of sparse matrices.
Multiplying Sparse Matrices
A simple-minded approach to matrix multiplication is to blindly use algorithm 4.2 again, but instead of using the ordinary array operations to access to matrix elements, use the sparse array (or multilist) operations to access them:
1  void    mm_mul_sa (sa_t *A, sa_t *B, sa_t *C)   2  {   3          int i, j, k;   4          int sum;   5     6          for (i = 0; i < A->num_rows; i++) {   7                  for (j = 0; j < B->num_cols; j++) {   8                          sum = 0;   9                          for (k = 0; k < A->num_cols; k++) {  10                                  sum += saGet (A,i,k) * saGet (B,k,j);  11                          }  12                          saSet (C,i,j,sum);  13                  }  14          }  15  }
This is a step in the wrong direction, however: since saGet and saSet are generally O(n) operations themselves, the resulting algorithm is  in the worst case.
However, there is a way to speed this up considerably by changing the inner loop (in this code, the k loop) to take advantage of two key facts:
The product of any number and zero is zero.  Therefore, if  we know that either A[i][k] or B[k][j] is zero, we  can skip the multiplication and addition.
The loop strides through the actual (non-zero) elements in the  array in the same order that they appear in the linked lists  that are used to represent the array.  Therefore, instead of  starting at the base of each list (as saGet and saSet must do), we can keep track of where we are in each  list, so that we can find the next element very quickly.
[hbtp]
 
This algorithm is identical to algorithm 4.2 ,  except for the inner block, which is changed as follows:
1  void    mm_mul_sa_fast (sa_t *A, sa_t *B, sa_t *C)   2  {   3          int i, j, sum;   4          sa_cell_t *row_p, *col_p;   5     6          for (i = 0; i < A->num_rows; i++) {   7                  for (j = 0; j < B->num_cols; j++) {   8                          row_p = A->rows [i];   9                          col_p = B->cols [j];  10                          sum = 0;  11    12                          while ((row_p != NULL) && (col_p != NULL)) {  13                                  if (row_p->index == col_p->index) {  14                                          sum += row_p->value * col_p->value;  15                                          row_p = row_p->next;  16                                          col_p = col_p->next;  17                                  }  18                                  else if (row_p->index < col_p->index)  19                                          row_p = row_p->next;  20                                  else  21                                          col_p = col_p->next;  22                          }  23                          saSet (C, i, j, sum);  24                  }  25          }  26  }
The inner loop of algorithm 4.3 avoids trying each possible k (as algorithm 4.2 did) by moving down both the row and column lists in tandem, searching for elements in the row list that have the same index as elements in the column list.  Since the lists are kept in order by index, we know that we can do this in one scan through the lists.  Each iteration through the loop moves forward at least one position in one of the lists, so the loop terminates after at most R + C iterations (where R is the number of elements in the row list and C the number of elements in the column list).
