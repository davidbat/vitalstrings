None of the following tunnel types.
TUNNEL_TYPE_DIRECT
2
A packet is encapsulated directly within a normal IP header, with no intermediate header, and unicast to          the remote tunnel endpoint.
TUNNEL_TYPE_6TO4
11
An IPv6 packet is encapsulated directly within an IPv4 header, with no intermediate header, and unicast          to the destination determined by the 6to4 protocol.
TUNNEL_TYPE_ISATAP
13
An IPv6 packet is encapsulated directly within an IPv4 header, with no intermediate header, and unicast          to the destination determined by the ISATAP protocol.
TUNNEL_TYPE_TEREDO
Teredo encapsulation for IPv6 packets.
TUNNEL_TYPE_IPHTTPS
15
IP over HTTPS encapsulation for IPv6 packets.
Note  This enumeration value is only available on Windows 7,  Windows Server 2008 R2, and later.
 
Type: SOCKET_ADDRESS
The IPv6 address of the DHCPv6 server for the adapter address. This member is only applicable to an IPv6        adapter address configured using DHCPv6. This structure member is not currently supported and is reserved for future use.
Note  This structure member is only available on Windows Vista and later.
Dhcpv6ClientDuid
Type: BYTE[MAX_DHCPV6_DUID_LENGTH]
The DHCP unique identifier (DUID) for the DHCPv6 client. This member is only applicable to an IPv6 adapter        address configured using DHCPv6.
Note  This structure member is only available on Windows Vista and later.
Dhcpv6ClientDuidLength
Type: ULONG
The length, in bytes, of the DHCP unique identifier (DUID) for the DHCPv6 client. This member is only        applicable to an IPv6 adapter address configured using DHCPv6.
Note  This structure member is only available on Windows Vista and later.
Dhcpv6Iaid
Type: ULONG
The identifier for an identity association chosen by the DHCPv6 client. This member is only applicable to        an IPv6 adapter address configured using DHCPv6.
Note  This structure member is only available on Windows Vista and later.
FirstDnsSuffix
Type: PIP_ADAPTER_DNS_SUFFIX
A pointer to the first IP_ADAPTER_DNS_SUFFIX structure in a linked list of        DNS suffixes for the adapter.
Note  This structure member is only available on Windows Vista with SP1and later and on Windows Server 2008  and later.
Remarks
The GetAdaptersAddresses function retrieves       information for IPv4 and IPv6 addresses and returns this information as a linked list of IP_ADAPTER_ADDRESSES structures
The adapter index values specified in the IfIndex and Ipv6IfIndex members may change when an adapter is       disabled and then enabled, or under other circumstances, and should not be considered persistent.
The values for the IfType member are defined in the Ipifcons.h header file. Only the possible values listed in the description of the IfType member are currently supported.
The size of the IP_ADAPTER_ADDRESSES structure       changed on Windows XP with SP1 and later. The size of the IP_ADAPTER_ADDRESSES structure also changed on       Windows Vista and later. The size of the IP_ADAPTER_ADDRESSES structure also changed on       Windows Vista with SP1and later and onWindows Server 2008 and later. The Length member should be used to determine       which version of the IP_ADAPTER_ADDRESSES structure is being used.
The version of the IP_ADAPTER_ADDRESSES structure on Windows XP with SP1 and later has the following new members added: Ipv6IfIndex, ZoneIndices, and FirstPrefix.
The version of the IP_ADAPTER_ADDRESSES structure on Windows Vista and later has the following new members added: TransmitLinkSpeed, ReceiveLinkSpeed, FirstWinsServerAddress, FirstGatewayAddress, Ipv4Metric, Ipv6Metric, Luid, Dhcpv4Server, CompartmentId, NetworkGuid, ConnectionType, TunnelType, Dhcpv6Server, Dhcpv6ClientDuid, Dhcpv6ClientDuidLength, and Dhcpv6Iaid.
The version of the IP_ADAPTER_ADDRESSES structure on Windows Vista with SP1and later and on Windows Server 2008 and later has the following new member added: FirstDnsSuffix.
The Ipv4Metric and Ipv6Metric members are used to       prioritize route metrics for routes connected to multiple interfaces on the local computer.
The order of  linked IP_ADAPTER_UNICAST_ADDRESS structures pointed to by the FirstUnicastAddress member that are returned by the GetAdaptersAddresses function does not reflect the order that IP addresses were added to an adapter and may vary between versions of Windows. Similarly, the order of linked IP_ADAPTER_ANYCAST_ADDRESS structures pointed to by the FirstAnycastAddress member and the order of linked IP_ADAPTER_MULTICAST_ADDRESS structures pointed to by the FirstMulticastAddress member do not reflect the order that IP addresses were added to an adapter and may vary between versions of Windows.
In addition, the linked IP_ADAPTER_UNICAST_ADDRESS structures pointed to by the FirstUnicastAddress member and the linked IP_ADAPTER_PREFIX structures pointed to by the FirstPrefix member are maintained as separate internal linked lists by the operating system. As a result, the order of linked IP_ADAPTER_UNICAST_ADDRESS structures pointed to by the FirstUnicastAddress member does not have any relationship with the order of linked IP_ADAPTER_PREFIX structures pointed to by the FirstPrefix member.
On Windows Vista and later, the linked IP_ADAPTER_PREFIX structures pointed to by the FirstPrefix member include three IP adapter prefixes for each IP address assigned to the adapter. These include the host IP address prefix, the subnet IP address prefix, and the subnet broadcast IP address prefix. In addition, for each adapter there is a multicast address prefix and a broadcast address prefix.
On Windows XP with SP1 and later prior to Windows Vista, the linked IP_ADAPTER_PREFIX structures pointed to by the FirstPrefix member include only a single IP adapter prefix for each IP address assigned to the adapter.
In the Windows SDK, the version of the structure for use on Windows Vista and later is  defined as IP_ADAPTER_ADDRESSES_LH. In the       Microsoft Windows Software Development Kit (SDK), the version of this structure to be used on earlier systems including       Windows XP with SP1 and later is defined as IP_ADAPTER_ADDRESSES_XP. When compiling an       application if the target platform is Windows Vista and later       (NTDDI_VERSION >= NTDDI_LONGHORN, _WIN32_WINNT >= 0x0600, or WINVER >= 0x0600), the IP_ADAPTER_ADDRESSES_LH structure is typedefed to       the IP_ADAPTER_ADDRESSES structure. When compiling an application if the target       platform is not Windows Vista and later, the IP_ADAPTER_ADDRESSES_XP structure is typedefed to       the IP_ADAPTER_ADDRESSES structure.
The SOCKET_ADDRESS structure is used in the IP_ADAPTER_ADDRESSES structure. On the       Windows SDK released for Windows Vista and later, the organization of header files has       changed and the SOCKET_ADDRESS structure is defined       in the Ws2def.h header file which is automatically included by the Winsock2.h header file. On the Platform Software Development Kit (SDK) released for       Windows Server 2003 and Windows XP, the SOCKET_ADDRESS structure is declared in the Winsock2.h header file. In order to use the IP_ADAPTER_ADDRESSES structure, the Winsock2.h header file must be included before the Iphlpapi.h header file.
Examples
This example retrieves the IP_ADAPTER_ADDRESSES structure for the adapters associated with the system and prints some members  for each adapter interface.
Copy
#include <winsock2.h> #include <iphlpapi.h> #include <stdio.h> #pragma comment(lib, "IPHLPAPI.lib") #define MALLOC(x) HeapAlloc(GetProcessHeap(), 0, (x)) #define FREE(x) HeapFree(GetProcessHeap(), 0, (x)) /* Note: could also use malloc() and free() */ int __cdecl main(int argc, char **argv) { /* Declare and initialize variables */ DWORD dwSize = 0;     DWORD dwRetVal = 0;      unsigned int i = 0; // Set the flags to pass to GetAdaptersAddresses ULONG flags = GAA_FLAG_INCLUDE_PREFIX; // default to unspecified address family (both) ULONG family = AF_UNSPEC;      LPVOID lpMsgBuf = NULL;      PIP_ADAPTER_ADDRESSES pAddresses = NULL;     ULONG outBufLen = 0;      PIP_ADAPTER_ADDRESSES pCurrAddresses = NULL; PIP_ADAPTER_UNICAST_ADDRESS pUnicast = NULL;     PIP_ADAPTER_ANYCAST_ADDRESS pAnycast = NULL;     PIP_ADAPTER_MULTICAST_ADDRESS pMulticast = NULL;     IP_ADAPTER_DNS_SERVER_ADDRESS *pDnServer = NULL;     IP_ADAPTER_PREFIX *pPrefix = NULL; if (argc != 2) {         printf(" Usage: getadapteraddresses family\n");         printf("        getadapteraddresses 4 (for IPv4)\n");         printf("        getadapteraddresses 6 (for IPv6)\n");         printf("        getadapteraddresses A (for both IPv4 and IPv6)\n");         exit(1);     } if (atoi(argv[1]) == 4)         family = AF_INET; else if (atoi(argv[1]) == 6)         family = AF_INET6;      outBufLen = sizeof (IP_ADAPTER_ADDRESSES);     pAddresses = (IP_ADAPTER_ADDRESSES *) MALLOC(outBufLen); // Make an initial call to GetAdaptersAddresses to get the // size needed into the outBufLen variable if (GetAdaptersAddresses(family, flags, NULL, pAddresses, &outBufLen)         == ERROR_BUFFER_OVERFLOW) {         FREE(pAddresses);         pAddresses = (IP_ADAPTER_ADDRESSES *) MALLOC(outBufLen);     } if (pAddresses == NULL) {         printf("Memory allocation failed for IP_ADAPTER_ADDRESSES struct\n");         exit(1);     } // Make a second call to GetAdapters Addresses to get the // actual data we want printf("Memory allocated for GetAdapterAddresses = %d bytes\n", outBufLen);     printf("Calling GetAdaptersAddresses function with family = "); if (family == AF_INET)         printf("AF_INET\n"); if (family == AF_INET6)         printf("AF_INET6\n"); if (family == AF_UNSPEC)         printf("AF_UNSPEC\n\n");      dwRetVal =         GetAdaptersAddresses(family, flags, NULL, pAddresses, &outBufLen); if (dwRetVal == NO_ERROR) { // If successful, output some information from the data we received pCurrAddresses = pAddresses; while (pCurrAddresses) {             printf("\tLength of the IP_ADAPTER_ADDRESS struct: %ld\n",                    pCurrAddresses->Length);             printf("\tIfIndex (IPv4 interface): %u\n", pCurrAddresses->IfIndex);             printf("\tAdapter name: %s\n", pCurrAddresses->AdapterName);              pUnicast = pCurrAddresses->FirstUnicastAddress; if (pUnicast != NULL) { for (i = 0; pUnicast != NULL; i++)                     pUnicast = pUnicast->Next;                 printf("\tNumber of Unicast Addresses: %d\n", i);             } else printf("\tNo Unicast Addresses\n");              pAnycast = pCurrAddresses->FirstAnycastAddress; if (pAnycast) { for (i = 0; pAnycast != NULL; i++)                     pAnycast = pAnycast->Next;                 printf("\tNumber of Anycast Addresses: %d\n", i); } else printf("\tNo Anycast Addresses\n");              pMulticast = pCurrAddresses->FirstMulticastAddress; if (pMulticast) { for (i = 0; pMulticast != NULL; i++)                     pMulticast = pMulticast->Next;                 printf("\tNumber of Multicast Addresses: %d\n", i);             } else printf("\tNo Multicast Addresses\n");              pDnServer = pCurrAddresses->FirstDnsServerAddress; if (pDnServer) { for (i = 0; pDnServer != NULL; i++)                     pDnServer = pDnServer->Next;                 printf("\tNumber of DNS Server Addresses: %d\n", i);             } else printf("\tNo DNS Server Addresses\n");              printf("\tDNS Suffix: %wS\n", pCurrAddresses->DnsSuffix);             printf("\tDescription: %wS\n", pCurrAddresses->Description);             printf("\tFriendly name: %wS\n", pCurrAddresses->FriendlyName); if (pCurrAddresses->PhysicalAddressLength != 0) {                 printf("\tPhysical address: "); for (i = 0; i < pCurrAddresses->PhysicalAddressLength;                      i++) { if (i == (pCurrAddresses->PhysicalAddressLength - 1))                         printf("%.2X\n",                                (int) pCurrAddresses->PhysicalAddress[i]); else printf("%.2X-",                                (int) pCurrAddresses->PhysicalAddress[i]);                 }             }             printf("\tFlags: %ld\n", pCurrAddresses->Flags);             printf("\tMtu: %lu\n", pCurrAddresses->Mtu);             printf("\tIfType: %ld\n", pCurrAddresses->IfType);             printf("\tOperStatus: %ld\n", pCurrAddresses->OperStatus);             printf("\tIpv6IfIndex (IPv6 interface): %u\n",                    pCurrAddresses->Ipv6IfIndex);             printf("\tZoneIndices (hex): "); for (i = 0; i < 16; i++)                 printf("%lx ", pCurrAddresses->ZoneIndices[i]);             printf("\n");              pPrefix = pCurrAddresses->FirstPrefix; if (pPrefix) { for (i = 0; pPrefix != NULL; i++)                     pPrefix = pPrefix->Next;                 printf("\tNumber of IP Adapter Prefix entries: %d\n", i);             } else printf("\tNo IP Adapter Prefix entries\n");              printf("\n");              pCurrAddresses = pCurrAddresses->Next;         }     } else {         printf("Call to GetAdaptersAddresses failed with error: %d\n",                dwRetVal); if (dwRetVal == ERROR_NO_DATA)             printf("\tNo addresses were found for the requested parameters\n"); else { if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, dwRetVal, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language (LPTSTR) & lpMsgBuf, 0, NULL)) {                 printf("\tError: %s", lpMsgBuf);                 LocalFree(lpMsgBuf);                 FREE(pAddresses);                 exit(1);             }         }     }     FREE(pAddresses); return 0; }
Requirements
