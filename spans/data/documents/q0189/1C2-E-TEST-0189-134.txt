Translate
Figure 6-9 Affine transforms
A single transform combines any number of these operations into a 3x3 matrix. iOS has functions to support rotation, scaling, and translation. If you want shear, you’ll have to write the matrix yourself. (You can also use CGAffineTransformMakeShear from Jeff LaMarche; see “Further Reading” at the end of the chapter.) Transforms can dramatically simplify and speed up your code. Often it is much easier and faster to draw in a simple coordinate space around the origin and then to scale, rotate, and translate your drawing to where you want it. For instance, FlowerView includes a lot of code like this: CGPointMake(radius * 2 + xOffset, radius + yOffset) That’s a lot of typing, a lot of math, and a lot of things to keep straight in your head. What if instead you just draw it in a 41×4 box as shown in Figure 6-10? Now all the interesting points fall on nice, easy coordinates like {0,1} and {1,0}. The following code shows how to draw using this transform. Compare the highlighted sections with the FlowerView code earlier in this chapter.
120 Part II: Getting the Most Out of Everyday Tools
0, 0
Figure 6-10 Drawing FlowerView in a 4×4 box
FlowerTransformView.m (Transforms)
static inline CGAffineTransform CGAffineTransformMakeScaleTranslate(CGFloat sx, CGFloat sy, CGFloat dx, CGFloat dy) { return CGAffineTransformMake(sx, 0.f, 0.f, sy, dx, dy); } - (void)drawRect:(CGRect)rect { CGSize size = self.bounds.size; CGFloat margin = 10; [[UIColor redColor] set]; UIBezierPath *path = [UIBezierPath bezierPath]; [path addArcWithCenter:CGPointMake(0, -1) radius:1 startAngle:-M_PI endAngle:0 clockwise:YES]; [path addArcWithCenter:CGPointMake(1, 0) radius:1 startAngle:-M_PI_2 endAngle:M_PI_2 clockwise:YES]; [path addArcWithCenter:CGPointMake(0, 1) radius:1 startAngle:0 endAngle:M_PI
Chapter 6: Better Drawing 121
clockwise:YES]; [path addArcWithCenter:CGPointMake(-1, 0) radius:1 startAngle:M_PI_2 endAngle:-M_PI_2 clockwise:YES]; [path closePath]; CGFloat scale = floor((MIN(size.height, size.width) - margin) / 4); CGAffineTransform transform; transform = CGAffineTransformMakeScaleTranslate(scale, scale, size.width/2, size.height/2); [path applyTransform:transform]; [path fill]; } When you’re done constructing your path, you compute a transform to move it into your view’s coordinate space. You scale it by the size you want divided by the size it currently is (4), and you translate it to the center of the view. The utility function CGAffineTransformMakeScaleTranslate isn’t just for speed (although it is faster). It’s easier to get the transform correct this way. If you try to build up the transform one step at a time, each step affects later steps. Scaling and then translating is not the same as translating and then scaling. If you build the matrix all at once, you don’t have to worry about that. This technique can be used to draw complicated shapes at unusual angles. For instance, to draw an arrow pointing to the upper right, it’s generally easier to draw it pointing to the right and then rotate it. You have a choice between transforming the path using applyTransform: and transforming the whole view by setting the transform property. Which is best depends on the situation, but I usually prefer to transform the path rather than the view when practical. Modifying the view’s transform makes the results of frame and bounds more difficult to interpret, so I avoid it when I can. As you see in the following section, you can also transform the current context, which sometimes is the best approach.
Drawing with Core Graphics
Core Graphics, sometimes called Quartz 2D or just Quartz, is the main drawing system in iOS. It provides destination-independent drawing, so you can use the same commands to draw to the screen, layer, bitmap, PDF, or printer. Anything starting with CG is part of Core Graphics. Figure 6-11 and the following code provide an example of a simple scrolling graph.
GraphView.h (Graph)
@interface GraphView : UIView @property (nonatomic, readonly, strong) NSMutableArray *values; @property (nonatomic, readonly, strong) NSTimer *timer; @end
122 Part II: Getting the Most Out of Everyday Tools
Figure 6-11 Simple scrolling graph
GraphView.m (Graph)
#import “GraphView.h” @implementation GraphView @synthesize values=values_; @synthesize timer=timer_; const double kXScale = 5.0; const double kYScale = 100.0; - (void)awakeFromNib { values_ = [NSMutableArray array];
double y = [[self. y * kYScale + yOffset).values count] .Chapter 6: Better Drawing 123 timer_ = [NSTimer scheduledTimerWithTimeInterval:0. CGContextAddLineToPoint(ctx. [[UIColor redColor] CGColor]). x < [self.height / 2.values count].size. ++x) { y = [[self.25 target:self selector:@selector(updateValues:) userInfo:nil repeats:YES]. CGContextMoveToPoint(ctx.(void)dealloc { [timer_ invalidate]. for (NSUInteger x = 1. [self.values addObject: [NSNumber numberWithDouble:nextValue]].(void)drawRect:(CGRect)rect { if ([self. } [self setNeedsDisplay]. [self.(void)updateValues:(NSTimer *)timer { double nextValue = sin(CFAbsoluteTimeGetCurrent()) + ((double)rand()/(double)RAND_MAX). } . } @end  .bounds. CGContextSetStrokeColorWithColor(ctx. 0. NSUInteger maxValues = floorl(self. } CGContextRef ctx = UIGraphicsGetCurrentContext(). CGContextSetLineJoin(ctx. 5). x * kXScale.width / kXScale). } .maxValues)]. kCGLineJoinRound).values removeObjectsInRange: NSMakeRange(0.values objectAtIndex:0] doubleValue].values count] == 0) { return.bounds. } CGContextStrokePath(ctx). y * kYScale + yOffset).values count] > maxValues) { [self.size. if ([self. } .values objectAtIndex:x] doubleValue]. CGContextSetLineWidth(ctx. CGFloat yOffset = self.
m (Graph) . even under ARC. Note that the “current path” is an attribute of the CGContext. it adds a line to that point in the graph and finally strokes the path. x. Instead. y).bounds. CGPathAddLineToPoint(path. [[UIColor redColor] CGColor]). For full details. CGPathRelease(path).values objectAtIndex:x] doubleValue]. For each number. kCGLineJoinRound). this code adds a new number to the end of the data and removes an old number from the beginning. Note the use of CGPathRelease. CGContextStrokePath(ctx).values count].(void)drawRect:(CGRect)rect { if ([self. y).  Core Graphics uses the Core Foundation memory management rules. 5).height / 2. double y = [[self. 0. CGContextSetStrokeColorWithColor(ctx. } CGContextRef ctx = UIGraphicsGetCurrentContext(). CGContextSetLineJoin(ctx. CGFloat yOffset = self. x < [self. CGMutablePathRef path = CGPathCreateMutable(). &transform.values count] == 0) { return. kYScale.124 Part II: Getting the Most Out of Everyday Tools Every second. see Chapter 19.  . path). } Using a CGPath this way allows you to simplify your math with a transform. You can’t apply a scaling transform to the view or the context because that would distort the line. you could use a CGPath as shown in the following code. not a separate object.values objectAtIndex:0] doubleValue]. &transform. Then it marks the view as dirty with setNeedsDisplay. The drawing code gets the current context. 0. CGContextSetLineWidth(ctx. ++x) { y = [[self.  GraphView. CGAffineTransform transform = CGAffineTransformMakeScaleTranslate(kXScale. sets various advanced line drawing options not available with UIBezierPath. for (NSUInteger x = 1. Core Foundation objects require manual retain and release. CGPathMoveToPoint(path. yOffset). and moves to the first point.size. } CGContextAddPath(ctx.
you may have a function to draw a specific shape with a specific color. -1.0f. When you draw. UIRectFill(CGRectMake(10.0f. iOS already avoids calling drawRect: except when the view is dirty. To avoid side effects. There is only one stroke pen. and then translate it. UIKit and Core Graphics can generally intermix without issue.  Mixing UIKit and Core Graphics Within drawRec:. As long as you use the context returned by UIGraphicsGetCurrentContext inside of drawRect:. This moves (translates) the height of the context. while Core Graphics uses a lower-left origin (LLO) system by default. A context includes a lot of information such as a pen color.0f). -1. height). and more. You can either do your math backward or you can flip the context: CGContextTranslateCTM(ctx. CGContextSaveGState remembers the current state of a context.0f.Chapter 6: Better Drawing 125 You may be tempted to cache the CGPath here so that you don’t have to compute it every time. Here’s an example of CGContextSaveGState. CGContextTranslateCTM(ctx. text color. but outside of drawRect: you may find that things drawn with Core Graphics appear upside down. this would change things for your caller. CGContextRestoreGState(UIGraphicsGetCurrentContext()). everything is fine because this context is already flipped. When going from UIKit to Core Graphics. It then changes the pen color to black and restores the context. Sometimes you may want to modify the context and then put it back the way you found it. First flip it. you need to calculate a new path. But if you create your own context using functions like CGBitmapContextCreate. 100)). 1.0f). 1. [[UIColor redColor] setStroke]. // Red This code sets the stroke pen color to red and saves off the context.  Managing Graphics Contexts Before calling drawRect:. -height). transform. 0. current font. the transform is reversed: CGContextScaleCTM(ctx. you can push and pop the context using CGContextSaveGState and CGContextRestoreGState. CGContextScaleCTM(ctx. Do not confuse this with the similar-sounding UIGraphicsPushContext and UIGraphicsPopContext. the drawing system creates a graphics context. When the data changes. and then flips it using a negative scale. They do not do the same thing. the pen is red again. UIGraphicsPushContext changes the current context. For instance. (CGContext). 10. but in this case it wouldn’t help. it’ll be LLO.0f.  . CGContextSaveGState(UIGraphicsGetCurrentContext()). [[UIColor blackColor] setStroke]. so when you change the color. UIKit uses an upper-left origin (ULO) coordinate system. which only happens when the data changes. That’s a good instinct. Caching the old path in this case would just complicate the code and waste memory. 0. 100.
UIGraphicsBeginImageContext(CGSizeMake(kImageWidth. 100. 100)). 10. Say you are in the middle of drawing something into the current view context. that’s just what you want. // Next line is nonsense UIGraphicsPushContext(UIGraphicsGetCurrentContext()). [[UIColor redColor] set]. UIFont *font = [UIFont boldSystemFontOfSize:17. Most of the time. flipping the coordinate system. This only matters in cases where you want to draw into the new bitmap context with UIKit.CGImage. you’d want to save off the current UIKit context. which is almost certainly not what was meant. kImageWidth. // Black In this case. creating the new context.m (Drawing) .126 Part II: Getting the Most Out of Everyday Tools The following code illustrates a common error. you don’t need to push or pop contexts because Core Graphics functions take the context as a parameter. If you want to use UIKit to do any of your drawing. [[UIColor blackColor] setStroke]. kImageHeight) withFont:font]. The result is shown in Figure 6-12. That’s what UIGraphicsPopContext does. You then change the pen color to black. UIGraphicsPopContext(). It takes care of pushing the old context. textImage = UIGraphicsGetImageFromCurrentImageContext(). kImageHeight)).). This is a pretty useful and common operation. You now will draw a black rectangle. and pop the context back to the original (which effectively does nothing). and making it the current context.0]. and switch to a completely new drawing context. Here’s an example of how to create an image and return it using UIGraphicsBeginImageContext. but to switch contexts entirely. That’s what UIGraphicsPushContext does. UIRectFill(CGRectMake(10.(UIImage *)reverseImageForText:(NSString *)text { const size_t kImageWidth = 200. and now want to draw something completely different into a bitmap context.  MYView. const size_t kImageHeight = 200. CGImageRef textImage = NULL.  . As long as you use Core Graphics functions. you set the pen color to red and then switch context to the current context. etc. allocating memory for a new context. The purpose of UIGraphicsPushContext is not to save the current state of the context (pen color. which does nothing useful. [[UIColor redColor] setStroke]. When you finish creating your bitmap. you pop the stack and get your old context back. including all the drawing that had been done. 0. It’s so common that Apple has made a shortcut for it called UIGraphicsBeginImageContext. [text drawInRect:CGRectMake(0. line width.
}  Figure 6-12 Text drawn with reverseImageForText:  .0 orientation:UIImageOrientationUpMirrored].Chapter 6: Better Drawing 127 UIGraphicsEndImageContext(). return [UIImage imageWithCGImage:textImage scale:1.
It caches an image of your view and moves.” Alternatively. The most common cause for drawRect: running is when you call setNeedsDisplay. At the lowest level. then Photoshop is often the only way to go. and when possible you should use them rather than custom drawing. The following sections cover a few things to keep in mind when using UIView to keep it drawing as well as it can. Finally. you can cache static elements like CGFont or CGGradient objects so that you only generate them once. you can cache the result in a bitmap. you can use UIKit drawing methods like drawAtPoint: on background threads as long as you draw into your own CGContext and not the main view graphics context (the one returned by UIGraphicsGetCurrentContext). Using an appropriate contentMode lets the system adjust your view during rotation or resizing without calling drawRect:. If you want to partially redraw of a view. you should use CALayer (discussed in Chapter 7) or use subviews. Since iOS 4. Remember.  Caching and Background Drawing If you need to do a lot of calculations during your drawing. iOS does not perform partial view drawing. you can cache the entire result of a complex drawing operation. Fonts and gradients are useful to cache this way because they are often reused. practically. generally using UIGraphicsBeginImageContext as discussed in “Managing Graphics Contexts” earlier in this chapter. than calling it once. If you have an art department and plan to have extremely complex visual elements. which is discussed later in the section “CGLayer. The entire view will be redrawn. so don’t coalesce your calls. You may have heard that you must always draw on the main thread. iOS goes to great lengths to avoid calling drawRect:. Calling setNeedsDisplay many times in a single event loop is no more expensive. UIImageView is faster and uses less memory than anything you’re likely to put together in an afternoon with Core Graphics. such as UIGraphicsBeginImageContext. You should only access a given CGContext on one thread.  Custom Drawing Versus Prerendering There are two major approaches to managing complex drawing.  Avoid Drawing The fastest drawing is the drawing you never do. setNeedsDisplay just schedules the view to be redrawn. Often the best place to cache such a result is in a CGLayer. however. and setNeedsDisplayInRect: is the same as setNeedsDisplay. though. rotates. Beyond that. but this isn’t completely true. There are several UIKit functions that must only be called on the main thread. iOS is already doing that for you. For instance. you can cache the raw data you need rather than asking for it from your delegate every time. Much of this caching or precalculation can be done in the background.  . and scales it without any intervention from you. Avoid calling setNeedsDisplay unnecessarily. cache the results when you can. but you are free to create a CGBitmapContext object on any thread using CGBitmapCreateContext and draw into it. You can draw everything programmatically with CGPath and CGGradient. or you can prerender everything in a graphics program like Adobe Photoshop and display it as an image. Those familiar with Mac development may be familiar with partial view drawing using setNeedsDisplay InRect:.128 Part II: Getting the Most Out of Everyday Tools  Optimizing UIView Drawing UIView and its subclasses are highly optimized.
you  . 2. so you can also demonstrate it with the program BlurryText available with the online files for this chapter. First. as discussed in “Understanding Coordinates” earlier in this chapter.  Pixel Alignment and Blurry Text One of the most common causes of subtle drawing problems is pixel misalignment. As of iOS 4. This illusion makes things smoother. especially with UILabel. You may need to manage 1-scale and 2-scale versions of your images and possibly different images for iPad and iPhone. This is usually the case for small elements like buttons. Since the iPhone 3GS. If you ask Core Graphics to draw at a point that is not aligned with a pixel. If you make a habit of using odd font sizes. Today. To be certain to avoid the problem. so half-points (1. as you want to make minor tweaks. however. you want to make sure that your drawing is pixel aligned to avoid this. but that also makes them fuzzy. Even so. For instance. not pixels. you can often avoid the problem. giving the illusion that the line is between the two.  Figure 6-13 Text that is pixel aligned (top) and unaligned (bottom)  There are two solutions. I suggest that you keep the art files fairly “flat” and composit in code. unless you need pixel accuracy. your origin may be misaligned. That way. First.Chapter 6: Better Drawing 129 There are a lot of disadvantages to prerendering. This causes an unfortunate problem for the center property. Apple originally encouraged developers to prerender because early iPhones couldn’t compute gradients fast enough. If you set the center to an integral coordinate. and each generation makes custom drawing more attractive. Anti-aliasing also takes processing time. coordinates are in points. This is particularly noticeable with text. you don’t have to rerender the background. It is subtle. Many artists are still unfamiliar with how to draw stretchable images and how to best provide images to be composited for iOS. When you do use prerendered artwork. There are two pixels to the point on the current Retina display. there might be four or more pixels to the point. This complicates workflow and bloats your product. and it could be different from device to device. it is easiest to just make sure you use integer coordinates for your frames. Prior to the Retina display. When possible. I recommend custom drawing when you can do it in a reasonable amount of code. it introduces resolution dependence. This means it draws part of the information on one pixel and part on another. and may be difficult to see in print.5. Generally it is the frame origin that matters for pixel alignment. so it slows down drawing. you may use an image for a button’s background. it performs anti-aliasing. but handle the rounding and shadows in code. odd font sizes (13 rather than 12 for instance) will typically align correctly. It can make minor changes difficult and lock you into precise element sizes and colors if every change requires a round trip to the artist. In the future. this has been less of an issue.5) are also pixel aligned. pixel aligned meant integer coordinates. Figure 6-13 demonstrates this problem.
you’re promising the drawing system that you will draw every pixel in your rectangle with fully opaque colors. As pre-Retina displays phase out. When you mark a view as opaque. That allows the drawing system to ignore views below yours and that can improve performance. However.center = center. if there are any partially transparent pixels in your view. the user isn’t going to see the circuit board or the ground. It’s a pretty fast operation. setting opaque can have unpredictable results. or by using a UIView category like setAlignedCenter:: . So as you raise and lower the alpha. and backgroundColor to nil or [UIColor clearColor]. it is still a concern. In the end. Remember. but it is very easy and fast enough for most problems. hidden indicates that the view should not be drawn at all and is generally equivalent to an alpha of 0.  Alpha. you’re changing how much this view contributes to the pixel versus views “below” it. An alpha of 0 means that none of the view’s information is used to color the pixel. but are actually orthogonal: alpha. self. you can get a small benefit by setting it to NO. Marking a view opaque or not does not actually make its content more or less transparent. especially views that scroll like UITableViewCell. For now. You should mark your views opaque whenever possible.(void)setAlignedCenter:(CGPoint)center { self. though.1. or if you don’t draw every pixel in your rectangle. Hidden and transparent views do not receive touch events. and hidden. and sets the context to transparent black before calling drawRect:. particularly when applying transforms. Opaque is a promise that the drawing system can use for optimization. this will be less of an issue as long as you set center to integer coordinates. You can make a view transparent and still receive touch events by setting its alpha to 1. You should not rely on this particular value. This is YES by default. The hidden property cannot be animated. CGRectIntegral() returns the smallest integral rectangle that encloses the given rectangle. } Because this effectively sets the frame twice. opaque to NO.frame). Finally. The meaning of transparent is not well defined in the documentation. A view with a transparent background is still considered visible for the purposes of hit detection. but the point is that “nearly transparent” is generally treated as transparent. The alpha property determines how much information a view contributes to the pixels within its frame. Opaque.  . So an alpha of 1 means that all of the view’s information is used to color the pixel. Closely related to opaque is clearsContextBeforeDrawing. it’s just a matter of what color to draw the pixel. but if you’re going to draw every pixel anyway. You cannot create a “transparent overlay” to catch touch events by setting the alpha very low. Setting a nontransparent backgroundColor ensures that all pixels are drawn. Hidden Views have three properties that appear related. This avoids any garbage data in the view. If you set the entire screen to transparent pixels. it is not the fastest solution. so it’s common to hide views by animating alpha to 0.130 Part II: Getting the Most Out of Everyday Tools need to make sure that the frame is integral either by using setFrame: instead of setCenter:. opaque. but through experimentation I’ve found that it is an alpha less than 0.frame = CGRectIntegral(self. nothing is really transparent on an iPhone screen.
CGContextSetRGBFillColor (textCtx. Each of these has different attributes. save it off.  . however. designed to draw to the screen. textBounds.  LayerView. 200.Chapter 6: Better Drawing 131  CGLayer CGLayer is a very effective way to cache things you draw often. CGContextRef textCtx = CGLayerGetContext(sTextLayer).0.0.size. a CGLayer is similar to a CGBitmapContext. often hardware optimized. If a CGLayer is destined for a view graphics context. for drawing into CGContext. [@”Pushing The Limits” drawInRect:textBounds withFont:font]. This could be done with CGContextShowTextAtPoint instead. You use UIGraphicsPushContext so that you can use UIKit to draw the text into the layer context. Figure 6-14 shows the ouput. You can then “stamp” the CGLayer repeatedly while rotating the context. 1). UIGraphicsPushContext(textCtx).bounds. NULL). } CGContextTranslateCTM(ctx. In this case it’s cached in a static variable the first time the view is drawn. and available hardware acceleration. There are several kinds of CGContext. CGContextRef ctx = UIGraphicsGetCurrentContext(). 0.0. and use it to draw the result into a CGContext later.(void)drawRect:(CGRect)rect { static CGLayerRef sTextLayer = NULL. The difference is that you can optimize CGLayer for use with a particular kind of graphics context. This should not be confused with CALayer. UIGraphicsPopContext(). if (sTextLayer == NULL) { CGRect textBounds = CGRectMake(0. The most common is a view graphics context. 1. self. 0. The following example demonstrates caching a CGLayer. and UIGraphicsPopContext to return to the normal context.width / 2. color details. Contexts are also used for bitmaps and printing. which is a more powerful and complicated layer object from Core Animation. which is returned by UIGraphicsCurrentContext. 0.m (Layer) @implementation LayerView . including maximum resolution. At its simplest.size. 100). UIFont *font = [UIFont systemFontOfSize:13. CGBitmapContext can’t do this because it doesn’t know that you plan to draw it on the screen. it can cache its data directly on the GPU. sTextLayer = CGLayerCreateWithContext(ctx. You can draw into it.0]. which can significantly improve performance. CGLayer is a Core Graphics layer that is optimized. but UIKit makes it very easy to draw an NSString.
sTextLayer). ++i) { CGContextRotateCTM(ctx.132 Part II: Getting the Most Out of Everyday Tools self. } } @end  Figure 6-14 Output of LayerView  . CGContextDrawLayerAtPoint(ctx. 2 * M_PI / 10).height / 2). i < 10. CGPointZero. for (NSUInteger i = 0.size.bounds.
iphonedevelopment.  Further Reading Apple Documentation The following documents are available in the iOS Developer Library at developer. which puts your interface in motion. UIKit. Also covered is CALayer. but you can get a good introduction in Apple’s “OpenGL ES Programming Guide for iOS” (see the “Further Reading” section).apple. This chapter focused on Core Graphics and its Objective-C descendant. and an important tool for your drawing toolbox even if you’re not animating. so it isn’t tackled here.  .com/search/label/CGAffineTransform. iOS also has ever-growing support for OpenGL ES for drawing advanced 3D graphics and textures. a powerful addition to UIView and CGLayer. iPhone Development. OpenGL ES is a booklength subject of its own. By now you should have a good understanding of how systems interact and how to optimize your iOS drawing. Drawing and Printing Guide for iOS iOS Human Interface Guidelines iOS Application Programming Guide OpenGL ES Programming Guide for iOS Quartz 2D Programming Guide Technical Q&A QA1708: Improving Image Drawing Performance on iOS View Programming Guide for iOS  Other Resources LaMarche. Jeff has several articles that provide a lot of insight into using CGAffineTransform.Chapter 6: Better Drawing 133  Summary iOS has a rich collection of drawing tools. iOS 5 brings Core Image to iOS for tweaking pictures. Jeff.blogspot.com or through the Xcode Documentation and API Reference. That is discussed briefly in Chapter 1. Chapter 7 discusses Core Animation.
134 Part II: Getting the Most Out of Everyday Tools  .
For more information on OpenGL ES. In this chapter you discover the two main animation systems of iOS: view animations and the Core Animation framework. but a better way to let the user know what’s happening and what to expect. CircleView just draws a circle in its frame. To facilitate all this animation. It’s likely that you are familiar with basic view animations. Finally. including animating your own properties. bounds. For more information on Cocos2D. You can use UIView to animate frame.org. center. The following code creates the animation shown in Figure 7-1. Most common animations can be handled with +animateWithDuration:animations: and related methods. center. applications zoom into place. Views slide in and out. Core Animation is all about performance. When you create a bookmark and it flies to the toolbar. iOS devices include a powerful GPU and frameworks that let you harness that GPU easily. You learn how to draw with Core Animation layers and how to move layers around in two and three dimensions. transform. This chapter focuses on animations for view-based programming. so I’ll just touch on the high points in this section and then move on to more advanced layer-based drawing and animation. see cocos2d-iphone. You learn how to create custom automatic animations. Let’s start with a very simple animation of a ball that falls when you tap the view. so you learn how to manage layers in multithreaded applications.com. Common decorations like rounded corners. Game development is outside the scope of this book. it is natural to press the left-pointing button to go back to where you were. and shadows are trivial with CALayer. When views slide into place from right to left. alpha.  . see the OpenGL ES for iOS portal at developer. Apple has made animation not just a beautiful part of the experience.apple. These subtle cues are a critical part of making your user interface intuitive as well as engaging. transform. Most of the time you’ll animate frame. These frameworks are ideal for most iOS applications except games. backgroundColor. and alpha. pages fly into the bookmark list. and contentStretch.Chapter 7  Layers Like an Onion: Core Animation  The iPhone has made animation central to the mobile experience. and you learn to apply them quickly and easily. colored borders. it’s more obvious where you should look to get back to that bookmark. and is usually best served by built-in frameworks like OpenGL ES or third-party frameworks like Cocos2D.  View Animations UIView provides rich animation functionality that is very easy to use and well optimized.
(void)viewDidLoad { [super viewDidLoad].circleView = [[CircleView alloc] initWithFrame: CGRectMake(0. 20. g = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(dropAnimate)].h” @implementation ViewAnimationViewController @synthesize circleView = circleView_. [[self view] addGestureRecognizer:g]. 20).circleView]. 0.m (ViewAnimation) #import “ViewAnimationViewController. self.circleView.136 Part II: Getting the Most Out of Everyday Tools  Figure 7-1 CircleView animation  ViewAnimationViewController.  .h” #import “CircleView. [[self view] addSubview:self. 20)].center = CGPointMake(100. self. UITapGestureRecognizer *g. .
center = CGPointMake(250. by default it automatically stops responding to user interaction. and it can handle most common problems. or translate the view over time. You look at how to handle that next. } completion:^(BOOL finished){ [UIView animateWithDuration:1 animations:^{ self. . } ]. the ball will jump to the lower left and then animate to the right. tapping it won’t generate any events. Less commonly.circleView. this code runs. you need to consider this issue. }]. If an animation is in progress. you can animate backgroundColor and contentStretch. When you animate a view. It’s also common to animate transform to scale. as shown in the following code.(void)dropAnimate { [UIView animateWithDuration:3 animations:^{ self. } Now the ball will drop and the move to the right.(void)viewDidUnload { [super viewDidUnload]. In this example. Anytime you create an animation in response to user input.Chapter 7: Layers Like an Onion: Core Animation 137 } . Sometimes that’s what you want. There are two solutions.center = CGPointMake(100. That’s probably not what you want. and opacity. tapping the main view causes the animation. 300).circleView. then it’s canceled and the completion block runs with finished==NO. If you tap the screen while the animation is in progress. Chaining animations is also straightforward. The issue is that every time you tap the view.circleView = nil. But there’s a subtle problem with this code. location. particularly animating size.center = CGPointMake(100. 300). First.circleView. self. So while the ball is dropping. } . Animating the background color is particularly useful in HUD-style interfaces to move between mostly transparent and mostly opaque backgrounds.  Managing User Interaction The problem mentioned in the previous section is caused by a user experience mistake: allowing the user to send new commands while you’re animating the last command.(void)dropAnimate { [UIView animateWithDuration:3 animations:^{ self. 300). but in this case it isn’t. you can change your user interface so that tapping the ball causes the animation:  . This can be more effective than just animating the overall alpha. rotate. however. }]. } @end This is the simplest kind of view-based animation.
and then enable it when the animation completes.circleView.userInteractionEnabled.  Don’t confuse CALayer from Core Animation with CGLayer from Core Graphics. so it can’t create anything like Cover Flow. except for basic z-ordering. so you need to be careful about how many of them you use.enabled with self.  Drawing with Layers View animations are powerful. these are great tools.center = CGPointMake(250. Both are layers.circleView addGestureRecognizer:g].apple. and view animations have a lot of limitations.center = CGPointMake(100. . you need to learn to use Core Animation. This section explains how to draw with CALayer without animations. Core Animation provides a variety of tools. } ]. 300). In that case you would replace recognizer.com. }]. 300). See Chapter 6 for more information on CGLayer. But you’re here to go beyond the basic needs. If you have basic needs.138 Part II: Getting the Most Out of Everyday Tools [self. Their basic unit of animation is UIView. but they have dramatically different purposes. In this chapter.(void)dropAnimate:(UIGestureRecognizer *)recognizer { [UIView animateWithDuration:3 animations:^{ recognizer. especially for basic layout animation. This technique is nice because it minimizes side effects to the rest of the view. The most basic and important part of Core Animation is CALayer. and you should rely on them whenever you can. which is a pretty heavyweight object. The other solution is to ignore taps while the ball is animating. } completion:^(BOOL finished){ [UIView animateWithDuration:1 animations:^{ self. when I refer to a layer. self. but you might want to prevent all user interaction for the view while the animation runs. The following code shows how to disable the UIGestureRecognizer in the gesture recognizer callback . several of which are useful even if you don’t intend to animate anything.enabled = YES.circleView. } completion:^(BOOL finished){ recognizer. UIView also doesn’t support three-dimensional layout. You explore animating later in the chapter.  . To move your UI to the next level.view. They also provide a small number of stock transitions that you can read about in the Animations section of the View Programming Guide for iOS available at developer.enabled = NO. I mean CALayer.
transform.. If the layer has been marked dirty by a call to setNeedsDisplay. layer. then the drawing system will continue with the following steps. You can override a draw method to draw custom content.  UIView UIView  CALayer CALayer  CALayer UIView  Figure 7-2 View and layer hierarchies  Layers draw whatever is in its contents property. Unless setNeedsDisplay is called. just like every UIView can have subviews. CALayer *layer = .Chapter 7: Layers Like an Onion: Core Animation 139 In many ways.. requesting that contents be updated using the following steps. It’s your job to set this somehow. You might ask. and discussed more fully in “Setting Contents Directly” later in this section. [CALayer displayIfNeeded]—The drawing system automatically calls this as needed. usually with Core Graphics. It has a location.. 1. UIView relies on a CALayer to manage its drawing. CALayer is all about drawing. UIImage *image = . particularly touch events. Figure 7-2 shows the hierarchy. You shouldn’t call it directly.contents = (__bridge id)[image CGImage].. then Core Animation will go through the following methods to create it. even if it’s nil. which allows the two to work very well together. The default implementation calls the delegate method displayLayer: if the delegate  . and there are various ways of doing that. CALayer is very much like UIView. 2. In fact.. which is a CGImage (see the note at the end of this section). 3. And every CALayer can have sublayers. as shown here. Every UIView has a CALayer to do its drawing. why even have separate objects? The most important answer is that UIView is a fairly heavyweight object that manages drawing and event handling. There is a layer hierarchy exactly like the view hierarchy. [CALayer display]—This is called by displayIfNeeded when appropriate. The simplest approach is to assign it directly. [CALayer setNeedsDisplay]—Your code needs to call this.. size. If you do not set the contents property directly. and content. the contents property is never updated. It marks the layer as dirty.
4. If this method is implemented. for contents. 5. To draw with UIKit. CABackingStorage. Note that you may call this directly.view. but this is not always the case. The default behavior of a CALayer is to never draw unless you explicitly ask for it.  LayersViewController. you can implement display or displayLayer:. creates a CGImage (see note below) and assigns it to contents. The thing to remember is that the default behavior of a UIView is to draw when it thinks you need it. there are several ways to set the contents of a layer. In the rest of this section I discuss each approach. Otherwise. just use the passed context to draw with Core Graphics. The drawing system almost never automatically updates contents in the way that UIView is often automatically refreshed.  Setting Contents Directly Providing a content image (shown in the following code) is the easiest solution if you already have an image handy. You can override display in a subclass to set contents directly. See the section “Drawing in Your Own Context” later in this section for information on why you would call this directly. [delegate displayLayer:]—The default [CALayer display] calls this if the delegate implements it. and it is optimized to not waste time doing anything that wasn’t explicitly asked for. If not. Its job is to set contents. the default drawInContext: calls this to update the context so that display can create a CGImage. The default display method takes the resulting context.m (Layers) #import <QuartzCore/QuartzCore.h> . For instance.. you need to call UIGraphicsPushContext() to make the passed context the current context. then no further custom drawing code will be run.contents = (__bridge id)[image CGImage]. [delegate drawLayer:inContext:]—If implemented. You can set it directly with setContent:. If you use custom drawing. [CALayer drawInContext:]—The default display method creates a view graphics context and passes it to drawInContext:.  . display calls drawInContext:. but no UIKit context is set up for you automatically. then Core Animation will use a private class.  The contents property is usually a CGImage.png”]. or you can implement drawInContext: or drawLayer:inContext:. UIView draws itself the first time it’s put on screen. As you can see. Otherwise it does nothing. This is similar to [UIView drawRect:]. Marking a CALayer as dirty with setNeedsDisplay does not impact sublayers. The default [CALayer drawInContext:] calls [delegate drawLayer:inContext:] if it’s implemented. even if it does nothing. CALayer is a much lower-level object. self. UIImage *image = [UIImage imageNamed:@”pushing. Marking a UIView as dirty with setNeedsDisplay automatically redraws all the subviews as well.layer. 6. CALayer does not.140 Part II: Getting the Most Out of Everyday Tools implements it. You can set contents to either a CGImage or the contents of another layer..
you can also draw with UIKit. a cast is required. The default implementation creates an CGContext. but actually expects a CGImageRef. passes it to drawInContext:. (This may be resolved in a later version of iOS. In my experience it’s dangerous to make a UIView the delegate for any of the sublayers. You can do this any way you’d like. and you have an image for each. you can provide completely custom drawing with CALayer.  Implementing Display The job of display or displayLayer: is to set contents to a correct CGImage. UIImageView is highly optimized for displaying images. but using UIGraphicsPushContext.) A common error is to pass a UIImage here instead of a CGImageRef. it’s usually a better idea to use a UIImageView or a UIButton rather than a custom UIView with hand-loaded layer content. To make this work with ARC. You can create those images by loading them from your bundle.  See Chapter 6 for information on how to draw with Core Graphics and UIKit. or any other way you’d like.  Custom Drawing As with UIView.framework to use Core Animation. UIView has a layer and it must be that layer’s delegate. and includes a lot of good user interface mechanics that are a pain to reproduce. You won’t get a compiler error or runtime warning. By default. If your view content is basically several images. Just don’t let your UIViewController get overcomplicated. What can make more sense is to make your UIViewController the delegate for the layers. or you can have some other object be the delegate for sublayers. This is an easy thing to forget. Typically you’ll draw with Core Graphics. So you can implement displayLayer: in UIView to manage its layer. This avoids extra objects and subclasses if your needs are pretty simple. particularly if you aren’t subclassing UIView. As with contentMode and contentStretch in UIView.Chapter 7: Layers Like an Onion: Core Animation 141 You must always import QuartzCore. CALayer can be configured to scale its image in different ways using contentsCenter and contentsGravity. turns the result into a CGImage. Your view will just be blank.  . The cast to __bridge id is needed because contents is defined as an id. Having UIView implement displayLayer: seldom makes sense in my opinion. the contents are scaled to fill the view. Whether to subclass CALayer or use a delegate is really a matter of taste and convenience. Buttons often work this way. The most common reason to override this is if your layer has several states. UIButton is very good at switching images based on state. even if that distorts the image. This can create infinite recursion when the UIView tries to copy its sublayers in certain operations such as transitions.h and link with QuartzCore. drawing them with Core Graphics. UIKit likely does it better than you will. Don’t try to reinvent UIKit in Core Animation. and assigns it to contents.
} @end Note the call to setNeedsDisplay in initWithFrame:. } return self.(id)initWithFrame:(CGRect)frame { self = [super initWithFrame:frame]. You may also notice the hand-drawing of the background rather than using the backgroundColor property. [[UIColor blackColor] set]. UIRectFill(layer. This is intentional.142 Part II: Getting the Most Out of Everyday Tools Using drawInContext: is just another way of setting contents. UIGraphicsPopContext(). You just need to generate a context and pass it in.m (Layers) @implementation DelegateView . Once you engage in custom drawing with drawLayer:inContext:. } . if (self) { [self. The advantage of this over setting contents directly is that display automatically creates a CGContext appropriate for the layer. You need to mark them as dirty with setNeedsDisplay. [[UIColor whiteColor] set]. most automatic layer settings like backgroundColor and cornerRadius are ignored. In particular.  Drawing in Your Own Context Unlike [UIView drawRect:]. There isn’t helpful compositing going on for you like in UIView.bounds). It’s called by display.layer setNeedsDisplay]. This is nice for capturing the contents of a layer onto a bitmap or  . you need to call UIGraphicsPushContext before calling UIKit methods. Because Core Animation does not set a UIKit graphics context. then put the custom drawing onto a sublayer.  DelegateView.(void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx { UIGraphicsPushContext(ctx). UIFont *font = [UIFont systemFontOfSize:48. which is called only when the layer is explicitly marked dirty with setNeedsDisplay. and round the corners on the superlayer.) The following code shows how to implement the delegate method drawLayer:inContext: to draw the string “Pushing The Limits” at the top of the layer using UIKit. Your job in drawLayer:inContext: is to draw everything needed for the layer. As discussed earlier. and UIGraphicsPopContext before returning. If you want layer effects like rounded corners together with custom drawing. [@”Pushing The Limits” drawInRect:[layer bounds] withFont:font lineBreakMode:UILineBreakModeWordWrap alignment:UITextAlignmentCenter]. layers do not automatically draw themselves when put on screen.0]. (See Chapter 6 for a discussion of Core Graphics and flipped coordinate systems. it is completely legal to call [CALayer drawInContext:] yourself. the coordinate system is flipped for you.
subviews. CALayer *layer = [layers objectAtIndex:0].frame = CGRectMake(100. you need to do a small amount of work to prevent them from animating. CALayer *squareLayer = [CALayer layer]. } This draws a small red sublayer and a small blue subview.view.  . 100. [self.Chapter 7: Layers Like an Onion: Core Animation 143 PDF so you can save it or print it. Consider this example:  LayerAnimationViewController. This is mostly useful if you want to composite this layer with something else because if all you want is a bitmap.layer addSublayer:squareLayer]. [view setCenter:CGPointMake(100. } .view. [layer setPosition:CGPointMake(200. 20). squareLayer.view addGestureRecognizer: [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(drop:)]].backgroundColor = [UIColor blueColor].view addSubview:squareView]. both are moved. you could just use contents.layer. The layer animates over a quarter second. 250)]. When the view is tapped. but it’s not instantaneous like the view. [self. not any of its sublayers.backgroundColor = [[UIColor redColor] CGColor]. 20. [self. 100.  Moving Things Around Now that you can draw in a layer. drawInContext: only draws the current layer. 20. UIView *view = [views objectAtIndex:0]. squareLayer.view. let’s look into how to use those layers to create powerful animations. That also captures the current state of the layer if it’s animating.sublayers. 250)]. You can prevent this by disabling actions: [CATransaction setDisableActions:YES]. Layers naturally animate. It’s fast. NSArray *views = self. The view jumps immediately to the new location. If you want to draw the layer and its sublayers. It use the current state of the render tree that Core Animation maintains internally. so it doesn’t call drawInContext:.(void)drop:(UIGestureRecognizer *)recognizer { NSArray *layers = self. 20). use renderInContext:. CALayer implicitly animates all properties that support animation. squareView. UIView *squareView = [UIView new].m (LayerAnimation) . In fact.(void)viewDidLoad { [super viewDidLoad].frame = CGRectMake(200. squareView.
Core Animation bundles property changes into atomic transactions (CATransaction). see the “Core Animation and Threads” section later in this chapter. and when the run loop completes. make sure to call setDisableActions: when you mean to change it. you may want to change the duration of the animation. Apple may remedy this eventually. In the meantime. so you want to know about both animations when working out the intermediate values. The following changes the duration of the current transaction to 5 seconds rather than the default quarter-second. For instance. you need to make changes to the current transaction. You can also set a completion block to run after the current transaction finishes animating using [CATransaction setCompletionBlock:]. or to disable animations for only a part of the event loop. all the changes are committed to the layer tree. (If that last sentence piqued your interest.  See the “Auto-animate with Actions” section of this chapter for more information on how implicit animations are implemented and how you can extend them. To modify the animation properties. Most of the time when you change several layer properties. you would expect it to have a side effect (disabling actions) rather than returning the current value of the property. An implicit CATransaction is created for you the first time you modify a layer on a thread that includes a run loop. But what if you don’t like the defaults? For instance. You can use this to chain animations together. as it has with other misnamed properties. First.144 Part II: Getting the Most Out of Everyday Tools I discuss actions further in the “Auto-animate with Actions” section later in this chapter.) During the run loop. you need to understand transactions.  Implicit Animations You now know all the basics of animation. Just set layer properties and your layers animate in the default way.0]. [CATransaction setAnimationDuration:2. These allow you to assign different durations to different parts of the animation. opacity and backgroundColor are interrelated properties. you can also create your own explicit transactions using [CATransaction begin] and [CATransaction commit]. It should be actionsDisabled (or actionsEnabled to be parallel with userInteractionEnabled). Because it begins with a verb. You also don’t want to waste the renderer’s time calculating animations for one property change if the next property change affects it. You won’t get a warning or error if you call [CATransaction disableActions] in a void context.  disableActions is a very poorly named property.  . among other things. you want them all to animate together. While the run loop creates a transaction for you automatically. Both affect the final displayed pixel color. all layer changes are collected.
along with individual timing for each segment.autoreverses = YES.duration = 1. a timingFunction. This pulses the layer forever.repeatCount = INFINITY.toValue = [NSNumber numberWithDouble:0. If you have custom properties in your layer. anim. Implicit animations are implemented using CAAnimation. fade = [CABasicAnimation animationWithKeyPath:@”opacity”]. ” The mistake looks like this: CABasicAnimation *fade. fade. and employ layer transitions. An animation has a key. you can move to CAKeyframeAnimation. I discuss this later in the “Animating Custom Properties” section of this chapter. The major difference is that instead of giving a fromValue and toValue. you now can give a path or a sequence of points to animate through. The Animation Types and Timing Programming Guide on developer. anim.0]. anim.apple. They’re not technically difficult to set up.toValue = [NSNumber numberWithDouble:0.Chapter 7: Layers Like an Onion: Core Animation 145  Explicit Animations Implicit animations are powerful and convenient. you may notice that they’re not set correctly during animation. The way it works is to make several copies of the layer. fade. fade. as shown in the following code.0]. and some other configuration options. send setValue:forKey: messages to the copies and then display. When you want to stop the animation. You must override initWithLayer: to copy your custom properties if you want them to be available during an animation. but they’re not very flexible. anim. a duration. animating the opacity from one to zero and back over 2 seconds.0].  Model and Presentation A common problem in animations is the dreaded “jump back. CABasicAnimation *anim = [CABasicAnimation animationWithKeyPath:@”opacity”].duration = 2. With CAAnimation. anim. The most basic animation is a CABasicAnimation.0. so everything you can do with an implicit animation can be done explicitly as well. [layer addAnimation:anim forKey:@”anim”]. Most of the work is on the creative side to find just the right path and timing. If you want more control over the animation.  .0]. but sometimes you want more control.fromValue = [NSNumber numberWithDouble:1. [circleLayer addAnimation:fade forKey:@”fade”]. This is because the layer is copied. a fromValue. remove it: [layer removeAnimationForKey:@”anim”].fromValue = [NSNumber numberWithDouble:1. That’s where CAAnimation comes in.com provides excellent examples. as the name implies. you can manage repeating animations. It captures the generated contents and displays them. CABasicAnimations are basic. a toValue. They’re easy to set up and use. It interpolates a property over a range using a timing function. precisely control timing and pacing.
but it’s internal to Core Animation and you very seldom encounter it. so you snap back to where you started. fade = [CABasicAnimation animationWithKeyPath:@”opacity”]. On top of all of that. All of this becomes a bit of a pain.  Sometimes you see people recommend setting removedOnCompletion to NO and fillMode to kCAFillModeBoth.opacity = 0. fade = [CABasicAnimation animationWithKeyPath:@”opacity”].  . not what you see on the screen. To understand why this happens. They represent roughly what is shown on the screen. The best solution to that is to turn off implicit animations if you’re doing explicit animations: [CATransaction begin]. The model layer is defined by the properties of the “real” CALayer object. as shown here: circleLayer. [CATransaction commit]. and then suddenly the circle reappears. you need to be aware of the difference between the model layer and the presentation layer. These become the presentation layer.. This is not a good solution..opacity = 0. The model layer hasn’t changed. all its changes are thrown away and the model layer is used to determine the new state. you continue to see the model value. [circleLayer addAnimation:fade forKey:@”fade”]. Instead. it wastes memory..146 Part II: Getting the Most Out of Everyday Tools This fades the circle out over 1 second. There is technically another layer called the render layer that really represents what’s on the screen. It essentially makes the animation go on forever.. but sometimes the implicit animation in setOpacity: fights with the explicit animation from animationWithKeyPath:. Nothing in the preceding code modifies any property of circleLayer itself. CABasicAnimation *fade. If you ever remove the animation by replacing it with another with the same name. . and when it completes. but this can make explicit animation a bit simpler. which is drawn to the screen. circleLayer. which means the model layer is never updated. The solution to this is to set the model layer. If you ask for the property’s value. So what happens in the preceding code? CAAnimation modifies the presentation layer. just as expected. . Sometimes this works fine. If you try to implicitly animate the property afterward. [CATransaction setDisableActions:YES]. CAAnimation makes copies of circleLayer and modifies those. so you may like the following category on CALayer that wraps it all together and lets you set the duration and delay. it won’t work correctly because the CAAnimation is still running. CABasicAnimation *fade. the old value snaps back. calling removeAnimationForKey: or removeAllAnimations. [circleLayer addAnimation:fade forKey:@”fade”]. Most of the time I still prefer implicit animation.
time can be scaled. but it comes up when you’re trying to coordinate animations. just like you need to convert points that occur in different views or layers. but that isn’t how it works.beginTime = CACurrentMediaTime() + delay. however.toValue = value. in Core Animation.m (LayerAnimation) @implementation CALayer (RNAnimations) . [CATransaction commit].Chapter 7: Layers Like an Onion: Core Animation 147 CALayer+RNAnimation.  . It’s the current model value because the animation hasn’t begun. Setting beginTime like this is a nice way to chain animations. anim. CAAnimation conforms to the CAMediaTiming protocol. To reference “now. localTime = [self convertTime:remotetime fromLayer:otherLayer].(void)setValue:(id)value forKeyPath:(NSString *)keyPath duration:(CFTimeInterval)duration delay:(CFTimeInterval)delay { [CATransaction begin]. anim. [CATransaction setDisableActions:YES]. Typically this is the toValue. You might ask another layer for a particular animation and when that animation will end so that you can start your animation. Because of this.duration = duration. localPoint = [self convertPoint:remotePoint fromLayer:otherLayer].beginTime + otherAnim. A second does not always have to be a second. anim = [CABasicAnimation animationWithKeyPath:keyPath].duration. when considering timings between layers. myAnim. This isn’t very common. anim. even if you hard-code the time rather than ask the other layer.fillMode = kCAFillModeBoth. time is relative. } @end  A Few Words on Timings As in the universe at large.beginTime = [self convertTime:finish fromLayer:layer]. you need to convert them.” just use CACurrentMediaTime(). What value should your property have between now and when the animation begins? You would assume that it would be the fromValue. anim. Just like coordinates. [self addAnimation:anim forKey:keyPath]. CFTimeInterval finish = otherAnim.fromValue = [[self presentationLayer] valueForKey:keyPath]. This raises another issue. CABasicAnimation *anim. [self setValue:value forKeyPath:keyPath]. and you can set the speed property to scale its timing. anim. CAAnimation *otherAnim = [layer animationForKey:@”anim”].
fades to 0.fromValue = [NSNumber numberWithDouble:1. anim.0].opacity = 0.0. This almost certainly isn’t what you want.beginTime = CACurrentMediaTime() + 3. however.5]. anim. anim. rotate. You rotate layers around an anchor point. But it does allow you to give the illusion of three-dimensional movement. During that time. With layers. designated {0. you want to set this to kCAFillModeBackwards or kCAFillModeBoth.5.0. you can apply three-dimensional transformations by adding perspective. [CATransaction commit].5. then 3 seconds. anim. and skew.0}. no matter how large or small the layer is. the default property animation is used to fade opacity from 1. In most cases. So the layer begins with opacity of 1. anim = [CABasicAnimation animationWithKeyPath:@”opacity”]. This technique limits you to two-dimensional transformations: translate. the anchor point is in the center of the layer.148 Part II: Getting the Most Out of Everyday Tools [CATransaction begin]. This can be changed to “clamp” values before or after the animation by setting the fill mode to kCAFillModeBackwards.duration = 5. 0. You can resolve this using fillMode.0 and fades again to 0.5 over a quarter-second. This animation does nothing for 3 seconds. kCAFillModeForwards.0 to 0.0.5 over 5 seconds. or kCAFillModeBoth. By default. It can be moved anywhere within the layer. layer. So the lower-right corner is {1. and later jumps back to 1. This is often called 2.5. which means that the animation has no influence on the values before or after its execution. [layer addAnimation:anim forKey:@”fade”].0. [CATransaction setDisableActions:YES].  .5}. The anchor point is described in terms of a unit square rather than in points. scale. Figure 7-3 illustrates this. setting the opacity to its fromValue and interpolating to its toValue. Then the animation begins. The default is kCAFillModeRemoved.  Into the Third Dimension Chapter 6 discussed how to use CAAffineTransform to make UIView drawing much more efficient. making it convenient to rotate around an edge or corner.5D rather than 3D because it doesn’t make layers into truly three-dimensional objects in the way that OpenGL ES does. 1.toValue = [NSNumber numberWithDouble:0.
5 time model  3 clamped value animation  8  kCAFillMode forwards opacity 1 0.5 time model  3 model animation  8  kCAFillMode Backwards opacity 1 0.5 time clamped value  3 model animation  8  Figure 7-3 Effect of fill modes on media timing functions  .Chapter 7: Layers Like an Onion: Core Animation 149 kCAFillMode Removed opacity 1 0.
readwrite. const CGFloat kPanScale = 1. readwrite. @synthesize leftLayer=leftLayer_. 0). strong) CALayer @property (nonatomic.150 Part II: Getting the Most Out of Everyday Tools Here’s a simple example of a three-dimensional box.(CALayer *)layerWithColor:(UIColor *)color transform:(CATransform3D) transform { CALayer *layer = [CALayer layer]. return perspective. *rightLayer.bounds = CGRectMake(0. layer. transform = CATransform3DMakeTranslation(0. } .m34 = -1.transform = transform. *frontLayer. M_PI_2. 0).topLayer = [self layerWithColor:[UIColor redColor] transform:transform]. readwrite. layer. . @synthesize frontLayer=frontLayer_. [super viewDidLoad].  BoxViewController.view./100. kSize. @synthesize backLayer=backLayer_. 1. readwrite. return layer.. layer. strong) CALayer @property (nonatomic. const CGFloat kSize = 100. transform = CATransform3DRotate(transform. readwrite.layer addSublayer:layer].  .center. perspective. } static CATransform3D MakePerspetiveTransform() { CATransform3D perspective = CATransform3DIdentity. -kSize/2.view. strong) CALayer @property (nonatomic.m (Box) @implementation BoxViewController @synthesize topLayer=topLayer_.position = self.(void)viewDidLoad { CATransform3D transform..h (Box) @interface BoxViewController : UIViewController @property (nonatomic. strong) CALayer @property (nonatomic.0.backgroundColor = [color CGColor]. strong) CALayer @end *topLayer. *bottomLayer. 0. [self./2000. kSize). 0. layer.  BoxViewController. @synthesize rightLayer=rightLayer_. *backLayer. *leftLayer. strong) CALayer @property (nonatomic.. @synthesize bottomLayer=bottomLayer_. readwrite. self.
[self. 0. UIGestureRecognizer *g = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(pan:)].  . transform = CATransform3DRotate(transform. 1. -kSize/2). self. M_PI_2. self.sublayerTransform = MakePerspetiveTransform(). 0. 0). transform = CATransform3DRotate(transform. M_PI_2. transform = CATransform3DRotate(transform. CATransform3D transform = MakePerspetiveTransform(). transform = CATransform3DRotate(transform.view]. } . self. All the layers are created with layerWithColor:transform:. 0). 1. 1. transform = CATransform3DMakeTranslation(0.layer. 0.leftLayer = [self layerWithColor:[UIColor cyanColor] transform:transform]. transform = CATransform3DMakeTranslation(kSize/2. self. self. M_PI_2. 0. transform = CATransform3DRotate(transform. 1.bottomLayer = [self layerWithColor:[UIColor greenColor] transform:transform].view.layer.view. kSize/2).0.frontLayer = [self layerWithColor:[UIColor magentaColor] transform:transform]. 0).view addGestureRecognizer:g]. 0). 0. } @end This shows how to build a simple box and rotate it based on panning. 0). kSize/2. transform = CATransform3DRotate(transform. Notice that all the layers have the same position. transform = CATransform3DMakeTranslation(0.sublayerTransform = transform. 0. 0). 0). transform = CATransform3DRotate(transform. 0.(void)pan:(UIPanGestureRecognizer *)recognizer { CGPoint translation = [recognizer translationInView:self. 0. 0. 0. 0. 0).Chapter 7: Layers Like an Onion: Core Animation 151 transform = CATransform3DMakeTranslation(0. self.rightLayer = [self layerWithColor:[UIColor blueColor] transform:transform]. They only appear to be in the shape of a box through transforms that translate and rotate them. 0. transform = CATransform3DMakeTranslation(-kSize/2. M_PI_2. 1. self. M_PI_2.backLayer = [self layerWithColor:[UIColor yellowColor] transform:transform]. kPanScale * translation.x. 0). 0. -kPanScale * translation. 0).y.
0). layer.zPosition = z. transform = CATransform3DRotate(transform.height/2. CATransformLayer *contentLayer = [CATransformLayer layer].(void)viewDidLoad { [super viewDidLoad]. 0). } You now need to insert a CATransformLayer to work with. layer. as shown in the following code. This makes the box look  . 0).layer.(void)pan:(UIPanGestureRecognizer *)recognizer { CGPoint translation = [recognizer translationInView:self.view.bounds.view. } .view]. 0)].transform = CATransform3DMakeTranslation(size.bounds = CGRectMake(0. contentLayer. kSize.sublayerTransform = transform. } .contentLayer addSublayer:layer]. 1. 0. CGSize size = contentLayer. 1. CATransform3D transform = CATransform3DIdentity. self. [self. contentLayer.contentLayer = contentLayer. self.x. It’s not used to determine location in space. y)..topLayer = [self layerAtX:0 y:-kSize/2 z:0 color:[UIColor redColor] transform:MakeSideRotation(1.size. but you can adjust this to “zoom the camera. layer. 0.backgroundColor = [color CGColor]. then zPosition is only used for calculating layer order. I won’t go into the math here. kSize). size. For most cases.  BoxTransformViewController.bounds. 2000 units works well. transform = CATransform3DRotate(transform.m (BoxTransform) .” You could also build this box by setting position and zPosition rather than translating. self.y. -kPanScale * translation..width/2.152 Part II: Getting the Most Out of Everyday Tools You apply a perspective sublayerTransform (a transform applied to all sublayers. .frame = self.(CALayer *)layerAtX:(CGFloat)x y:(CGFloat)y z:(CGFloat)z color:(UIColor *)color transform:(CATransform3D)transform { CALayer *layer = [CALayer layer]. return layer. This may be more intuitive for some developers. layer.view. kPanScale * translation. but not the layer itself ).layer addSublayer:contentLayer]. layer. but the m34 position of the 3D transform matrix should be set to -1/EYE_ DISTANCE. [self. If you just use a CALayer. 0. 0.position = CGPointMake(x.transform = transform.layer.
All of these can be animated.Chapter 7: Layers Like an Onion: Core Animation 153 completely flat. For instance. is the automatic border effects that CALayer provides. For instance.  Decorating Your Layers A major advantage of CALayer over UIView. which can provide some nice visual effects. CALayer can automatically give you rounded corners. rounded border and shadow. without requiring you to apply a perspective transform. a colored border.  Figure 7-4 Layer with colored. you can adjust the position and shadow to give the illusion of clicking as the user presses and releases a layer. and a drop shadow. The following code will create the layer shown in Figure 7-4. CATransformLayer supports full use of zPosition. even if you’re only working in 2D.  .
for instance.shadowOffset = CGSizeMake(3. In the following examples. circleLayer.view.. layer. layer. but there are times you’d like to configure them. CABasicAnimation *anim = [CABasicAnimation animationWithKeyPath:@”position”].borderColor = [[UIColor blueColor] CGColor]. . circleLayer. layer. 3. When you modify the position property. layer. [circleLayer setPosition:CGPointMake(100. 100)]. To modify how an implicit animation behaves.radius = 20. layer.m (Decoration) CALayer *layer = [CALayer layer].frame = self. the default action is to animate it over a quarter second.0. This allows you to configure your animations when you create the layer rather than applying an explicit animation every time you change a property.borderWidth = 5. circleLayer.  Auto-animate with Actions Most of the time.  ActionsViewController.154 Part II: Getting the Most Out of Everyday Tools DecorationViewController.radius = 20. Let’s modify this so that changes in position always animate over 2 seconds: CircleLayer *circleLayer = [CircleLayer new].frame = self. 100.0). circleLayer. .layer addSublayer:circleLayer]. anim.duration = 2..view.bounds. NSMutableDictionary *actions = [NSMutableDictionary dictionaryWithDictionary: [circleLayer actions]].frame = CGRectMake(100.cornerRadius = 10. you need to configure the layer’s actions.shadowOpacity = 0.view.layer addSublayer:layer].backgroundColor = [[UIColor redColor] CGColor]. and especially if you want it to always behave that way for this layer. CircleLayer is a layer that draws a red circle in its center with the given radius.actions = actions. [actions setObject:anim forKey:@”position”]. You can turn off all implicit animations using CATransaction. layer.bounds.. [self. 100).view.m (Actions) CircleLayer *circleLayer = [CircleLayer new]. circleLayer. [self. [circleLayer setPosition:CGPointMake(100.layer addSublayer:circleLayer]. 100)].. implicit animations do what you want. Layer actions are fired in response to various changes on the layer. such as adding or removing the layer from the hierarchy or modifying a property. layer. 100. [self.5. but that only applies to the current transaction (generally the current run loop).  .view.
CircleLayer. }  . .0].fromValue = [NSNumber numberWithDouble:0. So changing the radius causes your current circle to cross-fade with your new circle. growAnim. growAnim. [actions setObject:groupAnim forKey:kCAOnOrderIn].animations = [NSArray arrayWithObjects:fadeAnim. This is commonly used with a CATransition (a special type of CAAnimation). as shown in the following example. There are some special actions for when the layer is added to the layer tree (kCAOnOrderIn) and when it’s removed (kCAOnOrderOut).8].toValue = [NSNumber numberWithDouble:1. There are a few steps to make this work correctly. groupAnim. You can apply a CATransition as the action for the contents property to create special effects like slide show whenever the contents change. This probably isn’t what you want. By default. in the CircleLayer.toValue = [NSNumber numberWithDouble:1. you can make a group animation of growing and fade-in like this: CABasicAnimation *fadeAnim = [CABasicAnimation animationWithKeyPath:@”opacity”].(id)init { self = [super init]. you have a radius property. For example. the fade transition is used. radius is not animated. A dictionary cannot hold nil.fromValue = [NSNumber numberWithDouble:0. but contents is (using a fade CATransition). } return self. CABasicAnimation *growAnim = [CABasicAnimation animationWithKeyPath: @”transform.m (Actions) @implementation CircleLayer @dynamic radius.Chapter 7: Layers Like an Onion: Core Animation 155 Setting the action to [NSNull null] disables implicit animations for that property. fadeAnim. CAAnimationGroup *groupAnim = [CAAnimationGroup animation]. but what about custom properties on CALayer subclasses? For instance.scale”]. By default. Actions are also important when dealing with transitions (kCATransition) when one layer is replaced with another. so you need to use the NSNull class. growAnim.4]. nil]. You want radius to animate just like position. fadeAnim.  Animating Custom Properties Core Animation implicitly animates several layer properties. if (self) { [self setNeedsDisplay].0].
} . return self.size. CGContextFillPath(ctx).(id < CAAction >)actionForKey:(NSString *)key { if ([self presentationLayer] != nil) { if ([key isEqualToString:@”radius”]) { CABasicAnimation *anim = [CABasicAnimation animationWithKeyPath:@”radius”].  . } @end I’ll start with a reminder of the basics. return anim. } return [super needsDisplayForKey:key]. [[UIColor redColor] CGColor]). You implement initWithLayer: so that you copy your custom property to the presentation layer.156 Part II: Getting the Most Out of Everyday Tools . radius).x = (self.width .size = CGSizeMake(radius.fromValue = [[self presentationLayer] valueForKey:@”radius”]. You call setNeedsDisplay in init so that your custom drawInContext: is called the first time you’re added to the layer tree. CGFloat radius = self.height . CGContextAddEllipseInRect(ctx.radius) / 2. You implement actionForKey: to return an animation with a fromValue of the currently displayed (presentationLayer) radius.bounds.origin.(id)initWithLayer:(id)layer { self = [super initWithLayer:layer].radius. anim. Now you come to your actions. rect). } } return [super actionForKey:key]. CGRect rect. rect.origin.size. You override needsDisplayForKey: so that whenever radius is modified.(void)drawInContext:(CGContextRef)ctx { CGContextSetFillColorWithColor(ctx. } .y = (self. rect.bounds. } + (BOOL)needsDisplayForKey:(NSString *)key { if ([key isEqualToString:@”radius”]) { return YES. This means that you’ll animate smoothly if the animation is changed midflight. rect. [self setRadius:[layer radius]].radius) / 2. you automatically redraw.
There are still a few rough edges to it.com or through the Xcode Documentation and API Reference. Matt.com/2008/09/parametric-acceleration-curves-in-core. so having a good understanding of how it works is crucial. such as damped ringing and exponential decay.” Cocoa With Love.html  . cocoawithlove. unlike UIView properties. Changes to CALayer properties are batched into transactions using CATransaction. it can be challenging to debug. It is vital that you not override it by either implementing your own accessors or using @synthesize to do so. CALayer automatically generates accessors for its properties at runtime. Animation Types and Timing Programming Guide Core Animation Programming Guide  Other Resources Dzhumerov.  Core Animation and Threads It’s worth noting that Core Animation is very tolerant of threading.me/technical/core-animation-3d-model/ Gallagher.  Summary Core Animation is one of the most important frameworks in iOS. drawInContext: may be called from any thread (although a given CGContext should be modified on only one thread at a time). and sometimes things need to be “just so” to make it work correctly (for example. “Parametric acceleration curves in Core Animation. Milen. however. implementing your properties with @dynamic rather than @synthesize). you should perform Core Animation actions on a thread with a run loop to improve performance. If you don’t have a run loop. and those accessors have important logic. not @synthesize.  Further Reading Apple Documentation The following documents are available in the iOS Developer Library at developer.apple.” Code Juggler.Chapter 7: Layers Like an Onion: Core Animation 157 It is critical to note that you implemented the radius property using @dynamic here. You can generally modify CALayer properties on any thread. Explains how to implement timing curves that cannot be implemented with CAMediaTimingFunction. This happens automatically if you have a run loop. including the magic -1/2000. When it doesn’t work correctly. you need to call [CATransaction flush] periodically. http://milen. though. It puts a fairly easy-to-use API in front of an incredibly powerful engine. If at all possible. Hopefully this chapter has made you confident enough with the architecture and the documentation to dive in and make some really beautiful apps. An excellent overview of the math behind the perspective transform. “Core Animation’s 3D Model.
158 Part II: Getting the Most Out of Everyday Tools  .
and your app probably crashes.. Accept that in this impossible case you may crash. or errors you won’t be able to recover from anyway. which by default crashes your program. Besides. This isn’t a great solution. Particularly during development. The most common of these is failure to allocate memory. you learn how to get those crash reports from your users. but let’s pretend) that stringWithFormat: might fail because Foundation isn’t able to allocate memory. This raises an NSInternalInconsisten cyException. it’s almost impossible to write error-handling code in Objective-C that does not itself allocate memory.Chapter 8  Tackling Those Pesky Errors  Error management can be one of the most frustrating parts of development. and NSError objects. and how to log effectively and efficiently. The first and most obvious is to crash. this is a very good thing.. the OS is very likely about to shut you down anyway. It’s hard enough getting everything to work when things go well. It is conceivable (not really. Because your program may crash in the field. } . I’ve seen a lot of very elaborate code around handling extremely unlikely errors. 1]. Cocoa provides some tools to make the job easier. NSArray *array = [NSArray arrayWithObject:string].” which means the failure tends to happen close to the bug. and keep the code simple. It needlessly complicates the code. }  . In this chapter you learn the major patterns that Cocoa uses to handle errors that you should use in your own projects. closely related error-handling approach is NSAssert. If you can’t allocate small amounts of memory.  Error Handling Patterns There are several useful approaches to handling errors. It “fails fast. You also learn the major error-handling tools. and there’s nothing you’re going to be able to do anyway.maxIndex) { return. exceptions. but to build really great apps you need to manage things gracefully when they go wrong. Consider the following code: NSString *string = [NSString stringWithFormat:@”%d”. but don’t discount it too quickly. Don’t do that. One of the worst things I see in code is something like this: .(void)doSomething:(NSUInteger)index { if (index > self. In that case it returns nil. You could (and in C you often would) include a check here to make sure that doesn’t happen. including assertions. and the call to arrayWithObject: throws an exception for trying to insert nil into an array. The next.
or would you prefer that it run in a possibly random way? Different  . There is a major difference between expected and unexpected errors. I’ll discuss assertions more in the following two sections. Expected errors should be handled gracefully and should never crash.  Technically abort sends the process a SIGABRT. which can be caught by a signal handler. See “Catching and Reporting Crashes” later in this chapter for information about how to handle crashes.160 Part II: Getting the Most Out of Everyday Tools Clearly passing an out-of-range index is a programming error. You need to recover gracefully when you cannot write a file. which by default calls abort and crashes the program. These should generally be handled with assertions. You can generally ignore truly unexpected errors and let them crash you. The worst thing NSArray could do is to silently ignore bad values. It can easily happen if the user has requested that iTunes fill the device with music. The lesson here is that crashing is not the worst-possible outcome. running out of disk space is a rare but expected error. It should never happen in normal operation. The common pattern for managing expected errors is to return an NSError object by reference. This is processed by the current exception handler. Data corruption is generally the worst-possible outcome. If you are familiar with Mac development. it’s definitely better to crash. raises an exception. “Assertions” and “Exceptions. On the other hand. you may be used to exceptions terminating only the current run loop. which terminates the program no matter what thread it runs on.” including how to manage development and release builds. That is incredibly difficult to debug. Generally I do not recommend catching SIGABRT. It’s the caller’s job to pass good values. It really comes down to this: When your program is in an illegal state. and how to make these a bit more graceful. You should have received a memory warning and been terminated long before you got to that state. In iOS. NSAssert tests a condition. There are differing opinions on whether NSAssert should be disabled in release code. This code swallows that error. and if it returns NO. I’ll discuss this in “Errors and NSError” later in this chapter. but iOS calls abort by default. Consider the following example of NSAssert: NSAssert(x == 4. It’s better to crash. would you rather it stop running. An assertion requires that something must be true at a certain point in the program. Note how NSArray handles this situation. If it is not true. failure to allocate small amounts of memory is an unexpected error. In the middle are programming errors. then the program is in an undefined state and should not proceed. @”x must be four”). and if getting into a deeply unknown state could corrupt user data. If you pass an index out of range it raises an exception very similar to NSAssert. turning it into a no-op. You can disable NSAssert by setting NS_BLOCK_ASSERTIONS.  Assertions Assertions are an important defense against programming errors.
because __FILE__ and __LINE__ need to be evaluated at the point of the original caller. \ } Assertions often precede code that would crash if the assertion were not valid. NSCAssert is required when using assertions within C functions. This also defines RNCAssert as a wrapper around NSCAssert and a helper function called RNAbstract. [array addObject:foo]. Setting NS_BLOCK_ ASSERTIONS completely eliminates them from the code. ## __VA_ARGS__). The following code assumes you have an RNLogBug function that logs to your log file. @”foo must not be nil”). while I like removing assertions in the Release configuration. .  RNAssert. I don’t like ignoring them. My opinion is that it’s generally better to disable assertions in release code. That said. but it’s necessary here. even with assertions turned off. }  . ## __VA_ARGS__). \ NSAssert((condition). even in release mode #define RNAssert(condition. It’s mapped to NSLog as an example. \ NSCAssert((condition). The problem with this is that in the field.) \ if (!(condition)) { \ RNLogBug((desc). My solution is to wrap assertions so that they log in all cases. For example (assuming you’re using RNAssert to log even in the Release configuration): RNAssert(foo != nil. Xcode 4 templates automatically disable assertions when you build for the Release configuration. @”foo must not be nil”). but the assertion causes a crash. What was the point of turning off assertions if you’re going to crash anyway in many cases? That leads to code like this: RNAssert(foo != nil. desc) \ if (!(condition)) { \ RNLogBug((desc).. Generally I don’t like to use #define. desc.. (desc). (desc). this still crashes.h> #define RNLogBug NSLog // Use DDLogError if you’re using Lumberjack // RNAssert and RNCAssert work exactly like NSAssert and NSCAssert // except they log.h #import <Foundation/Foundation. if (foo != nil) { [array addObject:foo]. ## __VA_ARGS__). I’ve seen too many cases where the programming error would have only caused a minor problem. They’re exactly the kind of “this should never happen” error condition that you’d want to find in your logs. rather than Objective-C methods.Chapter 8: Tackling Those Pesky Errors 161 people come to different conclusions here. \ } #define RNCAssert(condition. ## __VA_ARGS__).
and the program catching such an exception should quit soon afterwards. In short. it’s best to use NSAssert to raise an NSInternalInconsistencyExce ption. default: RNAssert1(NO. exceptions are not for handling recoverable errors in Objective-C. but I recommend +raise:format: for simplicity.  Exceptions Exceptions are not a normal way of handling errors in Objective-C.. using RNAssert so that you log. it will help you catch any switch blocks that you failed to update. You can build these by hand. I recommend this pattern when you want an assertion: if (foo != nil) { [array addObject:foo]. and in fact NSAssert is implemented as an exception. Objective-C has language-level support for exceptions using directives such as @throw and @catch. or create and raise your own NSException object.com): The Cocoa frameworks are generally not exception-safe. however. switch (foo) { case kFooOptionOne: . @”foo must not be nil”). break. I almost always recommend an assertion as the default case of a switch statement. The general pattern is that exceptions are reserved for programmer error only. There is seldom a good reason to catch exceptions except at the top level of your program. This is similar to NSAssert. if you add a new enumeration item. which is done for you with the global exception handler. case kFooOptionTwo: .. } This ensures that the assertion always matches the conditional. This raises more opportunities for bugs if the assertion and conditional don’t match. Sometimes assertions are overkill. @”Unexpected value for foo: %d”. If you want to raise an exception to indicate a programming error..162 Part II: Getting the Most Out of Everyday Tools That’s a little better. foo): break. Instead..apple. break. } else { RNAssert(NO. } This way. but this is a good pattern in cases where you want one. Exceptions are for handling those things that should never happen and which should terminate the program. but you’ve got duplicated code. but you generally should not use these. From Exception Programming Topics (developer.  .
max]. if iTunes Connect works for you. Apple makes a single blanket request to the user for permission to upload crash reports. It’s handy and nice. Currently it does not handle uploading logs to go along with the crash report.net). so you need a different system during development and internal betas. In short.. The clang flag -fobjc-arc-exceptions controls this. Because you generally shouldn’t catch exceptions directly. Quincy Kit is built on top of PLCrashReporter from Plausible Labs. which can lead to leaks on background threads. but it has a lot of limitations. You probably should not try to rewrite PLCrashReporter. Automatic Reference Counting is not exception safe by default in Objective-C.. they may have symbols or they may not. Failure to allocate small amounts of memory should be treated as a programming error in iOS because it shouldn’t be possible and almost certainly indicates a programming error. Reports are updated only once a day. you might consider writing your own version of Quincy Kit. In principle ARC is exception safe in Objective-C++.%d)”. Xcode uses Spotlight to find these files. It’s easy to integrate into an existing project. min. and a programming error. programming errors should also raise exceptions in release mode.  Catching and Reporting Crashes iTunes Connect is supposed to provide crash reports. and with logging in release mode. While a program is in the middle of crashing. index. but @autoreleasepool blocks are still not released. If you need more flexibility. Properly handling all of the subtle issues that go with that is not simple. and it uploads reports to your own web server after asking user permission. Xcode generally does a good job of automatically symbolicating the reports (replacing addresses with method names) in Organizer as long as you keep the . great.  Errors and NSError There is a major difference between a user or environment error. the difference between NSInternal InconsistencyException and NSRangeException is rarely useful. iTunes Connect only supports applications deployed on the App Store. Quincy Kit provides a friendly front end for uploading that information. You should do as little work as possible during the crash event. but often it doesn’t. Making ARC exception safe incurs performance penalties. which is one of many reasons to avoid significant use of Objective-C++. it would be just as clear and useful to use NSAssert.dSYM file for every binary you ship. When you get your crash reports. and Landon Fuller has been working on PLCrashReporter for years. it can be in a bizarre and unknown state. PLCrashReporter handles the complex problem of capturing crash information. but not all that complicated.  . That’s why Quincy Kit uploads the crash files when the program restarts rather than during the crash. Many users decline. If data corruption is possible. Even something as simple as allocating or freeing memory can deadlock the system and rapidly drain the battery. There seldom is much reason to do this. so make sure they’re available in a place that Spotlight can search. depending on how your image was built.Chapter 8: Tackling Those Pesky Errors 163 [NSException raise:NSRangeException format:@”Index (%d) out of range (%d. Programming errors should be handled with exceptions in debug mode. You should expect significant memory leaks from exceptions. The best replacement I’ve found is Quincy Kit (quincykit. In almost all cases.
They might still check the return value to determine the overall success or failure of the operation. This would be confusing and error prone. but because it conforms to NSCoding. If the method instead returned an NSError. then nil would indicate success. if (! success) { if (error != NULL) { *error = [NSError errorWithDomain:. NSFileManager is a good example of an object that uses NSError extensively. but in NSCocoaErrorDomain the error code 4 indicates that a file was not found (NSFileNoSuchFileError).) should never raise exceptions. generally using an NSError object. the caller would have to guess how  . This allows callers to pass NULL to indicate that they do not care about the error details... They should return errors. Internally the method might look something like this: .(BOOL)copyItemAtPath:(NSString *)srcPath toPath:(NSString *)dstPath error:(NSError **)error This method copies a file or directory from one location to another. the method returns NO and updates an NSError object that the caller passes by reference (pointer to a pointer). and the domain is a string that allows you to identify the meaning of that integer. It can obviously be passed within a program. etc. It can even encapsulate error recovery mechanisms using the NSErrorRecoveryAttempting protocol.(BOOL)copyItemAtPath:(NSString *)srcPath toPath:(NSString *)dstPath error:(NSError **)error { BOOL success = .. } Note how this checks that error (a pointer to a pointer) is non-NULL before dereferencing it. if (! [fileManager copyItemAtPath:srcPath toPath:toPath error:&error]) { [self handleError:error]. in NSPOSIXErrorDomain the error code 4 indicates that a system call was interrupted (EINTR). Errors are primarily defined by their domain and a code. Obviously that might fail for a variety of reasons. NSError encapsulates information about an error in a consistent package that is easy to pass around. . The code is an integer. NSError *error. For instance. it’s easy to write to disk or over a network. disk full.164 Part II: Getting the Most Out of Everyday Tools User errors or environment errors (network failures.]... If it does. } } return success. as shown in this example. } This pattern is convenient because the return value is consistent with the success of the operation. Without a domain.
Error Recovery Attempter An error recovery attempter is a way to encode error recovery options into the NSError object.  Error Localization Where to localize errors is always a tricky subject. You should never localize a string that you do not intend to display to a user.example.strings appended. Instead. In that file.” Then. you would have a localized strings file named com. It just wastes money and confuses users in more languages. such as NSStringEncodingErrorKey for passing the relevant string encoding or NSURLErrorKey passing an URL. Several domains already do this. to read the file. and an object to inform of the selected option. If the error is passed through several layers. Errors like “Interrupted system call (4)” are generally not useful to the user.ErrorDomain. some description text (called the “suggestion”). such as com. Low-level frameworks tend to present errors in very userunfriendly ways. Translating such an error message into French and Spanish doesn’t help anything. Because errors often need to be logged in the developer’s language.MyApp. for the error domain com. You are encouraged to create your own domains for your own errors. [error code]].  . NSUnderlyingErrorKey. You’re free to create new keys to provide domain-specific information. this lets the UI communicate back to the original subsystem to let it attempt to recover. and NSRecoveryAttempterErrorKey.ErrorDomain. localize only at the point of displaying the error.strings. just map the error code to the localized value: “1” = “File not found.Chapter 8: Tackling Those Pesky Errors 165 to interpret the error code. I recommend against using NSLocalizedDescriptionKey and its relatives in most cases for NSError. The error recovery system encapsulates localized options.ErrorDomain. NSString *localizedMessage = [[NSBundle mainBundle] localizedStringForKey:key value:nil table:[error domain]]. MyApp. NSError includes a user info dictionary that can contain any information you like. There are several pre-defined keys for this dictionary such as NSLocalizedDescriptionKey. You can keep localized strings for various error codes using a localized string table with the same name as your error domain with . This object should conform to the NSRecoveryAttempting informal protocol.  This last point bears emphasizing.MyApp. You should generally use a Uniform Type Indicator (UTI) for this. Localizing these kinds of error messages actually makes things more difficult to debug because logs may be sent to you reporting errors in a language you can’t read.example. just use NSBundle: NSString *key = [NSString stringWithFormat:@”%d”.example. For instance.
(void)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex { NSError *error = objc_getAssociatedObject(actionSheet. error.m (ErrorRecovery) #import “RNErrorManager. OBJC_ASSOCIATION_RETAIN_NONATOMIC). sheet.h” static const char kRNErrorKey. } objc_setAssociatedObject(sheet. sheet. static RNErrorManager *sSharedManager.h (ErrorRecovery) @interface RNErrorManager : NSObject <UIActionSheetDelegate> + (RNErrorManager *)sharedManager. } + (RNErrorManager *)sharedManager { return sSharedManager. &kRNErrorKey.(UIActionSheet *)actionSheetForError:(NSError *)error { UIActionSheet *sheet = [[UIActionSheet alloc] init]. &kRNErrorKey). @implementation RNErrorManager + (void)initialize { sSharedManager = [[RNErrorManager alloc] init].title = [error localizedRecoverySuggestion].(UIActionSheet *)actionSheetForError:(NSError *)error. return sheet. for (NSString *option in [error localizedRecoveryOptions]) { [sheet addButtonWithTitle:option]. @end  RNErrorManager. . Here’s an example singleton that will manage a UIActionSheet based on the error-recovery options. id attempter = [error recoveryAttempter].166 Part II: Getting the Most Out of Everyday Tools iOS provides no UI integration for error recovery.  RNErrorManager. } .delegate = self. if ([attempter respondsToSelector: @selector(attemptRecoveryFromError:optionIndex:)]) { [[error recoveryAttempter] attemptRecoveryFromError:error  . but it’s not hard to roll your own. } .
then it’s easy to move the showIn. you can figure out the relevant error.: call to RNErrorManager.Chapter 8: Tackling Those Pesky Errors 167 optionIndex:buttonIndex]. @”OPTION: Avoid error by leaving. } else { NSAssert(NO.”). [userInfo setObject:options forKey:NSLocalizedRecoveryOptionsErrorKey]. @”OPTION: Fix error”). [userInfo setObject:self forKey:NSRecoveryAttempterErrorKey]..m (ErrorRecovery) NSArray *options = [NSArray arrayWithObjects: NSLocalizedString(@”Run away”.view]. The calling code might look like this:  ErrorRecoveryViewController. } } @end In actionSheetForError:. you fetch the error using objc_getAssociatedObject and call the delegate method on the recovery attempter. this generates a UIActionSheet. NSError *error = [NSError errorWithDomain:RNAppErrorDomain code:kRNAppBadThingError userInfo:userInfo]. When the button is clicked. [sheet showInView:self.”). sets itself as the delegate.  . NSLocalizedString(@”Hide”. [userInfo setObject:NSLocalizedString(@”What do you want to do?”. @”OPTION: Avoid error by hiding. @”Request decision. Because you can display UIActionSheet many different ways. and uses objc_setAssociatedObject to attach the original NSError to the sheet. it’s convenient to have RNErrorManager return the sheet rather than present the sheet itself. @”Recovery attempter does not implement protocol. nil]. That way when you are called back.. NSLocalizedString(@”Fix”. If your application only presents these in one way.”). UIActionSheet *sheet = [[RNErrorManager sharedManager] actionSheetForError:error]. NSMutableDictionary *userInfo = [NSMutableDictionary dictionary].”) forKey:NSLocalizedRecoverySuggestionErrorKey].
you actually respond to the user’s choice in the original caller. fix it.”). Foundation provides a single logging call: NSLog. case kRecoveryOptionHide: NSLog(@”Hide!”). } }  Logs Logging is a critical part of debugging. recoveryOptionIndex)..168 Part II: Getting the Most Out of Everyday Tools Finally. which is never appropriate in released code.  . Some people deal with this issue simply: #ifdef DEBUG #define MYLog NSLog #else #define MYLog #end That’s fine for pulling out NSLog. Let’s start with logging in the right way. Here are some of the things to consider in your logging engine: ■ It should log to console in debug mode and to a file in release mode. break. Ideally it should be able to log to both at the same time. What you need is a logging engine that adapts to both development and release. break.. NSLog should never appear in production code. Worst of all. default: NSAssert(NO. If you don’t log to console in debug mode. This nicely separates error recovery logic from error presentation. which is not ideal. but now you have no logs at all. You want to log the right things and you want to log in the right way. break. case kRecoveryOptionFix: NSLog(@”OK. It is inflexible and incredibly slow.. The only advantage NSLog has is that it’s convenient. break. It’s also very hard to get right. allowing you to provide a consistent error UI throughout your application. @”Unknown recovery option: %d”. it logs to the console. you won’t see logging output in Xcode.m (ErrorRecovery) .(void)attemptRecoveryFromError:(NSError *)error optionIndex:(NSUInteger)recoveryOptionIndex { switch (recoveryOptionIndex) { case kRecoveryOptionRunAway: NSLog(@”Run Away!”).  ErrorRecoveryViewController.
and age your logs so quickly that you probably still won’t have the information you need. Consider the following code: NSString *expensiveValue = [self expensiveCall]. but this is a very cheap operation compared to expensiveCall. [self expensiveCall]].. it requires only a few extra lines of code to configure. DDLogVerbose(@”expensiveValue=%@”. [self expensiveCall]). If you build your own logging engine. Are you just relogging something that is already covered by another log statement? This is particularly important if you’re logging data rather than just “I’m in this method now. See “Further Reading” at the end of this chapter for the link. If you log too little. you’ve wasted time calculating it. ask yourself what you would ever do with it. ■ It should make sure that logging to disabled logging levels is cheap. If you log too much.]). Middle ground is very application specific. The log level is checked twice (once in the macro and once in [DDLog log:. In this case. expensiveCall is not executed unless needed. you won’t have the information you need to debug issues.Chapter 8: Tackling Those Pesky Errors 169 ■ It should include logging levels (error. In Lumberjack it’s done this way:  . you’ll overwhelm even the best system. This still leaves the question of what to log.. info. format:@”expensiveValue=%@”. The NSLog interface is very easy to use. verbose). You definitely don’t want simple logging statements to require multiple lines of code.. expensiveValue). In general. ■ It must support log aging to avoid filling the hard disk. warning. A similar logging trick is to make sure you need to log before entering a loop. this is a good technique to emulate. and a simple substitution of NSLog calls to DDLog.. If you never use expensiveValue in the upcoming code and verbose logging isn’t turned on. When adding a logging statement.. but there are some general rules. calls to implement. ■ It should be very easy to call.” Avoid calculating complex data if you might not log it. My current recommendation for iOS logging is Lumberjack from Robbie Hanson of Deusty Designs. hurt performance. Lumberjack is written in such a way that this stays cheap: DDLogVerbose(@”expensiveValue=%@”. This translates to do { if(ddLogLevel && LOG_FLAG_VERBOSE) [DDLog log:. generally using a C syntax with varargs rather than an Objective-C syntax. ■ It should not block the calling thread while it writes to a file or the console. } while(0). and you want something that looks basically like that..
If you need this kind of functionality.  . Don’t ask your customers to “just trust you” with their sensitive information. and you have the decryption key. but the more of their information in your possession. the more legal issues you have to consider. it is occasionally important to see the real data in the logs. verbose logging is turned off so even if DDLogVerbose checks the level again. but this is sometimes trickier than it sounds. That’s even more important if complex work needs to be done to generate the log. this would have been much easier to discover. just make sure it doesn’t stay in place in production code. Many applications process information that should never go into a log. } } The point of this is to avoid repeatedly calculating whether to log and to avoid calculating the log string. You often will want to compress them first. When verbose logging is turned on the extra LOG_VERBOSE check is trivial compared to the rest of the loop.  Logging Sensitive Information Logging opens up serious privacy concerns. Otherwise you can use MFMailComposeViewController to send them as an attachment. Not only does it put the customer at risk. What if sensitive information is sent over a network and you log the packets? You may need to filter your logs before writing them to avoid this. I spent quite some time tracking down a bug where we were dropping the last character of the password. Encrypting your logs does nothing to help this situation. and avoids creating a string for object. If you have automated tests. Most of the time. There are some wrappers for Minizip such as Objective-Zip and ZipArchive. you could upload them. you’re probably logging something you shouldn’t be. Regularly audit your logs to make sure you’re not logging sensitive information.170 Part II: Getting the Most Out of Everyday Tools if (LOG_VERBOSE) { for (id object in list) { DDLogVerbose(@”object=%@”. search the logs for your password and any other sensitive information. The problem is that the users send their logs to you. During development. the above code is cheaper in most cases. After running your program at the maximum logging level. this generally can be added fairly easily. Had we logged the password. I’ve had good luck using Minizip for this (see “Further Reading”). If you have a network protocol. Keep in mind the potential size of your logs. Don’t forget to include some way to get the logs from the user.  Getting Your Logs Logs aren’t very useful if you can’t get to them. If you feel you need to encrypt your logs. Few things eat up profits as quickly as consulting lawyers. but I’m not particularly impressed with them. object). Obviously you should not log passwords or credit card numbers.
www. This is highly portable. Gilles. blog. “Exceptions and Errors on iOS. code.apple. quincykit. Don’t let the “win” and “Dll” fool you. “Automatic Reference Counting.winimage. clang.google. zLib and Minizip.” Jayway Team Blog. The standard for ZIP file handling.exceptions Lumberjack. code.com/2010/10/13/exceptions-and-errors-on-ios Quincy Kit. A good discussion of programmer versus user errors and how to deal with exceptions versus other kinds of errors. Fredrik.com/zLibDll/minizip. but you should have the tools to make it a manageable one. It’s much easier to manage things when they go right than when they go wrong.com or through the Xcode Documentation and API Reference. A nice crash-catcher for iOS.llvm.Chapter 8: Tackling Those Pesky Errors 171 Be sure to ask permission before sending logs. There’s nothing that will make this an easy process.  Summary Error handling is one of the trickiest parts of any environment.org/docs/AutomaticReferenceCounting.html  . Generally you should only need to send logs in response to a problem report. Mac and iOS logger.” This is the official documentation on how ARC and exceptions interact.  Further Reading Apple Documentation The following documents are available in the iOS Developer Library at developer. but sending logs can use a lot of bandwidth and battery.html#misc.net Volant. In this chapter you’ve seen how to best handle things when they go wrong.jayway.com/p/cocoalumberjack/ Olsson. Not only are there privacy concerns. Exception Programming Topics Error Handling Programming Guide TN2151: Understanding and Analyzing iPhone OS Application Crash Reports  Other Resources Clang documentation.
172 Part II: Getting the Most Out of Everyday Tools  .
Part III  The Right Tool for the Job Chapter 9 Controlling Multitasking Chapter 10 REST for the Weary Chapter 11 Batten the Hatches with Security Services Chapter 12 Running on Multiple iPlatforms and iDevices Chapter 13 Internationalization and Localization Chapter 14 Selling Past the Sale with In App Purchase  .
.
Chapter 9  Controlling Multitasking  There are two broad meanings of “multitasking” in iOS. it refers to when a single application runs multiple operations simultaneously. Although your application may be terminated without warning any time it is suspended. but only in limited ways. In this chapter. registering an app as location aware.  Best Practices for Backgrounding: With Great Power Comes Great Responsibility In iPhoneOS 3. Your application should give the illusion that it’s always running. not the developer. it refers to running multiple applications at the same time by allowing one or more applications to run “in the background. only one third-party application could run at a time. you should skim the Concurrency Programming Guide before continuing. Apple wanted to make certain that the iPhone didn’t suffer the same performance and stability problems of earlier mobile platforms. If you need information about the fundamental technologies. I assume that you understand the basics of running tasks in the background. You learn the best practices for multitasking and discover the major iOS frameworks for multitasking: run loops. If you have never heard of them. it was terminated. This ensured that third-party background applications couldn’t waste resources like memory or battery.” Second. operations. If you are familiar with thread-based multitasking from other platforms. threads. and SimpleThread. Similarly. It can be very frustrating. Starting with iOS 4. but the policy has generally met its goal. This continued Apple’s focus on not allowing third-party applications to destabilize the platform or waste resources. First. and Grand Central Dispatch (GCD). SimpleOperation. Both are important parts of many iOS applications. iOS remains focused on the user. and similar backgrounding issues. you learn how to reduce your reliance on explicit threads and make the best use of iOS’s frameworks that avoid threads or handle threading automatically. most pointedly Windows Mobile. you learn how to give your users the illusion of multitasking without wasting system resources. and that you are familiar with beginBackgroundTaskWithExpirationHandler:. see “Executing Code in the Background” in the iOS Application Programming Guide. Apple began to permit third-party applications to run in the background. though you may never have used them in real code. The sample code for this chapter can be found in the projects SimpleGCD. it should give the impression  . this chapter assumes that you have at least a passing familiarity with operation queues and Grand Central Dispatch. When the user left your application. and this chapter discusses both. Perhaps most importantly. even though it isn’t.
it discards that data. This means that you should avoid displaying a splash screen during loading. There is a major exception to this rule. If you store it in an NSCache object. If throwing away your cached information makes resuming from the background as expensive as launching from scratch. your application is likely to be terminated when there is memory pressure. It’s part of the Allocations template. Now launch the memory pressure app. You should expect your drawRect: methods to be called when you resume. At that point. This saves you the cost of throwing away this object and re-creating it every time the user leaves your app briefly. Press the Home button and note the amount of memory you’re using now. even if your app is suspended at the time. Minimizing dirty memory reduces the likelihood that you will be terminated in the background. However. usually in ~/Library/Caches. If its memory footprint is very large. Your usage under memory pressure should be as low as possible. In Instruments. Note how much memory you release. This is what you’re releasing when you go into the background. there wasn’t any point to suspending. There is no one right answer. decompressing images can be very expensive. If you have a large image shown in a UIImageView. it does not receive memory warnings. The data for images loaded with imageNamed: are discarded automatically and reread from disk when needed again. Everything you do drains the battery. Be thoughtful about what you throw away and how long it will take you to re-create it. NSPurgeableData is an NSData object that you can flag as currently in use or currently purgeable. you will see two kinds of memory: dirty memory and resident memory. NSCache and NSPurgeableData are excellent tools for reducing dirty memory. while ensuring that it can be thrown away if needed. Dirty memory is the memory that iOS can’t automatically reclaim when you go into the background. the OS saves it until there is memory pressure. Reducing your app’s memory footprint is important when going into the background. Note the amount of memory you’re using. NSCache and NSPurgeableData are invaluable in addressing this issue. Larger data structures need to be written to files. so always look to avoid wasteful processing. Resident memory is your total current memory utilization. Then run your program with the VM Tracker. Views automatically throw away their backing stores (their bitmap cache).176 Part III: The Right Tool for the Job that nothing has changed when it launches again. Reducing it should be your primary focus. First create a “memory pressure” app that displays a massive image. and you should save sufficient state when you enter the background to resume seamlessly if terminated. In Instruments. your background usage should be less than your normal usage without being so low that you delay resuming. Resident memory is your entire memory footprint. Ideally. and you won’t have an opportunity to do anything about it. When your application is suspended.  . You need to profile your application. Your application should consume as little resources as possible when it is not the foreground application. A lot of framework data is automatically managed for you when your app goes into the background. the VM Tracker is useful for determining how much memory you’re using while in the background. Both are important for different reasons. UIImageView does not discard its data and this can be quite large. Minimizing this helps prevent low memory warnings while you’re in the foreground. you should generally remove it before going into the background. so you shouldn’t throw them away too often. NSUserDefaults is a good place to stash small amounts of data during applicationWillResignActive:. but so is minimizing the time required to resume. and mark it as purgeable with endContentAccess. even if it doesn’t visibly delay your app.
During that time. and a variety of other arcana. A subtle issue here is application termination. When your applicationWillResignActive: method. The system is waiting for you to return so it can continue. but it’s not the only resource.” That’s memory for decompressed images and is primarily caused by UIImage. Your application should delight. Some actions are forbidden while in the background. Running in the background creates new challenges for developers.  Make sure to shut down your OpenGL updates when the application is terminating as well as when going into the background. you should abort or pause any downloads that weren’t requested by the user. and repeats until something tells it to stop. even in very complex programs. and then dispatches that event to interested listeners. even when it’s not on screen. and watch your resource utilization.  . You almost never need to understand the internals of a run loop. you may see references to “Memory Tag 70. Memory is important. You must stop updating OpenGL views when you go into the background. The entire UI is hanging. If it does. disk access. it’s killed immediately. test heavily. This is the heart of an iOS program. The object that handles this is called a run loop (NSRunLoop). Keep that in mind when you’re writing your code. Generally you should complete any user-initiated download using beginBack groundTaskWithExpirationHandler:. The most significant is OpenGL calls. Avoid excessive network activity. provided that you can resume them later. or any other entry point to your program is called. IBAction. or anything else that will waste battery life. The application is allowed to run for a brief time after applicationWillTerminate: is called.Chapter 9: Controlling Multitasking 177 In the Instruments VM Tracker. What’s important to understand is that the run loop is just a big do/while loop. However. Just make sure to keep the user as your top priority. it’s because an event fired somewhere that traced its way to a delegate call that you implemented. scroll views can’t scroll. which could prevent it from finishing other application-termination logic. While your code is running on the main thread. waiting for you to finish. but users expect this key feature. buttons can’t highlight. which is the controller used by the OpenGL Game template in Xcode. These are incredibly rare in normal programs. they want to go play a game. the application is “in the background” and must not make OpenGL calls. GLKViewController automatically handles all of this for you. There are mach ports and message ports and CFRunLoopSourceRef types. Users don’t want to have to sit and stare at your application while their data downloads. timers can’t fire. pulling events off of various queues and dispatching them to listeners one at a time on that same thread. running on one thread.  Understanding Run Loops Every iOS program is driven by a do/while loop that blocks waiting for an event.
Delay-action methods like performSelector:withObject:afterDelay: are implemented by scheduling a timer. When you schedule an NSTimer. But what about other threads? The next section covers those.h (SimpleThread) @protocol CounterThreadDelegate <NSObject> @property (assign) NSUInteger count. you create an application that updates a simple counter on the screen. Animations generally run on background threads. you may need to spin off new threads. create an abstract NSThread class called CounterThread.  While each thread has a run loop. it’s very helpful to understand how NSThread works by itself. This will simplify showing various techniques. @end @interface CounterThread : NSThread @property (strong) id<CounterThreadDelegate> delegate.  Threading Blocking the main thread hangs your program. This is not as common as it may appear. UIApplicationMain sets up the main thread’s run loop for you. First. as does much of NSURLConnection network handling. The frameworks create and manage threads for you in most cases. Cocoa offers a useful thread abstraction called NSThread. and how to integrate it with a run loop.178 Part III: The Right Tool for the Job This doesn’t mean everything is on the main run loop.m of almost every project runs the main run loop. but pretend the operation is too expensive to do on the main thread. Run loops only execute their do/while loop in response to commands like runUntilDate: as discussed in the section “Threading” below. it checks what time it is and fires any timers that have expired. While operation queues and Grand Central Dispatch are becoming the preferred way to handle threading. For this example.  . But the heart of the system runs on a single. Each thread has its own run loop. completely transparently.  CounterThread. In this section you learn how to do this by hand. When that happens. This could easily be done with an NSTimer. You can write quite complex programs without explicitly creating any additional threads. @property (assign) BOOL shouldRun. this doesn’t mean that each thread processes its run loop. But sometimes you need to explicitly create your own worker threads. and in the later sections you learn better abstractions for handling threads. Most of the time all of this happens behind the scenes and you don’t need to worry about the run loop. The call to UIApplicationMain in main. it asks the current run loop to dispatch a selector at a certain time. The source code for this example is in the SimpleThread project. and keeps it running until the program terminates. so that’s not acceptable. shared run loop. Each time the run loop iterates. NSTimer relies on the run loop to dispatch messages. But some operations take a long time to run.
@”Abstract method. } } } } @end The main routine is run when the thread starts.Chapter 9: Controlling Multitasking 179 . It leaves memory in an unknown state. .(void)updateDelegate { // Whatever interesting work we want to do. so make sure // it’s threadsafe self. } .(void)stop.(void)updateDelegate. while (self. // Methods for our subclasses .shouldRun) { @autoreleasepool { [self processThread].(CounterThread *)initWithDelegate:(id)delegate.count + 1.delegate. } . It is possible to call cancel on a thread.delegate. @end  CounterThread. // This call is made on a background thread.count = self. } return self.(void)stop { self.(void)processThread.delegate = delegate.m (SimpleThread) @implementation CounterThread @synthesize delegate=delegate_. Releasing an NSThead object does not terminate the thread.(void)main { @autoreleasepool { self. .shouldRun = NO.(void)processThread { NSAssert(NO. Must be overridden”). The main routine must finish and return. } . When the main routine ends. . but you should avoid this. @synthesize shouldRun=shouldRun_.shouldRun = YES.(CounterThread *)initWithDelegate:(id)delegate { if ((self = [super init])) { self. } . the thread will terminate.  .
the thread cannot check shouldRun very often.180 Part III: The Right Tool for the Job Each thread is responsible for managing its own autorelease pool. ■ It needs to return periodically.m does for the main thread. [self. If it blocks indefinitely. and the thread may not terminate when it needs to. Threads also use memory and other kernel resources. The first @autoreleasepool takes care of any autoreleased objects that might be generated before reaching the loop. Because setText: modifies a UIKit object. } } The @synchronized makes sure that the calls to setText: are made in order. This can lead to leaking threads. That’s why you need to call it with performSelectorOnMainThread:withObject:waitUntilDone:. there aren’t any such objects.  . This puts a dramatic load on the CPU. That means it very rapidly checks shouldRun over and over.label performSelectorOnMainThread:@selector(setText:) withObject:string waitUntilDone:NO]. quickly drains the battery. not to ensure reading and writing the ivar are atomic. so they need to be terminated at appropriate times. The @autoreleasepool in the loop is important. so there’s no real need for this extra pool. and causes the device to heat up. With ARC (Automatic Reference Counting). but it’s a good habit to create one at the top of the thread just as main. The count getter doesn’t require an @synchronized because there is no point at which reading the scalar is unsafe. The pool isn’t drained until you reach the end of the @autoreleasepool block. There are a limited number of threads in the system. it busy-waits. autoreleased objects may be retained until the thread terminates. the compiler optimizes it out if it isn’t really needed. which cause your process’s thread count to grow over time. concrete subclasses override processThread to demonstrate different approaches. The updateDelegate method does whatever interesting work you want to do.(void)setCount:(NSUInteger)count { @synchronized(self) { count_ = count. If it immediately returns. It has to be thread-safe. count].(NSUInteger)count { return count_. In this example. the delegate’s count accessors looks like this:  STViewController. however. it has to run on the main thread. so this can eventually crash your program. There are two critical features of processThread: ■ It needs to block for some period of time. } // Thread-safe .m (SimpleThread) // Thread-safe . CounterThread is an abstract class. In this code. so without a block inside the loop. In the following examples. NSString *string = [NSString stringWithFormat:@”%d”.
An appropriate timeout is often between 1 and 10 seconds. } NSRunLoop *runLoop = [NSRunLoop currentRunLoop]. The call to runUntilDate: will block for no more than 1 second. Because you have no ivar holding the thread object. In your setter for that property. } This just sleeps for 1 second and updates the delegate.(void)processThread { [NSThread sleepForTimeInterval:1].m (SimpleThread) .(void)processThread { if (! self. but gives you no access to the thread once it’s been created. RunLoopThread is a subclass of CounterThread that demonstrates how to do this by calling runUntilDate:. that’s either a programming error and you should  . check whether a thread is already assigned. You should generally create a thread object and assign it to a property to keep track of it.Chapter 9: Controlling Multitasking 181 It is generally better to block too long than to check shouldRun too often as long as you are not rapidly generating and destroying threads (which you shouldn’t do anyway).timer) { self. you can now run arbitrary methods on this thread. That’s because this thread is not processing its run loop. This method automatically generates a thread for you. [runLoop runUntilDate:[NSDate dateWithTimeIntervalSinceNow:1]]. Using performSelector:onThread:withObject:waitUntilD one:. the thread behaves very much like the main run loop. [self updateDelegate]. What if you created an NSTimer inside updateDelegate? It would never execute. I recommend against using performSelectorInBackground:withObject: in most cases. This kind of thread is useful for many operations. you can’t easily determine that there is already a thread running for this operation. allowing processThread to return and the calling main function to check whether the thread should terminate. This makes it easy to accidentally leak threads.timer = [NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(updateDelegate) userInfo:nil repeats:YES]. } Using this approach. but it has a problem.  RunLoopThread. but something needs to process it (sometimes called “pumping the run loop”). If it is. Every thread has a run loop. and it’s the run loop that is responsible for checking the current time and dispatching any timers that have expired. Then main checks shouldRun and executes processThread again if appropriate. The most common mistake is to call performSelectorInBac kground:withObject: in methods like viewDidLoad that can be called more than once. The simplest concrete implementation of CounterThread is SimpleCounterThread: @implementation SimpleCounterThread .
count = 0. It is especially good for architectures that require a small number of long-lived threads. particularly when coupled with @synchronize. self. self. you use NSBlockOperation.(void)setCount:(NSUInteger)count { count_ = count.count + 1.  ViewController.count = myself.queue addOperation:op]. or it’s acceptable and you should terminate the old thread before creating the new one. [[NSOperationQueue mainQueue] addOperationWithBlock:^{ myself. op. [self addNextOperation]. } // Thread-safe . [self.queue = [[NSOperationQueue alloc] init].. } . Apple has begun encouraging developers to move toward a more operation-centric rather than thread-centric architecture for multitasking. An operation is an encapsulated unit of work. }  .}. but using NSOperation. NSThread can be a good fit. __block typeof(self) myself = self.label.. In this example. often expressed in the form of an Objective-C block.m (SimpleOperation) .completionBlock = ^{[myself addNextOperation]. iOS provides more powerful tools such as operations and dispatch queues that are discussed in the next sections. but the same approach works for much more time-consuming operations.(void)viewDidLoad { [super viewDidLoad]. To simplify creation.  Developing Operation-Centric Multitasking With the many things expected from modern applications. you can quickly generate enough threads to crash your program and even cause the device to become unresponsive for a while. NSOperation *op = [NSBlockOperation blockOperationWithBlock:^{ [NSThread sleepForTimeInterval:1].. }]. you create the same timer program as before. }]. the actual work is trivial (sleep a second and update a counter).182 Part III: The Right Tool for the Job use NSAssert. Again. count]. If you just call performSelectorInBackground:. For simple threading needs. Blocks are more fully covered in Chapter 16.(void)addNextOperation { __block typeof(self) myself = self. The bolded statements are discussed in more detail following the code. It makes it easy to create producer-consumer queues. myself.text = [NSString stringWithFormat:@”%d”. For more complex problems.
For example. If you reference self.suspended = YES.(NSUInteger)count { return count_. This is likely to improve. Note that the count accessors again need to be thread-safe because operations may access them from any thread.queue = nil. The changes are bolded. which is an NSOperationQueue that runs on the main thread. iOS devices currently do not have many cores. The typeof shorthand just makes it easier to paste this extra line when needed.queue.(void)viewDidUnload { self. Operations are also not fully as integrated into GCD queues on iOS as they are in OS X. If you reference an object inside of a block.m (SimpleGCD) . In this example. Notice how the GCD calls almost exactly match the NSOperation calls. double delayInSeconds = 1. a retain loop is created because self retains queue. This is such a common retain loop that the compiler gives you a warning if you do this accidentally. which means it's shared with the block. GCD has added powerful I/O handling routines that make it even more potent.Chapter 9: Controlling Multitasking 183 // Thread-safe . you would create an operation for every row. Much of GCD is very similar to NSOperation. but this is a useful way to add delays with operations. The extra variable myself breaks this loop because it is marked as __block scope. [self setLabel:nil]. or perhaps several rows. The completion block is useful for handling all kinds of cleanup.0. you use a completion block to schedule another operation. and you should expect NSOperation to grow as the preferred multitasking API in Cocoa. you implement the same timer as in the earlier sections. but not retained by the block..  ViewController. In addNextOperation. so there is only so much parallel work that they can do.. Operations have some overhead compared to Grand Central Dispatch. This is somewhat contrived because you normally would schedule all the operations at once. Generally you shouldn’t generate huge numbers of very small operations. which is discussed in the next section. With iOS 5. which retains the block. Rather than using performSelectorOnMainThread:. Instead.. this example uses the mainQueue. [super viewDidUnload]. } In addNextOperation and setCount: you create a strange variable called myself. dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW. self. you should not generate a separate operation for every pixel in a bitmap. It is used throughout the system layer for nearly everything. however. } . the block automatically retains that object.  Multitasking with Grand Central Dispatch Grand Central Dispatch is at the heart of multitasking in iOS.  .(void)addNextOperation { __block typeof(self) myself = self.
count + 1.text = [NSString stringWithFormat:@”%d”.VC”. not the programmer.(void)viewDidUnload { dispatch_suspend(self.label. DISPATCH_QUEUE_CONCURRENT).(void)viewDidLoad { [super viewDidLoad].queue = nil. count]. self. . [super viewDidUnload]. } . As long as all access to the resource is performed through the queue. [self addNextOperation]. The time is in nanoseconds.count = 0. With some thought. }). __block typeof(self) myself = self. ^{ myself. } One small change from NSOperation is that GCD offers dispatch_after.(void)setCount:(NSUInteger)count { count_ = count. Passing the time in seconds would require floating point math. Using nanoseconds is optimized for the hardware. [self setLabel:nil]. For instance.  . If that sounds like an exclusive (write) lock. Luckily. dispatch_release(self.count = myself. dispatch_async(dispatch_get_main_queue(). ^(void){ myself. While it is running.queue.184 Part III: The Right Tool for the Job delayInSeconds * NSEC_PER_SEC). self.robnapier. this provides very cheap synchronization. no other block on the queue is allowed to run. dispatch_after(popTime.. } . which can lead to some confusion because nearly every time interval in iOS is in seconds. A dispatch barrier creates a synchronization point within a concurrent queue. [self addNextOperation]. Nonbarrier blocks can be thought of as shared (read) locks.queue = dispatch_queue_create(“net. } .SimpleGCD.queue). even if there are other cores available. self.queue).  Creating Synchronization Points with Dispatch Barriers GCD offers a rich system of serial and concurrent queues. you can use these to create many things other than simple thread management. it is. which is more expensive and less precise. GCD queues can be used to solve many common locking problems at a fraction of the overhead. }). GCD is a very low-level framework and does not waste many cycles on programmer convenience. allowing you to schedule the next operation rather than sleeping. Xcode automatically provides a conversion snippet if you type dispatch_after and press Enter. self..
Most are either complicated and fast. } } This is simple to use. } } . DISPATCH_QUEUE_PRIORITY_ HIGH. based on the number of cores available and system load. dispatch_sync(self..  Queue Targets and Priority Queues are hierarchical in GCD. GCD queues are FIFO. so this is much faster than using a mutex. or . This prevents writer starvation. ^{ obj = [self.(void)insertObject:(id)obj atIndex:(NSUInteger)index { @synchronized(self) { [self. In the writer.array insertObject:obj atIndex:index]. created by calling dispatch_queue_create with the DISPATCH_QUEUE_CONCURRENT option. The BACKGROUND queue was added in iOS 5 and is the lowest-possible priority. the write runs alone._DEFAULT. In the reader (objectAtIndex:).(id)objectAtIndex:(NSUInteger)index { @synchronized(self) { return [self. or simple and slow. All of these queues are concurrent.(id)objectAtIndex:(NSUInteger)index { __block id obj. the writer returns quickly.concurrentQueue. and so on. and ensures that immediately reading after a write always yields the correct result. GCD schedules as many blocks as there are threads available from the HIGH queue.array insertObject:obj atIndex:index]._LOW. }). and only then are requests that were placed on the queue after the write processed. You can access these queues with dispatch_get_global_queue and a priority constant. . but very expensive even when there is little contention. ^{ [self.array objectAtIndex:index]. The system creates and destroys threads as needed. } All that is required is a concurrentQueue property. you use dispatch_barrier_async to ensure exclusive access to the queue while writing. GCD barriers offer a nice trade-off. so any requests on the queue before the write are completed first. which takes an exclusive lock on its parameter. . you could manage multithreaded access with @synchronize. return obj. as shown in the following code.array objectAtIndex:index].. There are many other approaches. })...concurrentQueue. . you use dispatch_sync to wait for it to complete. Only the global system queues are actually scheduled to run.. } ._BACKGROUND. it moves on to the DEFAULT queue.. The queue can process as many reads in parallel as it has cores available. but any future reads on the same thread are guaranteed to return the value the writer set. . By making the call asynchronous.Chapter 9: Controlling Multitasking 185 For comparison. Creating and dispatching blocks in GCD has very little overhead. When the HIGH queue is empty.(void)insertObject:(id)obj atIndex:(NSUInteger)index { dispatch_barrier_async(self.  .
This can sometimes be a useful and extremely fast way to pass information in and out of a  . DISPATCH_QUEUE_SERIAL). and there is no way to change its order relative to other blocks on the queue. DISPATCH_QUEUE_SERIAL). it’s executed. but even if the low priority block is next in line for the CPU. high). a high priority queue and a low priority queue. There is no way to cancel it. Once a block is added to a queue. Dispatching to the low priority queue is normal: dispatch_async(low. dispatch_queue_t high = dispatch_queue_create(“high”. it is attached to the DEFAULT queue. You can change the target queue with dispatch_set_target_queue. Suspending a queue prevents scheduling any blocks that were initially put on that queue. By default. This chapter won’t go into them deeply. To dispatch to the high priority queue. It won’t stop currently executing blocks. suspend the low queue and resume it after the high priority block finishes: dispatch_suspend(low).186 Part III: The Right Tool for the Job When you create your own queue. as well as any queues that target the suspended queue.  New in iOS 5 iOS 5 adds several GCD features that are particularly useful for high-performance operations. queue-specific data allows you to attach a piece of data directly to a queue. ^{ /* Low priority block */ }). create two queues. it won’t be scheduled until dispatch_resume is called. and generally you should rely on the OS to handle these things for you. it runs in the order it was added. If the queue is suspended multiple times. it is attached to one of these global queues (its target). When a block reaches the front of your queue. it requires an equal number of resumes. You need to balance dispatch_suspend and dispatch_resume exactly like retain and release. the block is effectively moved to the end of its target queue. ^{ /* High priority block */ dispatch_resume(low). dispatch_async(high. But what if you want a high-priority block to “skip to the head of the line?” As shown in the following code. but it’s useful to know they’re available. dispatch_set_target_queue(low. These are mostly applicable to the operating system itself. }). When it reaches the front of the global queue.  Queue-Specific Data Much like associative references discussed in Chapter 3. dispatch_queue_t low = dispatch_queue_create(“low”. You should expect these technologies to become more central in later versions of iOS. and make the high priority queue the target of the low priority queue.
dispatch_sync(queue.. and you will likely never need to use it directly. as demonstrated here. CFStringRef *value = CFStringCreate.. and particularly on the Mac. (void*)value. rather than a string or other identifier.Chapter 9: Controlling Multitasking 187 queue. ^{ CFStringRef *string = dispatch_get_specific(&kMyKey). static char kMyKey. However. One nice thing about queue-specific data is that they respect queue hierarchies.. discussed in the next section. It’s difficult to use this with Objective-C objects under ARC. improving memory usage. Like associative references. dispatch_queue_get_specific automatically checks the target queue. which promises significant I/O performance improvements on multicore iOS devices. dispatch_queue_set_specific(queue. These types of problems are very common for the OS... In this example. (dispatch_function_t)CFRelease). then that queue’s target queue. and you’ve found that memory allocation or disk access are your major bottlenecks. Dispatch data are blocks of noncontiguous. Buffers can also be incrementally released as they are processed. You may want to start looking at it now if your application needs to process very large amounts of data very quickly. My recommendation is to leave this technology alone while it finishes maturing and Apple works out the best patterns for using it. Apps will need to do more operations in parallel to leverage multicore hardware and provide the best experience for users. and on up the chain. queue-specific data uses a unique address as its key.  Dispatch Data Dispatch data is the foundation of one of the most powerful low-level performance advances in iOS 5. but operation queues and Grand Central Dispatch are more effective and promise greater performance with  . . this is free. So if the current queue doesn’t have the given key assigned. This is combined with dispatch data. This is usually achieved by passing the address of a static char. See the “Further Reading” section for links to more information. value is released automatically when the queue is destroyed or if another value is set for kMyKey. &kMyKey. immutable memory buffers that can be very quickly joined and split up between blocks with minimal copying. .  Summary The future of iOS development is multitasking. and is the basis for a feature called dispatch I/O. you will get most of the benefit for free by using the higher-level abstractions without taking on the complexity of using dispatch I/O directly.. in most cases. Traditional threading techniques are still useful. but Core Foundation objects are a bit easier to use. queue-specific data does not know how to retain and release. to allow extremely high-performance data passing that reduces memory copying and allocation/deallocation churn. }). Unlike associative references. You have to pass it a destructor function that it calls when the value is replaced. This is an incredibly robust system. For memory you’ve allocated with malloc.. but less common at the application layer.
Learning to manage your internal multitasking. many of his blog posts are still required reading. “LockingAPIs.” The section “Processing a File Using GCD” includes example code explaining dispatch I/O channels.com/index.com.pl?LockingAPIs  . “Techniques for Reading and Writing Files.com/pyblog/ ◾ Friday Q&A 2010-01-01: NSRunLoop Internals ◾ Friday Q&A 2009-07-10: Type Specifiers in C.cocoadev.apple. “Session 320: Adopting Multitasking in Your App” WWDC 2011. Threading Programming Guide  WWDC Sessions The following session videos are available at developer. and Thread Safety CocoaDev. iOS Application Programming Guide. The Locking APIs page includes links and discussion of the available technologies and tradeoffs. Part 3 ◾ Friday Q&A 2010-07-02: Background Timers ◾ Friday Q&A 2010-12-03: Accessors. http://www. NSBlog. http://mikeash. is a foundational part of today’s iOS development.com or through the Xcode Documentation and API Reference.” CocoaDev collects much of the accumulated wisdom of the Cocoa developer community. “Session 210: Mastering Grand Central Dispatch”  Other Resources Ash. “Executing Code in the Background” File System Programming Guide. Mike Ash is one of the most prolific writers on low-level threading issues out there. and behaving appropriately when multitasking with other applications.apple. While some of this is now dated. WWDC 2011.  Further Reading Apple Documentation The following documents are available in the iOS Developer Library at developer. Mike.188 Part III: The Right Tool for the Job less contention and less locking. Memory Management.
In addition to discussing the REST implementation on iOS. this chapter provides some guidelines for the server that will help you achieve the following goals: ■ Improve the code quality ■ Reduce development time ■ Improve code readability and maintainability ■ Increase the perceived performance of the app  The Worldwide Web Consortium has identified two major classes of web services. The ideas and techniques presented here are generic enough to be applied easily on any of the projects you might undertake. It’s 2011. you don’t have to know anything about web services or the Twitter REST API. If you have been an iPhone developer for at least a year. foursquare. such as to-do lists. You would have been introduced to the server developer and probably had some control over negotiating the output format and error handling stuff. and a quick search for Twitter in Apple’s App Store turns up nearly 650 iPad apps and more than 3. This chapter focuses on consuming a RESTful service in your application.000 iPhone apps. including but not limited to Twitter APIs. and web server communication might be short-lived (or even optional) for the application. In most cases. Apps that fall into this category are those that sync data with a remote server when a connection is present. Hence.Chapter 10  REST for the Weary  Most iOS applications have to communicate with a remote web server in one way or another at some point. Another set of apps needs nearly continuous network connectivity to provide any meaningful value to the user. rather than explaining how to build your next Twitter client. Web services used in 2011 are mostly RESTful. you might already have implemented a project like this. Caching data offline or synchronizing data with a remote server is discussed in Chapter 17. simple. foursquare. and Dropbox. this chapter provides some insights and best practices for designing your next iPhone app that consumes a generic. Today. (W3C Web Services Architecture 2004): RESTful services that manipulate XML representation of web resources using a uniform set of stateless operations. where your customer sends you a REST documentation of his server APIs. if you want to create the next Twitter client. Gowalla. and arbitrary services that might expose any operation. There are more than a dozen implementations of the Twitter API in Objective-C. Twitter clients. and most apps you write fall into this category. Some apps can run and be useful without a network connection. both the client and the server code would have been developed in tandem. SOAP and WSDL fall under the second category.  . The same is true for most public services like Facebook’s Graph API and Dropbox. These are typically apps that act as a mobile client for a web service. and hypothetical web service. This chapter presents some techniques for writing apps the right way for consuming a web service.
Resource identification on a RESTful server is done through URLs. Response from a RESTful server is usually sent in a uniform. For example. a REST server accepts it as a part of the URL.  Choosing Your Data Exchange Format Web services traditionally support two major kinds of data exchange format: JSON (JavaScript Object Notation) and XML (eXtensible Markup Language). The most commonly handled methods are parserDidStartDocument: parserDidEndDocument:  . As of today. allows clients to cache responses based on the URL. as an iOS developer you should be able to handle both kinds of data format on your app. Microsoft pioneered XML as the default data exchange format for its SOAP services. a DOM parser or a SAX parser. which includes but is not limited to caching responses and login access tokens. while JSON became an open standard described in RFC 4627. For example. just as a browser caches web pages. http://example. A SAX parser is a sequential parser and returns parsed data on a callback as it steps through the XML document. The following sections discuss some of the most commonly used toolkits. usually to decouple the client/server interface.190 Part III: The Right Tool for the Job  The REST Philosophy The three most important features of a RESTful server that an iOS developer should know about are its statelessness. the NSXMLParser foundation class has a method called initWithContentsOfURL:. There are several parsers available for both XML and JSON for Objective-C. and cacheability. This means every API is treated as a new request and no client context is remembered on the server. This method of resource identification. Parsed data becomes available through callback via delegate methods defined in NSXMLParserDelegate. You essentially initialize a parser object with the URL and the NSXMLParser does the rest.  Parsing XML on iOS XML parsing can be done using two kinds of parsers. Most SAX parsers work by taking in a URL as a parameter and giving you data as it becomes available. While there are debates over which is superior. uniform resource identification.com/resources/1234. the most commonly used formats are XML and JSON. (id)initWithContentsOfURL:(NSURL *)url.com/ resource?id=1234 becomes http://example. The next section discusses the differences among the formats and the ways you can parse them in your app. The client iOS app communicates with a RESTful server through this agreed-upon data exchange format. agreed-upon format. For example. along with the fact that a RESTful server doesn’t maintain the state of the client. A RESTful server is always stateless. instead of accepting a resource ID as a parameter. Clients do maintain the state of the server.
and NSDictionary to convert to and from JSON. (See the “Further Reading” section for the links to download these frameworks. This tends to make your code base a bit more verbose compared to a DOM parser. With iOS 5. there are many other alternatives to choose from. These performance gains make a lot of sense when you are parsing XML from your resource bundle.  . To convert a JSON response from your web service into a foundation class object (either a NSArray or a NSDictionary).  Parsing JSON on iOS The second data exchange format is JSON. loads the complete XML before it starts parsing. Apple introduced NSJSONSerialization that can be used for parsing if your app is iOS 5 only. use the extension method on NSString. JSONKit has convenience category extensions for NSString. you need a subclass of NSXMLParser for every object you are handling. on the other hand. The code samples in this chapter use JSONKit. The most commonly used frameworks by far are SBJson.) Almost all frameworks have category extensions on NSString. Any performance gain you get is negligible compared to the time of the network operation. YAJL. and NSDictionary. A web service response generally is less than that. A DOM parser. The most commonly used methods in NSXMLDocument are (id)initWithContentsOfURL:(NSURL *)url options:(NSUInteger)mask error:(NSError **)error initWithData:options:error: initWithXMLString:options:error: Once you initialize the NSXMLDocument you can access the contents using NSXMLNode and NSXMLElement methods like nodesForXPath:error: Using a DOM parser makes your code cleaner and easier to read. it was a private API in iOS 4 and Snow Leopard and was not available for general use. NSArray. TouchJSON. To learn more about XML performance. The advantage of using a DOM parser is its capability to access data at random using XPath queries and there is no delegation like in the SAX model. as in the following sample code fragment. However. While this comes at the expense of execution time for handling web service requests. NSArray. which is much more commonly used than XML. and JSONKit. the effect is minor because DOM parsers become slower only for documents larger than a megabyte or so.Chapter 10: REST for the Weary 191 parser:didStartElement:namespaceURI: qualifiedName:attributes: parser:didEndElement:namespaceURI:qualifiedName: parser:foundCharacters: Because the parser uses delegation to return data. While Apple has a JSON processing framework. You learn about NSJSONSerialization later in this chapter. download and test the XML Performance app published by Apple (see the “Further Reading” section at the end of this chapter).
See the “Further Reading” section for the link to this tool.) Because all five (SBJson. swapping a JSON library shouldn’t require monumental refactoring since in most cases it involves changing the class category extension methods. NSJSONSerialization also lacks the capability to serialize custom objects. JSONKit has a couple of convenient methods that accomplish this: serialize UnsupportedClassesUsingDelegate:selector:error: and serializeUnsupportedClasses UsingBlock:error:. YAJL. namely SBJson. // … fill in other parameters NSString *jsonString = [postDict JSONString].  . choosing JSON is a wise decision. these are the only two methods you will ever need while handling JSON. JSONKit. In short. but you should use this framework only if you are willing to support only iOS 5. The following code explains how to serialize a Foundation object (NSDictionary in this case) to a JSON string for sending it to the server as a post data. and YAJL. [postDict setObject:@”abcde12345” forKey:@”emp_id”]. every library is equally good and there is no one best library as of this date. Usually. If your server code is not yet developed. Apple’s classes are fast compared to other frameworks. whatever library you use. JSON processing on iOS is an order of magnitude easier than XML. Note that the other frameworks. TouchJSON. NSMutableDictionary *postDict = [NSMutableDictionary dictionary]. have equivalent implementations.  XML Versus JSON Source code fragments in this chapter are based on using JSON.  When you are choosing a library for your app. So if your server supports both XML and JSON formats. In most cases. Similarly. Apple introduced its own JSON parsing and serializing framework. You will learn how to design your classes to make it easy to add XML support without affecting the rest of the code base. something JSONKit can do. If your JSON parsing needs unsupported class handling. converting your Foundation objects into JSON strings is also straightforward. you might have to do some performance evaluation. [postDict setObject:@”theAccessToken” forKey:@”access_token”]. Keep a close eye on them and be ready to swap frameworks if one seems superior to another.  NSJSONSerializer In iOS 5. called NSJSONSerialization. you will not be able to use NSJSONSerialization. JSON processing is almost always much simpler than XML. and NSJSONSerialization) are actively developed. TouchJSON. (You can compare the frameworks using the open source test project json-benchmarks on Github. start by supporting JSON initially. The category methods mutableObjectFromJSONString and JSONString defined in the JSONKit come in very handy when processing JSON on iOS. In every case.192 Part III: The Right Tool for the Job NSMutableDictionary *responseDict = [responseString mutableObjectFromJSONString].
As such. As an iOS developer you probably do mostly projects that talk to an arbitrary web service instead of a known. You see this in detail a little later in this chapter. we describe a hypothetical app concept and develop the iOS code for it. it wasn’t really necessary to handle versioning in your models. most client/ server development happened in tandem with a web-based interface. This means the JSON you see on the response is just a different representation of the objects (or object list) on the server. Ruby. In short.  . it makes more sense to think in terms of objects. This could take days or months. You learn more about this shortly. at least from the late 1990s or early 2000s until the first iPhone was launched in 2007. you should probably build support for catering to those business needs. Scala. When you do that. Keep this concept in mind while writing your code. Internally. Design and develop your code such that you always reconstruct model objects for every object on the server. Rather than thinking in terms of JSON strings. As an iOS developer. These objects in turn become the model objects for your app. While that’s true to some extent. nearly every such popular service has an open source implementation for iOS. Refactoring will be far easier.Chapter 10: REST for the Weary 193 Designing the Data Exchange Format It’s essential to keep in mind that we are talking about data exchange between client and server. every server is coded using some object-oriented programming language. think of JSON as a data exchange format instead of a language with a bunch of syntax. Let’s call them model objects and these objects are serialized to JSON only at the transport level. The most common mistake iOS developers make is to think of JSON as some arbitrary data sent by the server in response to an API call. The client app running on the web browser is always deployed together with the server.  Model Versioning In the past. and you look at how to convert JSON dictionaries into models by using Objective-C’s key-value coding/observing (KVC/KVO) mechanism. a quick look at what happens on the server will give you a better picture of what JSON actually is. publicly available service like Twitter or Facebook or Flickr. you need not worry about changes affecting your code later. Most object-oriented languages provide interfaces to serialize objects and developers usually harness this to convert their objects to JSON. When the reconstructed objects on your iOS app match 100 percent with the objects on the server. How many older versions of the client you want to support depends on your business goals. Second. on iOS. as we delve deeper into the topic for each chapter. deploying the client requires that the app be physically installed on your user’s device. any data you need on your iOS app will likely be an object on the server as well. Whether the object is an ORM (object relational mapping)-mapped entity or a business object is of little importance. Consider documenting the data exchange contracts on an object basis rather than as primitive data types. Native clients were not commonly used. and you will probably create model objects for every equivalent server model object. However. the goal of data exchange is attained and your app will be error free. so you should also handle situations when the server is accessed with an older client. Using class clusters on your iOS app is one way to do that. Whether it’s Java.  A Hypothetical Web Service From here on. or C# (even PHP and Python support objects to some extent).
◾ Both these endpoints returns an access token. This is very critical to the performance of your app. Customers can also directly place orders using the kiosks (a dedicated iPad running your app) on their tables. In all cases the server will exchange an access token for a given authentication information. Customers should be able to see the menu. and the other is based on customer table numbers. While there are other requirements for this app. Customers should be able to submit reviews of an item. Here’s a brief description of the toplevel functionalities of the app: 1. This is clearly bad from a user experience point. ◾ In the iOS implementation you will learn how to map the JSON keys to your model object with as little code as possible by making use of Objective-C’s most powerful technique. You learn about this later in this chapter.194 Part III: The Right Tool for the Job Assume that you are in charge of developing an iPhone app for a restaurant. You will see how to post reviews in the background without showing a modal HUD. The important point is that you should develop one code base that caters to both types of login. Additionally. One is the traditional username/password-based type. ◾ This requirement translates to a web service /menuitems endpoint and a /menuitem/<itemid> that returns a JSON object that will be modeled as a MenuItem object. 3. you have to kill the thread. every web service requires you to send an access token with every subsequent call you make. along with the details of every menu item including the photos/videos of the food and ratings left by other customers. ◾ In these cases. you will not be able to control the number of network calls in your app. whereas waiters pick a table number along with every order they send through their own login accounts. key-value coding (KVC). Another reason is that to cancel a synchronous request running on a background thread. ◾ This requirement translates to a web service endpoint /menuitem/<itemid>/review. After logging in. The restaurant uses iPads to take orders.  . In the iOS client implementation you will learn how to “remember” this access token and send it along with every request.  Important Reminders Keep these essential points in mind as you build your app: ■ Never make a synchronous network call—Even if they are on a background thread. synchronous calls do not report progress. which is again not a good idea. So it’s clear that there are two kinds of login/authentication mechanisms. Customer orders are sent to the remote servers based on the customers’ table numbers. these three cover the most commonly used patterns when talking to a web service. Orders can be placed directly with waiters who enter it into their iPads. some iOS apps show a floating heads-up display (commonly known as HUD) that prevents users from doing any operation until the review is posted. ◾ This requirement translates to the /loginwaiter and /logintable web service endpoints. 2.
My advice here is to avoid thirdparty code that is heavily interdependent. Another important feature it provides is an NSOperationQueue encapsulation. More importantly. The code sample provided in the download files for this chapter uses ASIHTTPRequest. ASIHTTPRequest encapsulates many oftenused features like basic or digest authentication. Now let’s get started with choosing a network management framework. Moreover. for making asynchronous requests. Rather than reinvent what’s already available for the development of web services. there are some components and frameworks that are worth using. which you can use to queue network requests and control the number of concurrent operations. ■ Use NSOperationQueue or GCD-based threading instead—NSOperationQueue helps with controlling the queue length and the number of concurrent network operations. which you can use to queue network requests. You can add just the necessary classes from the framework into your app (as opposed to other libraries where you have to link your app against the complete library). ASIHTTPRequest Documentation 2011 in the “Further Reading” section at the end of this chapter). it provides an NSOperationQueue encapsulation. message formats for form posts. as explained above. In our case. When you are developing a REST client in your app. You can find the code for this in the Chapter 10 folder (iHotelApp) on the book’s website. it also provides a layer of isolation (which is also good for unit testing). for the development of web services I recommend using ASIHTTPRequest. ASIHTTPRequest is a nice wrapper that doesn’t bloat your code base while providing very powerful features.  NSURLConnection versus Third-Party Frameworks Apple provides classes in CFNetwork. However. you need to customize those classes by subclassing them. such as NSURLConnection. you should isolate the REST calls to their own class.  RESTEngine Architecture (iHotelApp Sample Code) iOS apps traditionally use model-view-controller (MVC) as the primary design pattern. and helps in keeping your controller code cleaner. Later in this chapter you learn the benefits of using a NSOperationQueue. and uploading or downloading files. for developing RESTful services. ASIHTTPRequest encapsulates many often-used features like basic or digest authentication. and uploading or downloading files. However. The stateless nature of REST and its cachable nature can be best applied when it’s written in its own class. rather than reinvent what’s already available. Let’s start designing the iOS app’s web service architecture.  My advice is generally to refrain from using third-party code when you’re developing for iOS.framework.Chapter 10: REST for the Weary 195 ■ Avoid using runloop-based threading directly for network operations (unless your project is small and has just a couple of API calls)—Running your own threads has some caveats.  . I recommend using ASIHTTPRequest (see the entry for Copsey. form posts.
Adding Authentication to the RESTEngine Now that the class is ready. which is explained in the “Tips to Improve Performance on iOS” section later in this chapter. Create a property of type ASINetworkQueue in this RESTEngine and initialize it inside the initialization method. Create a RESTEngine and add it to your project.196 Part III: The Right Tool for the Job Note that the code download for this chapter is quite vast. so simply assume that you exchange an access token with the server by sending the username and password to the /loginwaiter  . Setting this number correctly has a huge performance impact. authentication. For a demo implementation. @synthesize networkQueue. @property (nonatomic.) Now what should happen when there is a back end-related error? Communicating errors from RESTEngine to the view controller will be covered in the subsequent section. NTLM Authentication. This class will also manage the network operation queue. retain) ASINetworkQueue *networkQueue. you will add methods to handle web service calls. but not limited to. ASIHTTPRequest provides wrapper methods for a variety of authentication schemes including.  Creating the RESTEngine The RESTEngine is the heart of the iHotelApp. and so on. 2. refer to this chapter’s source code on the book’s website.  The networkQueue Initialization in RESTEngine. The chapter provides important code snippets. 1. The following are the first two important steps that need to be done. Open the project in Xcode to better understand the code and the architecture. For using ASINetworkQueue you should add the ASIHTTPRequest framework into your project. This class encapsulates every call to the web service standalone class. Data should be passed from RESTEngine to view controllers only as Model objects instead of JSON or NSDictionary objects. You will set the maximum number of concurrent operation count to 6. The RESTEngine mocks calls to the API by reading them out of sample JSON files because the API is not set up.m @synthesize delegate. HTTP Basic Authentication. (The process of creating model classes is discussed in the next section.h @interface RESTEngine : NSObject {} + (RESTEngine*) sharedInstance. and you should look at the corresponding files. HTTP Digest Authentication scheme.  The networkQueue Initialization in RESTEngine. I won’t go through the details of the authentication mechanisms in this chapter. This shouldn’t affect the architecture of the code. first and foremost. Refer to the “Further Reading” section at the end of this chapter for a link to information about how to integrate ASIHTTPRequest with your project. which handles your network calls.
example. [self.networkQueue = [ASINetworkQueue queue]. [request setDidFinishSelector:@selector(loginDone:)].networkQueue go]. @synthesize sessionKey. ASIFormDataRequest *request = [ASIFormDataRequest requestWithURL:[NSURL URLWithString:LOGIN_URL]]. [self.networkQueue addOperation:request].h @property (nonatomic. Now you should notify the caller.networkQueue setDelegate:self]. (which is usually the view controller) about the outcome of the web service call. BASE_URL. You need to define macros for these URL endpoints. -(id) initWithLoginName:(NSString*) loginName password:(NSString*) password. retain) NSString *sessionKey. You will use delegates for this.networkQueue setMaxConcurrentOperationCount:6]. initWithLoginName:password:.  . return self. … … -(id) initWithLoginName:(NSString*) loginName password:(NSString*) password { self. [request setUsername:loginName]. [request setDelegate:self]. [self. Add the following code to the RESTEngine class header file:  The Constants in RESTEngine. @”/ loginwaiter”] Next.m @synthesize networkQueue.  The init Method (and Property Declaration) in RESTEngine. } That completes your web service call.com” #define LOGIN_URL [NSString stringWithFormat:@”%@%@”. [self. [request setDidFailSelector:@selector(loginFailed:)]. create a property in RESTEngine to hold the access token and then create a new method. as in the following code:  The init Method (and Property Declaration) in RESTEngine.h #define BASE_URL @”http://api. [request setPassword:password].Chapter 10: REST for the Weary 197 request or to the /logintable request.
In that chapter.  Login Request Handling in RESTEngine. one for notifying a successful call and another for error notification. self. arguably cleaner way to notify the caller is by using blocks.  Code showing the delegate in RESTEngine. 1...  .198 Part III: The Right Tool for the Job Adding Delegates to the RESTEngine For every web service call this RESTEngine class exposes two delegate methods. as discussed in Chapter 16.m + (id)delegate { return _delegate. Use the following code to add a delegate definition to your RESTEngine class:  Code showing the delegate in RESTEngine. Usually this delegate is implemented by the view controller that calls the methods in the RESTEngine.(void)loginDone:(ASIHTTPRequest *)request { NSDictionary *responseDict = [[request responseString] mutableObjectFromJSONString]. Now change the loginDone and loginFailed methods to call this delegate. Blocks have their own advantages and drawbacks. Because the delegate is marked optional in the delegate declaration.accessToken = [responseDict objectForKey:@”accessToken”]. you should check if the delegate responds to it before sending the message. -(void) loginFailedWithError:(NSError*) error. //DELEGATES +(id)delegate. you modify this RESTEngine to return data and errors using blocks. +(void)setDelegate:(id)newDelegate. } + (void)setDelegate:(id)newDelegate { _delegate = newDelegate.  Another.m . . which also covers when to use blocks and when to use delegates. } 2.h @protocol RESTEngineDelegate <NSObject> @optional -(void) loginSucceeded:(NSString*) accessToken. @end .
Storing it in keychain is more secure than NSUserDefaults. If your access token is simply a string. Choose one based on your security requirements. } -(void) loginSucceeded:(NSString*) accessToken { NSLog(@”Login is successful and this is the access token %@”. } -(void) loginFailedWithError:(NSError*) error { NSLog(@”Login failed.(void)loginFailed:(ASIHTTPRequest *)request { self. you can call the initialize method from the view controller (which is usually the login page that shows the user name and password fields):  Login Button Event Handling in iHotelAppViewController. Error is :%@”. [error localizedDescription]). 4. } Thus. with just a few lines of code. } 3. you can store it in keychain or in NSUserDefaults.Chapter 10: REST for the Weary 199 if([_delegate respondsToSelector:@selector(loginSucceeded:)]) [_delegate performSelector:@selector(loginSucceeded:) withObject:self.accessToken = nil. } . you are able to implement the login functionality of the web service. [_accessToken retain]. Remember the access token. Now that the RESTEgine class implementation is complete. } return [[_accessToken retain] autorelease]. The easiest and probably the cleanest way to do this is to remove the synthesize method for accessToken and write it manually like this:  Access Token Custom Accessor in RESTEngine. }  . if([_delegate respondsToSelector:@selector(loginFailedWithError:)]) [_delegate performSelector:@selector(loginFailedWithError:) withObject:[request error]].m -(NSString*) accessToken { if(!_accessToken) { _accessToken = [[NSUserDefaults standardUserDefaults] stringForKey :kAccessTokenDefaultsKey].m -(IBAction) loginButtonTapped:(id) sender { [[RESTEngine sharedInstance] initWithLoginName:@”mugunth” password:@”abracadabra”]. Check your password. accessToken]. accessToken).
you create a new method called prepareRequestWithURLString:. Note that this factory method can also have additional parameters set depending on your web service requirements. [[NSUserDefaults standardUserDefaults] setObject:self. } If you need a request object from any other method. Instead of sending the access token in every method.m . It returns an ASIFormDataRequest for a given URL. return request. If your web server sends user profile information at login. Should your web service require  . if(self. [[NSUserDefaults standardUserDefaults] synchronize]. _accessToken = [aAccessToken retain]. You look at caching in Chapter 17. This is omitted here for the sake of clarity. a cleaner way is to write a factory method in your RestEngine that creates a request object. In the following example. every call after login is probably protected and can be accessed only by passing the access token.accessToken) [request setPostValue:self. }  When you write a custom accessor. Whew! That completes your first endpoint. but you are not done yet! Next you create a second endpoint. Get the full source code from the book’s website.  Authenticating Your API Calls with Access Tokens In most web services.200 Part III: The Right Tool for the Job -(void) setAccessToken:(NSString *) aAccessToken { [_accessToken release]. You will never again have a buggy API call where you accidentally forgot to set the access token. which is used to download a list of menu items from the server. you can call this factory method. /menuitems. ensure that the method sends KVO notifications by sending willChangeValueForKey and didChangeValueForKey messages.accessToken forKey:@”AccessToken”]. you might need a bit more sophisticated mechanism to cache the data.accessToken forKey:kAccessTokenDefaultsKey]. Did I mention that the entire method is going to be under five lines long?  Preparing a URL Request Using a Factory Method in RESTEngine.(ASIFormDataRequest*) prepareRequestForURLString:(NSString*) urlString { ASIFormDataRequest *request = [ASIFormDataRequest requestWithURL:[NSURL URLWithString:urlString]]. This request object can then be filled with parameters specific to the call.
com/food_image1. Canceling a running request speeds up the execution waiting time for the request submitted by the next view. Your view controller code remains clean of any unnecessary strings/dictionaries. [self. “name”: “Teriyaki Bento”.m -(ASIFormDataRequest*) fetchMenuItems { ASIFormDataRequest *request = [self prepareRequestForURLString:MENU_ ITEMS_URL]. To enable this behavior. In this case.Chapter 10: REST for the Weary 201 you to turn on gzip encoding for all calls. In this case.  . the profile view submits a request to fetch the user’s profile. this is the method to add them. the response is not used.networkQueue addOperation:request]. but to every web service apps you develop. the response from server for this is a list of menu items. To ensure that it plays nicely with others. “image”: “http://d1. and your subsequent views’ requests get executed faster. or need you to send the application version number and the devicerelated information. For example. Assume that the JSON returned by the server is of the following format: { “menuitems” : [{ “id”: “JAP122”. but the user has already navigated to the Mayorship view without viewing the profile.  Canceling Requests View controllers that need to display the information from your web service call methods like fetchMenuItems: on the RestEngine. every method that is written on your RestEngine class should return the request object back to the view controller. return request.  Request Responses When you call the fetchMenuItems: method. a simple string. tapping the Back button means that even if the request returns. [request setDidFailSelector:@selector(menuFetchFailed:)]. this factory method is the best place to add it. it is the responsibility of the view controller to cancel any request it creates when the user navigates out of the view. } If your method accepts post parameters. Canceling the profile fetch request naturally speeds up the Mayorship fetch request by freeing up the bandwidth.myhotel. you create a model class. This is applicable not just to foursquare.jpg”. the response was an access token. so you didn’t need to design a model. A good example of this scenario from the foursquare app is the user tapping on a profile view and then tapping on the Mayorships button. Canceling the request at this point means that other requests queued in the RESTEngine get a chance to run. [request setDidFinishSelector:@selector(menuFetchDone:)]. It’s now the responsibility of the profile view to cancel its request. Now add a method to your RESTEngine class for fetching menu items from the server:  Method to Fetch the List of Menu Items in RESTEngine. In the last web service call example.
you need to learn a bit about the model class inheritance architecture. extract the JSON dictionary of every menuitem. NSMutableDictionary *responseDict = [[request responseString] mutableObjectFromJSONString]. In this case. and use KVO to convert them into model objects. much more elegant way is to piggyback on Objective-C’s arguably most important feature: key-value coding. NSMutableArray *menuItems = [responseDict objectForKey:@”menuitems”]. including Apple’s NSJSONSerialization) discussed earlier. you can iterate through them.h @interface JSONModel : NSObject <NSCopying. Any web service-based app includes more than one model.h should look similar to the following. you get a dictionary with two entries. implement NSCopying and NSMutableCopying in this base class.  Because you will be making copies and/or mutable copies of your model classes. Derived classes must override this base class implementation and provide their own deep copy methods. a count of ten models for a single app is not uncommon.202 Part III: The Right Tool for the Job “spicyLevel”: “rating” : 4. you write a base class that does the bulk of KVC and delegates very little work to the subclasses. “status” and “menuitems”. @end  . “description” sit”. : 4  One easy way to create a model from a JSON is to write verbose code to fill in your model class with the JSON. converts a JSON-formatted string into a NSMutableDictionary (or a NSMutableArray). add a method called initWithDictionary: to the base class.  Key Coding JSONs Before you start writing your first model class. To start. Instead of writing the KVC code in ten different classes. In fact. I come back to the “status” entry in the “Error Handling” section later in this chapter.  JSONModel. Call this base class JSONModel. The JSONKit classes (or any other JSON parsing framework. This process is covered in the next section. The call shown in the following code can extract the menu items dictionary from the response. The other. “waitingTime” “reviewCount” }] 2. Any model class in the app that models a JSON and needs JSON observing will inherit from this JSONModel. NSMutableCopying> { } -(id) initWithDictionary:(NSMutableDictionary*) jsonDictionary. Now that you have an array of menu items. : “Teriyaki Bento is one of the best lorem ipsum dolor : “930”. Your JSONModel.
@property (nonatomic. “spicyLevel”: 2.h @interface MenuItem : @property (nonatomic. “name”: “Teriyaki Bento”. setDescription. you have “mapped” the JSON into your model class. *rating. “reviewCount” : 4 When you pass this dictionary to the setValuesForKeysWithDictionary: method. setRating. @property (nonatomic.myhotel. “rating” : 4.jpg”. *name. There are some exception cases to be handled.h model class should look like the following:  MenuItem. “description” : “Teriyaki Bento is one of the best lorem ipsum dolor sit”. you should understand how the method setValuesForKeysWithDictionary: works.m -(id) initWithDictionary:(NSMutableDictionary*) jsonObject { if((self = [super init])) { [self init]. JSONModel strong) NSString strong) NSString strong) NSString strong) NSString strong) NSString strong) NSString strong) NSString *itemId. The easiest way to implement this is to use the Objective-C’s built-in @property and @synthesize. and setReviewCount. “image”: “http://d1. it sends the following messages along with their corresponding values: setId. @property (nonatomic. Your MenuItem dictionary looks like this: “id”: “JAP122”. [self setValuesForKeysWithDictionary:jsonObject]. But will everything work automatically when you have a derived class? Isn’t there a catch here? Before going into details. setName. } return self. “waitingTime” : “930”. *itemDescription. and sets its value to the value of that entry. setSpicyLevel. setWaitingTime. so your MenuItem.com/food_image1. @property (nonatomic. if self is a derived class. setImage. *waitingTime. So a class modeling this JSON should implement these methods. @property (nonatomic. *image. it automatically matches the derived class properties and sets their values. *spicyLevel. Voilá! With just one line of code. @property (nonatomic.Chapter 10: REST for the Weary 203 Then implement the initWithDictionary: method:  JSONModel. Most importantly. } The important part of this procedure is the method setValuesForKeysWithDictionary: This method is a part of Objective-C KVC that matches each property in the class that has the same name as a key in the dictionary.  . which are covered shortly.
strong) NSString *reviewCount.m should look like this now:  MenuItem. you should handle these exception cases because the default implementation of the setValuesForKeysWithDictionary: method crashes with a familiar error message stating. itemDescription. rating. That’s because id is a reserved keyword and description is a method in NSObject that prints out the address of the object. add the handlers for the fetchMenuItems method to convert the JSON to model objects:  .m @synthesize @synthesize @synthesize @synthesize @synthesize @synthesize @synthesize @synthesize itemId.  Note that the property names for id and description have been changed to itemId and item Description.(void)setValue:(id)value forUndefinedKey:(NSString *)key NSLog(@”Undefined Key: %@”. Your MenuItem. In fact. image. reviewCount.m . JSONModel. else [super setValue:value forKey:key]. if([key isEqualToString:@”description”]) self. @end  MenuItem. KVC provides a method called setValue:forUndefinedKey:. key).(void)setValue:(id)value forUndefinedKey:(NSString *)key { if([key isEqualToString:@”id”]) self.itemId = value. “This class is not key value coding-compliant for the key:id. name. However. spicyLevel.204 Part III: The Right Tool for the Job @property (nonatomic. waitingTime. } To avoid crashes in the future because of spurious keys in JSON. To avoid conflicts you have to rename them.m. it is the default implementation of this method that raises the NSUndefinedKeyException. Override this method in your derived class and set the values accordingly. and be a bit more defensive in your programming style.itemDescription = value.” To handle this case. like this: . you could override this setValue:forUndefinedKey: method in the base class. } {  Now in your RESTEngine.
To improve performance and reduce payload size.Chapter 10: REST for the Weary 205 RESTEngine.(void)menuFetchFailed:(ASIHTTPRequest *)request { if([_delegate respondsToSelector:@selector(loginFailedWithError:)]) [_delegate performSelector:@selector(loginFailedWithError:) withObject:[request error]]. } . One is a large payload format that contains all information about the object. Just override methods in NSCopying and NSMutableCopying and you are done.)  List Versus Detail JSON Objects A JSON object is a payload that gets transferred from the server to the client. For the example in this chapter. you see NSLog statements displaying the wrong undefined key on the console. It’s also a good idea to add methods for performing deep copy to the derived class. Tools like Accessorizer available from the Mac App Store can help you with that. photos.(void)menuFetchDone:(ASIHTTPRequest *)request { NSMutableArray *responseArray = [[request responseString] mutableObjectFromJSONString]. and most of the other content. You get either a complete JSON. NSMutableArray *menuItems = [NSMutableArray array]. the server can send the small payload JSON for /menuitems. For example. On the implementation side. (See the “Further Reading” section for a link to the app. the iOS app doesn’t have to be changed for mapping two kinds of JSON. including images. a minimal amount of information about the menu item will be displayed on the listing page. In short. you have successfully mapped a JSON dictionary to your custom model and this model is clean of any JSON key strings! That’s the power of KVC.  . The detailed payload will contain exactly the same data plus the first page of reviews and links to the photos of the dishes and so on. and reviews. for(NSMutableDictionary *menuItemDict in responseArray) [menuItems addObject:[[[MenuItem alloc] initWithDictionary:menuItem Dict] autorelease]]. if([_delegate respondsToSelector:@selector(menuFetchSucceeded:)]) [_delegate performSelector:@selector(menuFetchSucceeded:) withObject:menuItems]. The code is also inherently defensive. and a detailed payload for /menuitems/<menuitemid>. } As you see. you call the MenuItem init method with a JSON dictionary to initialize itself from the dictionary keys. will be displayed on the detail page. This technique goes a long way toward improving an iOS app’s perceived performance. the second is a small payload that contains information that is needed just to display the information on a list. it’s common for server developers to use two kinds of payload for the same object. or a JSON that fills your object partially. The code written to map the detailed JSON should work without any modification in this scenario. in the sense that whenever there is a change in JSON keys that the server sends (probably rising from a bug on server side). by overriding a method only for special cases.m . and you can probably notify the server developers or make changes to your client to support the new keys.
myhotel. just assume that the detailed listing of a menu item has only one additional piece of information. “status” : “OK” } This code is very similar to what you already saw. “rating” : 4. “spicyLevel”: 2. which is the array of reviews.” and so on. every menu item is going to have an array of reviews left by the user. “name”: “Teriyaki Bento”. “reviews”: [{ “id”: “rev1”. “rating”: “5” }] }]. (nonatomic. there might be multiple such additions. Your review JSON doesn’t have any special keys that might be in conflict with Objective-C’s reserved list.206 Part III: The Right Tool for the Job  Nested JSON Objects In the example. strong) strong) strong) strong) strong) NSString NSString NSString NSString NSString *rating. But for the sake of simplicity.jpg”. “description” : “Teriyaki Bento is one of the best lorem ipsum dolor sit”. But what you actually want is to map that dictionary as well in a recursive fashion. (nonatomic.com/food_image1. In a real-life scenario. “reviewerName”: “Awesome Man”. and declare an NSMutableArray property on your model. “image”: “http://d1. This class’s header file will look similar to the one below. like a list of photos. “reviewedDate”: “10229274633”. *reviewDate. (nonatomic. but has one additional payload: an array of reviews. The implementation contains nothing but synthesizers and overridden NSCopying and NSMutableCopying (deep copy) methods. a list of “likes. If you depend on the default implementation of KVC. the KVC binding will set it to an array of NSMutableDictionary. Now before overriding the setValue:forKey: method. (nonatomic. This case is handled by the overriding the setValue:forKey: method. Assume that the following represents the format of JSON sent by the /menuitems/<itemid> method: { “menuitems” : [{ “id”: “JAP122”.m @property @property @property @property @property (nonatomic. “reviewText”: “This is an awesome place to eat”. you can generate these accessors using tools like Accessorizer. “reviewCount” : 4. *reviewId. *reviewerName. create a model object for a review entry. “waitingTime” : “930”. *reviewText.  Review. so you don’t even have to write any explicit code  .  Again.
Less Is More You might have heard about KVC and KVO. In some cases it’s sent through a special key.Chapter 10: REST for the Weary 207 for converting JSON to a review model. on the Internet from blogs of veteran Objective-C developers explaining how great they are. Most web services send a custom error message along with the 404 notice so that clients can understand what caused  . This is just one example. yet write it in a way that is clear to read and understand. the web server sends an error key with more information about the actual error and no such key is sent for a successful call. you move on to error handling. so that you write as little code as possible. override the setValue:forKey: method in the MenuItem model to convert review dictionaries to Review models:  Custom Handling of KVC’s setValue:forKey: Method in MenuItem. you need specialized error handling for handling your own internal business logic errors. a server might throw errors even when everything is perfectly fine. for instance. Next. That’s the power of KVC. Next. In other cases. } } else [super setValue:value forKey:key]. } The idea behind this code is to handle the reviews key of the JSON in a specialized way and to let the other keys be handled by the default superclass implementation. a missing menu item results in a 404 error. The initialization code is in the base class and the KVC compliant code is generated by the property/synthesizers. like status. This section shows you how to model this on iOS. In fact.m -(void) setValue:(id)value forKey:(NSString *)key { if([key isEqualToString:@”reviews”]) { for(NSMutableDictionary *reviewArrayDict in value) { Review *thisReview = [[[Review alloc] initWithDictionary:reviewArray Dict] autorelease]. you can put these concepts to use in your next app. Now that you have understood them. [self.reviews addObject:thisReview]. You will realize how powerful they are and how easily they allow you to write less code in a more efficient way. and in most cases. The first thing to understand is that not all API errors can be mapped to a custom HTTP error code. In this example. but the user input is wrong.  Error Handling Recall that you saw a key called status in the JSON payload. Every web service has some way to communicate error messages to the client. A website registration web service might throw an error if the user tries to register with an email address that’s already taken.
This subclass will have a property to store the business logic errors thrown from the server. otherwise subclass its parent. including your customer. Otherwise.(void)requestFinished {  . business logic errors in the same manner.m that illustrate request handling for successful conditions and report business logic error if any .restError = [[NSError alloc] initWithDomain:kBusinessErrorDomain code:[[errorDict objectForKey:@”code”] intValue]userInfo:errorDict]. This section shows you how to handle these cases in an elegant fashion. in some cases. As you saw earlier. } else { self. you check for the presence of the “error” JSON key and process it appropriately.m that illustrate error handling -(void) failWithError:(NSError *)theError { NSMutableDictionary *errorDict = [[self responseDictionary] objectForKey:@”error”]. requestFinished:. The first method to override is the failWithError:  Code in RESTRequest. 2. A client implementation should not just report the HTTP error as a error message to the user. please try again later” and no one. In the following steps you subclass ASIHTTPRequest or ASIFormDataRequest to handle custom API errors.208 Part III: The Right Tool for the Job that 404. 1. Override two methods to handle error conditions. } Using this class. Create a subclass of ASIFormDataRequest. as shown in the following code:  Code in RESTRequest. 3. You should handle non-HTTP. not every business logic error can be mapped to an equivalent HTTP error code. } [super failWithError:theError]. is interested in seeing that kind of vague message. the only error you can ever show is “Sorry. If your app needs to make only “form post” kinds of requests. subclass ASIFormDataRequest. if(errorDict == nil) { self.restError = [[NSError alloc] initWithDomain:kRequestErrorDomain code:[theError code] userInfo:[theError userInfo]]. there might be a benign error that is sent along with your response and the server might delegate the responsibility of treating that as an error or normal condition to the client. For handling both these cases you have to override another method. Create an NSError* property called restError in the subclass. ASIHTTPRequest. something bad happened. Moreover. The failWithError method will be called when there is a HTTP error. but also understand the internal business logic error for elegant error reporting and do proper error reporting.
Because this handling is done on a subclass. The view controller implementation will now be as simple as checking whether the error is nil. this is simple and can be handled using the foundation classes and macros. } else { [super requestFinished]. This enables the client to know both the HTTP error (by accessing the RestRequest’s superclass’s error object) and the business layer error. from the local property restError. For server-related errors. the previous implementation just showed the server errors on the UI. Some implementations require you to localize error messages in multiple languages. if(filePath != nil) { errorCodes = [[NSMutableDictionary alloc] initWithContentsOfFile:file Path].restError = [[NSError alloc] initWithDomain:kBusinessErrorDomain code:[[errorDict objectForKey:@”code”] intValue] userInfo:errorDict]. The iOS client can then look into a localized string table and show the correct error for a given code.  RESTError. if it’s not nil. } } Both these methods remember the business logic errors in the restError property of your subclassed request object.  Localization This section is about localizing web service-related error messages and not localizing your app.m + (void) initialize { NSString *fileName = [NSString stringWithFormat:@”Errors_%@”.Chapter 10: REST for the Weary 209 NSMutableDictionary *errorDict = [[self responseDictionary] objectForKey:@”error”]. All it gets is a nicely wrapped NSError object for both kinds of error.  . the class RestEngine doesn’t have to do any additional error handling. I move on to a discussion of localization. With that. For errors generated within the app. [super failWithError:self. Adding internationalization and localization support to your app is explained in detail in Chapter 13. show the message inside the [[request restError] userInfo]. The best way to show localized errors is for the server to return errors in agreed upon codes. if(errorDict) { self.restError]. NSString *filePath = [[NSBundle mainBundle] pathForResource:fileName ofType:@”plist”]. HTTP or business logic. [[NSLocale currentLocale] localeIdentifier]].
This is usually one on EDGE.210 Part III: The Right Tool for the Job } else { // fall back to English for unsupported languages NSString *filePath = [[NSBundle mainBundle] pathForResource:@”Errors_ en_US” ofType:@”plist”]. and for some reason. you initialized the networkQueue to run six concurrent operations because most servers don’t allow more than six parallel HTTP connections from a single IP address. In the “Creating the RESTEngine” section earlier in this chapter. write a method in your category extension to convert an XML tree into a NSMutableDictionary and pass this dictionary to the initWithDictionary: method. As such you can even listen for reachability notifications using the Reachability classes provided by Apple (Apple 2011) and change the queue size dynamically as and when the connectivity changes. Unlike a web-based app. this count of two on 3G and one on EDGE is not absolute and you should test the network of your customer base and use the results accordingly. Trying to implement techniques like prefetching contents for what could be the user’s next page will only slow down your app. Category classes like this provide a very powerful way to extend and add features to your existing implementation without creating any unwanted side effects. this is the best way to handle and show error messages instead of showing the server error from the userInfo dictionary. } } This RESTError class can again by initialized with the error dictionary you get from the server using the KVC technique you learned earlier in this chapter. Running more than six operations will only result in the seventh and subsequent operations timing out.  . at least in 2011. and in most cases it will be connected to a 3G network. Avoid multiple small AJAX-like API calls. The recommended way to do so is to write a category extension on your model that has a method to convert XML to dictionaries. it’s easy to add an additional format parsing to your model. With this current architecture in place. which you previously wrote. On a 3G network. In case your web service provides error codes to you along with error messages. Override NSError’s localizedDescription and localizedRecoverySuggestion methods to provide proper user-readable error methods. In short.  Tips to Improve Performance on iOS The best tip for improving performance for a web service-based app is to avoid sending data that’s not immediately necessary. your client wants to move the server implementation to a Windows-based system and the server now sends you XML data instead of JSON. most network operators throttle the bandwidth and limit the number of outbound connections from a mobile device to two. an iPhone app has very limited bandwidth. Again.  Handling Additional Formats Using Category Classes Assume that you have written and delivered your app. errorCodes = [[NSMutableDictionary alloc] initWithContentsOfFile:file Path].
it's best to avoid these APIs and possibly use or develop a custom API that gives more customized data per call.  Further Reading Apple Documentation The following documents are available in the iOS Developer Library at developer. Mac App Store. it’s safe to assume that you shouldn’t run more than one network operation on an EDGE connection. 2011 http://itunes. NSXMLDocument Class Reference  Other Resources Callahan.org/html/rfc4627 W3C.apple. 07 01. the following tips might help to get the best out of the iOS app you develop. the ultimate showdown 2011 http://www. more than two parallel network operations on a 3G network.com or through the Xcode Documentation and API Reference. Douglas. Apple XMLPerformance Sample Code Apple.com/gb/app/accessorizer/id402866670?mt=12 Cocoanetics. Apple Developer Documentation. Kevin. 2 11. 2006 http://tools. Again. Web Services Architecture. On iOS. You then learned about using queues for handing concurrent requests and how to maximize performance by altering the maximum concurrent operations on the queue-based available network. Reachability. and six on a wi-fi connection. ■ Unlike a browser. KVC.  Summary In this chapter you learned how to architect a iOS application that uses a web service. JSON vs Plist. 2004 http://www.apple.com/2011/03/json-versus-plist-the-ultimateshowdown/ Crockford.w3.org/TR/ws-arch/#relwwwrest  .Chapter 10: REST for the Weary 211 If you have control over the server development. ■ A server that caters to a web-based client should almost always have multiple small web service calls that are usually performed using AJAX.ietf. The chapter also presented the different data exchange formats and ways to parse them in Objective-C.cocoanetics. most carrier networks throttle the number of parallel data connections. RFC 4627. and you learned a very powerful method of processing responses from a RESTful service using Objective-C’s powerful method.
com/json-framework/ Wight.com/gabriel/yajl-objc Johnezang. Jonathan. 2011 https://github. JSON Framework.How To Use. 2011 https://github.com/ASIHTTPRequest/ ASIHTTPRequest . 1 1.com/johnezang/JSONKit mbrugger json-benchmarks on Github https://github. 2011 https://github. Ben. ASIHTTPRequest Documentation.com/TouchCode/TouchJSON Gabriel.212 Part III: The Right Tool for the Job Copsey. JSONKit.github. TouchCode/TouchJSON.com/mbrugger/json-benchmarks/  .com/ASIHTTPRequest/How-to-use#handling_http_ authentication Brautaset. Stig. 1 1. YAJL-ObjC. 2011 http://allseeing-i. 2011 http://stig. 2011 http://allseeing-i.
dives into the numerous security services that iOS offers. readable only by that application. Most modern operating systems employ some kind of privilege separation. When an application is installed. it is not well defined how iTunes will  . Calling stat on another application’s home directory fails. however. so that you can leverage these features to really improve the security of your products. but how to turn it off. OS X. and tmp.Chapter 11  Batten the Hatches with Security Services  iOS is likely the first platform that most developers encounter that employs a true least-privilege security model. and Windows run as either the current user or a superuser. but this is almost always used in a very coarse way. This chapter shows the way around the iOS security model. Similar restrictions prevent your application from reading /var/log while allowing access to /System/Library/Frameworks. Coming from these backgrounds. Attempts to segment this further. While you can create new directories within your sandbox. There is also a simple project called FileExplorer so you can investigate the public parts of the file system. Apple’s approach has been to give developers the least privileges it can and see what software developers are incapable of making with those privileges. have generally led to developer revolt. there are four important top-level directories: your . allowing different processes to run with different permissions. mobile). developers tend to be shocked when encountering the iOS security model. whether with Security Enhanced Linux (SELinux) or Windows User Account Control (UAC). The most common questions about SELinux are not how to best develop for it. Apple is unlikely to change its stance on this. it is given its own home directory in the file system.  Understanding the iOS Sandbox The heart of the iOS security model is the sandbox. and provides the fundamentals you need to really understand Apple’s security documentation. Then Apple provides the least additional privileges that allow the kinds of software it wants for the platform. Library. Rather than ensure maximal flexibility. This can be very restrictive on developers. All applications run as the same user ID (501. but it’s also kept iOS quite stable and free of malware.app bundle. Along the way you’ll gain a deeper understanding of how certificates and encryption work in practice. which can do nearly anything. Documents. Within your sandbox. but also makes it difficult for malicious or poorly written software to read or modify your data. so understanding and dealing with the security model is critical to iOS development. Most applications on Unix. Applications are not separated from each other using standard Unix file permissions. This makes it difficult to share information between applications. because of operating system restrictions. The code for this chapter is available in the online sample code.
there is still only a single delegate (of type id). as the name implies. You can always create subdirectories under Library if you need more organization. only to the device’s network.  Securing Network Communications The greatest risk to most systems is their network communication. When considering the security of the user’s data. you’ll need to copy them elsewhere first. In iOS 5. I recommend keeping everything in one of these top-level directories. This makes it ideal for temporary files. Most iOS network APIs automatically handle HTTPS. and the protocol eliminates many of the easiest attacks. This is still vulnerable to several kinds of attacks. The Library directory stores files that shouldn’t be directly user visible. but is preserved between application upgrades. this includes your Resources directory. even on hostile networks. It’s your responsibility to make sure that the user’s information is safe. so this mostly impacts how the documentation is organized. Everything within it is digitally signed. The most dangerous areas are generally coffee shops. however.app bundle is the package built by Xcode and copied to the device. If you have information that you would rather the user not have access to. The first and easiest solution is to use Hypertext Transfer Protocol Secure (HTTPS) for your network communication. This is weak protection. These files can be made available to the desktop through file sharing if UIFileSharingEnabled is turned on in Info. usually somewhere in Library.214 Part III: The Right Tool for the Job deal with them. The Library/Caches directory is special because it isn’t backed up. In particular. NSURLConnectionDelegate and NSURLConnectionDataDelegate. Users may choose whether to encrypt the iTunes backup with a password. as discussed shortly. because the user can always jailbreak the phone to read any file or the keychain. This is where you should put most things you don’t want copied to the desktop. If there is data that shouldn’t be stored unencrypted on the desktop machine. Your . you can store it in the keychain or in Library/Caches because these are not backed up. iOS security is about protecting the user from attackers. not about protecting the application from the user. Attackers don’t need access to the device. particularly files like word-processing documents or drawings that the user assigns a filename. The Documents directory is where you store user-visible data. turn on HTTPS. The tmp directory is special because it is neither backed up nor preserved between application upgrades. In the simplest deployment. airports.plist. and other public wi-fi networks. If you want to modify files that you install as part of your bundle. Although there are now two protocols. you should store it in the keychain (see the “Using Keychains” section later in this chapter). There is no certain way to prevent the owner of a device from reading data on that device. the informal delegate protocol of NSURLConnection has been replaced with two formal protocols. you put a self-signed certificate on the web server. but it’s easy to deploy and addresses the most basic attacks.  . backups are an important consideration. so you can’t modify it. iTunes only backs up the keychain if backup encryption is enabled. and configure NSURLConnection to accept untrusted certificates.
the entity you’re communicating with must have the private key. There is no real difference between key A and key B. HTTPS connections always require a credential object. discussed later. This is an important property that is used repeatedly in public key systems.serverTrust. This section gives a quick overview of the technology. encrypts it with your public key and sends it back to you. nor can key B decrypt things that key B encrypted. That entity decrypts the message with the entity’s private key. and vice versa. and connection:didCancelAuthenticationChallenge—there is now just one: connection:willSendRequestForAuthenticationChallenge:. and creates a credential object for it. to provide the credentials. NSURLCredential *cred. If you want to prove that some entity (person or machine) has the private key. Each can only decrypt the other’s ciphertext.  .  ASIHTTPRequest. connection:didReceive AuthenticationChallenge. you make up a random number. In this method. one is termed the public key. covered in Chapter 10. which generally everyone is allowed to know. even if you are not passing credentials to the server. Instead of three methods— connection:canAuthenticateAgainstProtectionSpace. Key A cannot decrypt things that key A encrypted. encrypt it with the entity’s public key and send it. Asymmetric cryptography is based on the mathematical fact that you can find two very large numbers (call them A and B) that are related in such a way that anything encrypted with one can be decrypted with the other.sender useCredential:cred forAuthenticationChallenge:challenge]. and the other is designated the private key. and if so. can support untrusted certificates without requiring you to implement delegate methods. whether or not the certificate is valid or trusted: . You can configure the request as follows: [request setValidatesSecureCertificate:NO].Chapter 11: Batten the Hatches with Security Services 215 The major NSURLConnection change in iOS 5 is to the authentication methods. but for the purposes of public key cryptography. which is secret.  How Certificates Work Hopefully you have encountered public-private key infrastructure (PKI) systems before. Because only the private key could have decrypted the message. The following code authenticates to any server that presents a noncorrupt certificate. The “Checking Certificate Validity” section later in this chapter explains how to more carefully validate the certificate. [challenge. and then discusses how it affects the security of your application. } This code extracts the trust object.(void)connection:(NSURLConnection *)connection willSendRequestForAuthenticationChallenge: (NSURLAuthenticationChallenge *)challenge { SecTrustRef trust = challenge. you are supposed to determine if you are willing to authenticate to this server. cred = [NSURLCredential credentialForTrust:trust].protectionSpace. You can use a public key to encrypt data such that only a computer with the private key can decrypt it.
An example of a certificate chain is shown in Figure 11-1. the server daw. but how well all of the private keys in the chain are protected. signed by an intermediate certificate from VeriSign. you can determine that the controllers of each of these certificates did sign the next certificate in the chain. then that’s more secure than a certificate that VeriSign issues you. and whether the identity of the owner has been authenticated. you control the root key store in your own application. In very rare cases. you first hash it with some well-known hashing algorithm. Second. along with more than a hundred other trusted root certificates.com. it hardly proves anything.  . In both cases. when people talk about a self-signed certificate. I’m the one who handed you the business card. But you don’t get a commercial certificate to improve the security of your system. and then encrypt it with your private key. You get one for convenience because the commercial certs are already in the root key store. and other providers are bad. If you generate your own self-signed certificate and protect the private key very well. But remember.216 Part III: The Right Tool for the Job This property also allows you to digitally sign data. Mathematically. For cryptographic reasons. which is signed by a root certificate from VeriSign. But the VeriSign root certificate is a self-signed certificate. A certificate is made up of a public key. You can set your own anchors if don’t want to trust Apple’s list. you know the signature was created by some entity that had access to the private key. is a self-signed certificate. there may be multiple signatures on one certificate. by definition. each signing the one below it. and it’s relevant to both questions. Given some data. Just because an entity has access to the private key does not prove he is who he says he is. and compare the hashes. Often. There are two questions you need to ask. Similarly. some metadata about the certificate (more on that later). you’re dependent on protecting your private key. and a collection of signatures from other certificates. why should you believe it? This is where a certificate chain comes in. In this example.apple. To validate the signature. which has signed the Apple certificate. VeriSign spends a lot of money and effort doing that. you hash the data again with the same algorithm. if a server presents you a public key that claims to be for www. how do you know that the public key you have is related to the entity you care about? If I approach you on the street and hand you a business card that says I’m the President of the United States.apple. but in the latter case you also have to worry about VeriSign protecting its private key. This leads to a surprising fact: There is no security reason to purchase a commercial certificate to secure your application’s network protocol to your own server. Explicitly trusted certificates are called anchors.com presents a certificate that includes its own public key. every certificate includes a signature from itself. but protecting two keys is always more risky than protecting just one of them. This isn’t to say that commercial certificates from VeriSign. In most cases. which has signed the intermediate certificate. This brings you to the much-misused term self-signed certificate. The trusted root store is a list of certificates that is treated as explicitly trustworthy. but why would you trust any of them? You trust them because Apple trusts the VeriSign root certificate. The resulting ciphertext is the signature. decrypt the signature using the public key. they mean a certificate that you shouldn’t trust. If they match. and it’s one of the most trusted certificates in the world. Apple ships the VeriSign root certificate in the trusted root store of every iOS device. First. DigiTrust. how well is the private key protected? Anyone with access to the private key can forge a signature with it. there is a short chain of certificates. What’s the difference? It isn’t how many signatures a certificate has in its chain that matters. A certificate that only has this signature is called self-signed. Every root certificate.
it is somewhat more convenient to use it for your application’s network protocol. A corrupt certificate should never be used for anything. A certificate is corrupt if it does not conform to the X. it’s just not more secure. It’s to say that it’s okay to trust only your certificates rather than trusting commercial certificates. This is not to say that it’s okay to trust random certificates (that is.Chapter 11: Batten the Hatches with Security Services 217  Figure 11-1 The certificate chain for daw. turning off certificate validation). and the iOS certificate function generally rejects them automatically. Generating your own certificate and shipping the public key in your application is marginally more secure than using a commercial certificate.apple.  . These are separate attributes that need to be understood individually. The first question is whether a certificate is corrupt.com  Commercial certificates are valuable only for websites visited by browsers or other software you don’t control. or if its signatures are incorrectly computed. and trusted or not. valid or not. If you already have a commercial certificate for your server. Certificates can be corrupt or not.509 data format.
host. The first test of validity is a name match.org and iOS will accept that.204. iOS does not make this easy to manage. The current version (v3) is defined by IETF RFC 5280 (ietf. The most important piece of metadata is the subject. you’re trying to connect to the IP address 72. you should generally reject it. For servers. NSLog(@”Trying to access %@. &result). and the site presents a certificate with a common name www. Similarly. but there are still some cases when it will reject a certificate because of a name mismatch you believe it should accept. CFStringRef subject = SecCertificateCopySubjectSummary(cert).113 does not include the string . You decide to accept any trusted certificate that includes google. The certificate you receive is *. which is encrypted. SecTrustResultType result = kSecTrustResultFatalTrustFailure. is it valid? Certificates contain a great deal of metadata about the public key they contain. Unfortunately. 0).com.google. this is generally the fully qualified domain name (FQDN) such as www. OSStatus status = SecTrustEvaluate(trust.  . you will need to link Security.org? Should you accept that certificate? Most humans would assume that example. but certificates use a simple string match. the certificate is invalid. To compile this example.google.  ConnectionViewController.org.218 Part III: The Right Tool for the Job X.int/ ITU-T).113.com.example. which is a mismatch.” you might be asked for your driver’s license. and it presents a certificate that says www.example. (__bridge id)subject). if (status == errSecSuccess && result == kSecTrustResultRecoverableTrustFailure) { SecCertificateRef cert = SecTrustGetCertificateAtIndex(trust. What if you visit example.org/rfc/rfc5280.example.14.(void)connection:(NSURLConnection *)connection willSendRequestForAuthenticationChallenge: (NSURLAuthenticationChallenge *)challenge { NSURLProtectionSpace *protSpace = challenge. If you walk into a bank and identify yourself as “John Smith.google. Got %@. but it can be done.org.  Checking Certificate Validity Given that a certificate is not corrupt.framework into your project.serverTrust. If the strings don’t match.example. It doesn’t represent anything by itself.14.org and www. if you are visiting a site named www. The public key is just a very large number.”.204.m (Connection) . If you hand over a license that says “Susan Jones. protSpace. Some servers present wild card certificates with subjects like *.org refer to the same server (which may or may not be true). SecTrustRef trust = protSpace.protectionSpace. Unfortunately it’s not always that simple. The string 72. In this example. It’s the metadata that gives that number meaning.example.com in its subject.org.com.509 refers to the data format specification and semantics originally defined by ITU-T (itu.com.badguy.” that would not help in identifying you no matter how authentic the driver’s license.txt).
509 certificate rather than as part of an SSL handshake (that is. break. } CFRelease(subject). If you’re okay with the name you were passed. [challenge. NSURLCredential *cred. &result). result).  . You fetch the subject and determine if it’s “close enough” (in this case. kCFCompareAnchored| kCFCompareBackwards). default: NSAssert(NO. @”Unexpected result from trust evaluation:%d”. You evaluate the trust object (SecTrustEvaluate) and receive a recoverable failure. [challenge. if (range.sender useCredential:cred forAuthenticationChallenge:challenge]. status). cred = [NSURLCredential credentialForTrust:trust]. } } else { // Something was broken NSLog(@”Complete failure with code: %lu”.com”).com).google. you evaluate it while ignoring the hostname). checking if it includes . } break. CFSTR(“. [challenge. case kSecTrustResultProceed: case kSecTrustResultConfirm: case kSecTrustResultUnspecified: { NSLog(@”Successing with result: %lu”. you reevaluate the certificate as a simple X. you are passed a challenge object and extract the trust object.sender cancelAuthenticationChallenge:challenge].sender cancelAuthenticationChallenge:challenge].location != kCFNotFound) { status = RNSecTrustEvaluateAsX509(trust. This is done with a custom function RNSecTrustEvaluateAsX509.google. break.Chapter 11: Batten the Hatches with Security Services 219 CFRange range = CFStringFind(subject. result). result). } if (status == errSecSuccess) { switch (result) { case kSecTrustResultInvalid: case kSecTrustResultDeny: case kSecTrustResultFatalTrustFailure: case kSecTrustResultOtherError: // We’ve tried everything: case kSecTrustResultRecoverableTrustFailure: NSLog(@”Failing due to result: %lu”. } } In this routine.
Building and using OpenSSL on iOS is beyond the scope of this book. } status = SecTrustCreateWithCertificates(certs. which only checks the validity and trust of the certificate itself. CFRelease(certs). CFArrayAppendValue(certs. A certificate may also be invalid because it has expired. index). numberOfCerts. ++index) { SecCertificateRef cert.509 policy.220 Part III: The Right Tool for the Job static OSStatus RNSecTrustEvaluateAsX509(SecTrustRef trust. result). } CFRelease(policy). if (status == errSecSuccess) { status = SecTrustEvaluate(newTrust. index < numberOfCerts. The following private methods allow you to work out the valid range: CFAbsoluteTime SecCertificateNotValidBefore(SecCertificateRef). SecTrustResultType *result ) { OSStatus status = errSecSuccess. while you can reevaluate the certificate using any date you want using SecTrustSetVerifyDate. &newTrust). CFAbsoluteTime SecCertificateNotValidAfter(SecCertificateRef). cert = SecTrustGetCertificateAtIndex(trust. public way to determine the validity dates for the certificate. CFRelease(newTrust). return status. CFIndex numberOfCerts = SecTrustGetCertificateCount(trust). without considering the hostname as the original SSL policy does. The only other practical way to parse the certificate is to export it with SecCertificateCopyData and parse it again using OpenSSL. Unfortunately. and may be rejected by Apple. for (NSUInteger index = 0. cert). policy. there is no easy. SecPolicyRef policy = SecPolicyCreateBasicX509(). } This function creates a new trust object by copying all the certificates from the original trust object created by the URL loading system. these may change at any time. Search the Web for “OpenSSL iOS” for several explanations of how to build this library. This trust object uses the simpler X. &kCFTypeArrayCallBacks). CFMutableArrayRef certs. SecTrustRef newTrust.  .  As with all private methods. certs = CFArrayCreateMutable(NULL.
■ kSecTrustResultInvalid—The validation was unable to complete. For this example. Enter any name you like.  Determining Certificate Trust So far. ■ kSecTrustResultRecoverableTrustFailure—The certificate is invalid. but that doesn’t mean your application needs to trust them. others are more localized like QuoVadis and Vaestorekisterikeskus. if you present your Metallica fan club membership card. set the Certificate Type to SSL Client. Open Keychain Access. Anchor certificates are those certificates that are explicitly trusted by the system. Each of these organizations went through a complex audit process and paid significant amounts of money to be in the root store. 1. set the Identity Type to Self Signed Root. ■ kSecTrustResultFatalTrustFailure—The certificate itself was defective or corrupted. That’s the same situation that an application faces when presented with a certificate signed by an unknown authority. and create the certificate. you create a self-signed root certificate. ■ kSecTrustResultConfirm—The certificate is valid. Select Keychain Access menu → Certificate Assistant → Create a Certificate. but that doesn’t mean it’s trusted. The following results indicate that the certificate should not be accepted: ■ kSecTrustResultDeny—The certificate is valid. you can embed the public key in your application and configure your trust object to accept only that certificate or certificates signed by it. That is the intent of this  . You should never see this error. such as a name mismatch. and the user has not explicitly accepted or rejected it. ■ kSecTrustResultUnspecified—The certificate is valid. 3. If you generate your own certificate. likely because of a bug in your code. Returning to the example of identifying yourself at the bank. expiration. 2. There are several results that represent “good” or “possibly good” certificates: ■ kSecTrustResultProceed—The certificate is valid. a certificate must ultimately be signed by one of the certificates in the trust object’s list of anchor certificates. and the user has explicitly accepted it. Some are global names like VeriSign and DigiTrust. and you should ask the user whether to accept it. iOS ships with more than a hundred of them from companies and government agencies. or lack of trust (such as a self-signed certificate). but in a way that may be acceptable. you’ve learned to determine if a certificate is valid. ■ kSecTrustResultOtherError—The validation was unable to complete. You will receive a warning that this is a self-signed certificate. it probably would not be accepted as identification. and the user has explicitly rejected it. the final result will be a SecTrustResultType. likely because of a bug in Apple’s code.Chapter 11: Batten the Hatches with Security Services 221 After evaluating the trust object. To be trusted. The bank has no reason to believe that your fan club has done a good job making sure you are who you say you are. This gives you greater control over your security and can save you some money. Generally you accept it in this case.
Keychain does not export the private key by default. &kCFTypeArrayCallBacks). Find your certificate and drag it to the desktop to export it. 4.222 Part III: The Right Tool for the Job process. which itself is encrypted using the user’s password or PIN. which is then used to decrypt the files. NSData *certData = [NSData dataWithContentsOfFile:path options:0 error:&error]. the password or personal identification number (PIN) is used to decrypt the per-device key again. CFRelease(certificate). NSString *path = [[NSBundle mainBundle] pathForResource:@”MyCert” ofType:@”cer”]. When the user unlocks the device.000 combinations (far fewer are used in practice). Back in the Keychain Access window. certificate = SecCertificateCreateWithData(NULL. Your newly created certificate will display a warning that “This root certificate is not trusted.” That is also as expected because it is not in the root keychain. 5. convert it into a SecCertificate. SecTrustSetAnchorCertificates(trust. Ten seconds after the device is locked. You load the certificate from your resource bundle into an NSData. SecCertificateRef certificate. and set it as the anchor for the trust object. On an iPhone. and control which certificates you accept or reject. Ltd demonstrated that it could brute-force a 4-digit PIN in about 20–40 minutes. If you would like to accept both. CFArrayRef certs = CFArrayCreate(NULL. The weakest link in this scheme is the user’s password. CFRelease(certs). 1.  Employing File Protection iOS provides hardware-level encryption of files. so you should click Continue. which offers only 10. (const void**)&certificate. You can test that the certificate presented is signed by your certificate as follows: NSError *error. This file includes only the public key. select the login keychain and select the category Certificates. you can correctly respond to any certificate in your connection:willSendRequest ForAuthenticationChallenge: method. In May 2011. Using these techniques. the unencrypted per-device key is removed from memory. Files marked for protection are encrypted using a per-device key. (__bridge CFDataRef)certData). certs). ElcomSoft Co. Drag the public key file into your Xcode project. This doesn’t protect against  . you can use SecTrustSetAnchorCertificatesOnly to reconfigure the trust object. users almost exclusively use a 4-digit PIN. The trust object will now only accept the certificates passed to SecTrustSetAnchorCertificates and will ignore the system’s anchors.
When the device is unlocked..  . The options. and the NSData constants begin with NSDataWritingFileProtection.Chapter 11: Batten the Hatches with Security Services 223 forensics or device theft...CompleteUnlessOpen.. while NSData uses numeric options during creation. ■ .. This allows your application to open existing files while running in the background. [data writeToFile:dataPath options:NSDataWritingFileProtectionComplete error:&writeError]. The files are unprotected from that point until the device is rebooted. these files are unprotected.Complete—Any file with this setting is protected 10 seconds after the device is locked. For a developer. and the setting you should generally use. shown in the following list..None—The file is not protected and can be read or written at any time. it will be protected if the device is locked.. This is the highest level of protection... NSFileManager applies string attributes to the file..CompleteUntilFirstUserAuthentication—Files with this setting are only protected between the time the device boots and the first time the user unlocks the device. which allows you to read as long as it is open when the device locks. ■ .. This is preferable to creating the file and then using NSFileManager to set its protection attribute. the specifics of the iOS encryption scheme aren’t critical. The scheme is effective enough for users to expect it from any application that holds sensitive information. The easiest way to achieve this is like this: [data writeToFile: options: error: [data writeToFile: options: error: path NSDataWritingFileProtectionComplete &error] || path NSDataWritingFileProtectionCompleteUnlessOpen &error]..CompleteUnlessOpen. When the file is closed. You can create open new files using . You can configure the protection of individual files that you create with NSFileManager or NSData. This allows your program to continue accessing the file while running in the background. have slightly different names.. convert it to an NSData and then use writeToFile: options:error:. ■ .. On iPad.CompleteUnlessOpen—Files with this setting are protected 10 seconds after the device is locked unless they are currently open. so the security is similar to file encryption on a laptop... but does protect against attackers who only have access to the device for a few minutes. The FileManager constants begin with NSFileProtection. but the meanings are the same. This is better than the None setting. ■ . To create a protected file in the background. Files with this setting may not be available when your program is running in the background.. This is the default value. you can apply the option . You should generally avoid this unless you’re actually in the background. but should be avoided if at all possible because it provides very limited protection. typing a real password is much more convenient. To create a new file with file protection turned on..
In practice. which is one reason I like it. In this context.  Using Keychains File protection is intended to protect data. key. and identity. ■ Check [[UIApplication sharedApplication] protectedDataAvailable]. Unfortunately. Many problems come from developers trying to use an Internet password. after a brief introduction to the low-level data structures. In most cases. you can use one of the following: ■ Implement the methods applicationProtectedDataWillBecomeUnavailable: and applicationProtectedDataDidBecomeAvailable: in your application delegate. NSDirectoryEnumerator *dirEnum = [fm enumeratorAtPath:dir]. This is what I’ll discuss in this section. Internet password. The keychain is protected by the operating system and is encrypted when the device is locked. the Keychain API is anything but friendly. ■ Observe the notifications UIApplicationProtectedDataWillBecomeUnavailable and UIApplicationProtectedDataDidBecomeAvailable (these constants lack the traditional Notification suffix). but my recommendation is Apple’s KeyChainItemWrapper from the GenericKeychain sample code (2010). if (![[attrs objectForKey: NSFileProtectionKey] isEqual:NSFileProtectionComplete]) { attrs = [NSDictionary dictionaryWithObject: NSFileProtectionComplete forKey:NSFileProtectionKey]. } } } If your application needs to know whether protected data is available or not. An item in the keychain is called a SecItem. The most common secrets are passwords and private keys. a secret is a small piece of data used to access other data. There is no SecItemRef type. but you should still make sure to protect all sensitive information as well as possible. Because it’s so simple and it’s hardware optimized. for (NSString *path in dirEnum) { NSDictionary *attrs = [dirEnum fileAttributes]. For foreground-only applications. Storing private keys and identities is rare in iOS applications  .224 Part III: The Right Tool for the Job If you use this technique. you need to give more careful thought to how to apply file protection. KeyChainItemWrapper only uses generic password items. upgrade your file protection at startup with a routine like this: -(void)upgradeFilesInDirectory:(NSString *)dir error:(NSError **)error { NSFileManager *fm = [NSFileManager defaultManager]. If your application runs in the background. Keychain is intended to protect secrets. you want to use a generic password. which is more complicated and provides little benefit. certificate. [fm setAttributes:attrs ofItemAtPath:path error:error]. There are five classes of SecItem: generic password. it works very similarly to file protection. file protection is very easy. but is stored in a CFDictionary. Many people have written wrappers around the Keychain API. you should generally protect your files unless you have a good reason not to.
For more information on this feature. NSString *username = [wrapper objectForKey:kUsernameKey]. but the best way is to assign your own identifier and search for that.apple.”  Sharing Data with Access Groups The iOS sandbox creates a significant headache for application suites. First. id kUsernameKey = (__bridge id)kSecAttrAccount. id kPasswordKey = (__bridge id)kSecValueData. At the bottom of the summary pane enable Entitlements. If you have multiple applications that work together. KeychainItemWrapper caches reads. Multiple applications can share keychain data as long as they share an access group. Using KeychainItemWrapper. KeychainItemWrapper * wrapper = [[KeychainItemWrapper alloc] initWithIdentifier:@”MyKeychainItem” accessGroup:nil]. there is no easy way to share information among them. The __bridge casts are to allow you to pass Core Foundation constants to a Cocoa method under ARC. This is how KeyChainItemWrapper operates. [wrapper setObject:password forKey:kPasswordKey]. iOS offers a solution to this with access groups. So with that background. There are many pieces of the key to search for. That should be written an encrypted file as described in the section “Employing File Protection.” but for now leave it nil. Of course you can save the data on a server. The keychain is not a place to store sensitive data that changes often. open the target in Xcode. I discuss access groups in the section “Sharing Data with Access Groups. which you can use to store your identifier. but the user still needs to enter credentials for each of your applications.  . Certificates that contain only public keys should generally be stored in files rather than in keychain. Then add a new keychain access group as shown in Figure 11-2. It automatically synchronizes with the keychain. For a generic password item. but not writes. you create one with initWithIdentifier:accessGroup:. service (kSecAttrService).Chapter 11: Batten the Hatches with Security Services 225 and it won’t be discussed in this book. The value is generally the password. Keychain items have several searchable attributes and a single encrypted value. as shown in the following code. Generic password items include an attribute kSecAttrGeneric. see the documentation for SecItemAdd in the Keychain Services Reference (developer.com). To create an access group. and identifier (kSecAttrGeneric). some of the more important attributes are the account (kSecAttrAccount). let’s see how to use KeychainItemWrapper. You can now read from and write to wrapper like you would an NSDictionary. You eventually need to search the keychain for the item you want. Writing to the keychain can be expensive. you can use this access group by passing the identifier to initWith Identifier:accessGroup:. so you shouldn’t do it too often.
SecKeyEncrypt and SecKeyDecrypt handle asymmetric (public/private key) encryption for you. If you have certificates.  Using Encryption Most of the time. iOS handles all your encryption needs for you.226 Part III: The Right Tool for the Job  Figure 11-2 Creating the serversettings access group  Storing small pieces of sensitive information in the keychain is quite simple with KeychainItemWrapper. but limited documentation. Most of it assumes that you have some background in cryptography. Unless you have a very good reason. which is much more complicated. This section covers what you need to use it successfully. But what about simple. It automatically encrypts and decrypts HTTPS for network traffic and manages encrypted files using file protections.  . I recommend using it instead of directly accessing the Keychain API. symmetric encryption using a password? iOS has good support for this. The available documentation is in /usr/include/CommonCrypto.
and it’s hardware optimized on iOS devices. and the final ciphertext are all public information. it converts plaintext into ciphertext. If you try to use a password as an AES key. A key is a very large number. used to encrypt and decrypt data. and the resulting data is your key. Long passwords that include spaces are sometimes called passphrases. shown in the following code:  . you significantly shrink the number of available keys. The best cryptographers in the world have carefully scrutinized it. The answer is a password-based key derivation function.S. the number of iterations. You then iterate through the PBKDF2 function a specific number of times. which is just a large random number. Real users select passwords from a much smaller set of characters. you should always use AES for symmetric encryption. making it extremely fast. you need to preserve the salt and the number of iterations. Worse yet. government as its standard for encryption. or AES. It offers an excellent trade-off of security and performance. All possible keys for an encryption system are called its key space. The important fact here is that the salt. approximately one ten-millionth the size of the full AES key space. but for simplicity I just use the word “password” no matter the construction. is a symmetric encryption algorithm. You need a way to convert a password into a useable key that makes it as hard as possible on the attacker to search every possible password. There are slight differences in the algorithm for each length.  Converting Passwords to Keys with PBKDF2 AES offers three key lengths: 128. but you can also save the number of iterations with the encrypted data. It’s just a large random number. To use PBKDF2. but it’s important to know the names because they show up in the documentation. The same key is used to convert ciphertext back into plaintext. including time performance and battery life performance. The standard recommends at least 64 bits. Specifically. that only creates about a 104-bit key space. you will use PBKDF2. which is defined by RSA Laboratories’ Public-Key Cryptography Standards (PKCS) #5. I recommend AES-128. What is important is that PBKDF2 converts a password into a key. if the user has a password longer than 16 bytes (16 single-byte characters or 8 double-byte characters). To decrypt the data. You can create it with a method like randomDataOfLength:. You don’t need to know the internals of PBKDF2 or PKCS #5. Unless you have very specialized needs. Given a key. Originally named Rijndael. Only the key and the original password are secrets. you need to generate a salt.Chapter 11: Batten the Hatches with Security Services 227  Overview of AES The Advanced Encryption Standard. in 2001 the algorithm was selected by the U. A key is not the same thing as a password. Typically the salt is saved with the encrypted data. The salt is combined with the password to prevent identical passwords from generating identical keys. you will throw away part of it when using AES 128. A password is something a human can type. 192. and 256 bits. It’s a very good algorithm. and the number of iterations is a constant in your source code. Generating the salt is easy. Unless you need another algorithm for compatibility with an existing system. If the user selects a random 16-character password using the 94 characters on a standard keyboard.
The following method accepts a password string and salt data and returns an AES key.000 iterations on a modern MacBook Pro. Luckily it’s easier to use PBKDF2 than it is to explain it. I recommend between 10.000 to 500.000 iterations adds nearly a second to key generation on an iPhone.UTF8String. } . but this has gone up as CPUs have improved. // password password.000 iterations on an iPhone 4 and 50.000 and 100.h> const NSUInteger kAlgorithmKeySize = kCCKeySizeAES128. The only algorithm supported on iOS for this purpose is SHA1.bytes. Originally. The reason for the large number is to slow down brute-force attacks. // passwordLength salt.000 iterations of PBKDF2.228 Part III: The Right Tool for the Job RNCryptManager. so you always pass kCCPRFHmacAlgSHA1 for this parameter. PBKDF2 requires a pseudorandom function (PRF). // salt  . even if the password is very weak. the standard called for 1. // ~80ms on an iPhone 4 + (NSData *)AESKeyForPassword:(NSString *)password salt:(NSData *)salt { NSMutableData * derivedKey = [NSMutableData dataWithLength:kAlgorithmKeySize]. NSAssert(result == 0. return data.mutableBytes). but provides much better protection if the password guessing is done on a desktop. + (NSData *)randomDataOfLength:(size_t)length { NSMutableData *data = [NSMutableData dataWithLength:length]. which is just a function that can generate a very long series of statistically random numbers.length.  RNCryptManager. By requiring 10. Going up to 100. An attacker generally tries passwords rather than raw AES keys because the number of practical passwords is much smaller.m (CryptPic) const NSUInteger kPBKDFSaltSize = 8.. That adds up to 13 minutes of search time for a 4-digit PIN. const NSUInteger kPBKDFRounds = 10000. int result = SecRandomCopyBytes(kSecRandomDefault. The extra 80ms for a single key generation is generally negligible. and months or years to search for even a very simple password.m (CryptPic) #import <CommonCrypto/CommonKeyDerivation. errno).. length. int result = CCKeyDerivationPBKDF(kCCPBKDF2.000 iterations of the PBKDF2 function. @”Unable to generate random bytes: %d”. // algorithm password. data. the attacker must waste about 80ms per attempt on an iPhone 4. NSData *salt = [self randomDataOfLength:kPBKDFSaltSize].
// kPBKDFRounds. so you should always use CBC. // derivedKey. It is extremely uncommon to encounter this situation in iOS. which means that it operates on a fixed-sized block of data. The one case where ECB makes sense is if you are encrypting a large number of small (16 byte or less) random numbers. This is often labeled optional. CBC allows you to define an extra block called the initialization vector (IV) to begin the chain.  ECB is faster than CBC. The IV is very similar to the salt discussed in the section “Converting Passwords to Keys with PBKDF2. AES works on exactly 128 bits (16 bytes) of input at a time.  Performing One-Shot Encryption That’s really all the theory you need.  Selecting the Mode and the Initialization Vector (IV) AES can operate in two modes. Key generation with PBKDF2 was added in iOS 5. In this mode. }  Applying PKCS7 Padding AES is a block cipher. you should always use CBC.Chapter 11: Batten the Hatches with Security Services 229 salt. // saltLen PRF rounds // derivedKey derivedKeyLen  // Do not log password here NSAssert(result == kCCSuccess. PKCS #7 defines a standard way to do this. return derivedKey. Because the data you want to encrypt may not be an exact multiple of 16 bytes. Otherwise. and that leaves your data vulnerable to certain attacks. the resulting ciphertext will still be different. The first block is a special case because there is no previous block.length. derivedKey. @”Unable to create AES key for password: %d”. but you should always provide one. ECB is no less secure than CBC. so you can ignore the implementation details. As with the salt. an all-zero block is used. and you generally request it by passing the kCCOptionPKCS7Padding option.length). Unless you have special requirements. An example of this is using AES to encrypt other AES keys. result). In that one case. the IV is just a random series of bytes that you save with the ciphertext and use during decryption. electronic codebook (ECB) and cipher-block chaining (CBC). which greatly improves overall security. iOS provides all the math functions. it may be necessary to pad the last block with extra data. iv = [self randomDataOfLength:kAlgorithmIVSize].” It ensures that if the same plaintext is encrypted with the same key. each block influences the encryption of the next block. // kCCPRFHmacAlgSHA1.  .mutableBytes. and it is the default in iOS.
const NSUInteger kAlgorithmBlockSize = kCCBlockSizeAES128.bytes. Handle Error .length. // keylength (*iv). // dataOutMoved if (result == kCCSuccess) { cipherData. *salt = [self randomDataOfLength:kPBKDFSaltSize]. // dataOutAvailable &outLength).bytes. // dataIn data. NSAssert(salt.mutableBytes. } else { // .length.m (CryptPic) #import <CommonCrypto/CommonCryptor. These take an NSData and return an NSData.. // key key.bytes. // dataOut cipherData.230 Part III: The Right Tool for the Job The first example is one-shot encryption and decryption routines. cipherData. and a salt. @”IV must not be NULL”).length = outLength.. return nil. // options key. // dataInLength. }  .length. CCCryptorStatus result = CCCrypt(kCCEncrypt. @”salt must not be NULL”). const NSUInteger kPBKDFSaltSize = 8. *iv = [self randomDataOfLength:kAlgorithmIVSize]. and returns ciphertext data. const NSUInteger kAlgorithmKeySize = kCCKeySizeAES128. size_t outLength.  RNCryptManager.// iv data. const NSUInteger kPBKDFRounds = 10000. NSData *key = [self AESKeyForPassword:password salt:*salt].. NSMutableData * cipherData = [NSMutableData dataWithLength:data.length + kAlgorithmBlockSize].. // operation kAlgorithm.h> const CCAlgorithm kAlgorithm = kCCAlgorithmAES128. They use the convenience function CCCrypt from CommonCryptor. // Algorithm kCCOptionPKCS7Padding. const NSUInteger kAlgorithmIVSize = kCCBlockSizeAES128. The encryption routine accepts plaintext data and a password. // ~80ms on an iPhone 4 + (NSData *)encryptedDataForData:(NSData *)data password:(NSString *)password iv:(NSData **)iv salt:(NSData **)salt error:(NSError **)error { NSAssert(iv. an IV.
return nil.” however. size_t outLength.length. As presented in in the section “Performing One-Shot Encryption.length]. } } return decryptedData.bytes.  RNCryptManager. // operation kAlgorithm. CCCryptorStatus result = CCCrypt(kCCDecrypt. it's just one function call.m (CryptPic) + (NSData *)decryptedDataForData:(NSData *)data password:(NSString *)password iv:(NSData *)iv salt:(NSData *)salt error:(NSError **)error { NSData *key = [self AESKeyForPassword:password salt:salt]. It also requires that all the plaintext be available when it gets started.  . } The decryption routine accepts ciphertext data. // dataOutAvailable &outLength). // dataOut decryptedData. a password.// iv data. // dataInLength..length.bytes. decryptedData.length. Handle Error .. } else { if (result != kCCSuccess) { // .Chapter 11: Batten the Hatches with Security Services 231  return cipherData. but once you have your data in place. It has a lot of parameters and you need to generate a key. The IV and salt are the same values returned from the encryption method.bytes. and salt.. NSMutableData * decryptedData = [NSMutableData dataWithLength:data. IV. }  Improving CommonCrypto Performance The CCCrypt function is fairly straightforward. // dataIn data. CCCrypt requires enough memory to hold two copies of your plaintext. // key key. // dataOutMoved if (result == kCCSuccess) { [decryptedData setLength:outLength].mutableBytes. // Algorithm kCCOptionPKCS7Padding. // keylength iv.. // options key.
salt = [self randomDataOfLength:kPBKDFSaltSize].. This still requires that all the plaintext be available in memory at the same time. This routine handles either encrypting or decrypting. default: NSAssert(NO. especially on a mobile device. This is particularly useful in cases when you want to store data on an untrusted server. } break. The dataIn and dataOut parameters can point to the same buffer as long as it’s as large as the ciphertext. and CCCryptorFinal. } break. case kCCDecrypt: // Read the IV and salt from the encrypted file if (! [inStream _CMgetData:&iv maxLength:kAlgorithmIVSize error:error] || ! [inStream _CMgetData:&salt maxLength:kPBKDFSaltSize error:error]) { return NO.  . CCCryptorUpdate. The full source code is available in the CryptPic sample code for this chapter. For AES that’s the size of the plaintext plus one 16-byte block. That can be expensive for large files. In this example. The _CM. It’s easiest to use file protection locally on the device and use AES to protect the file remotely.  RNCryptManager. iv = [self randomDataOfLength:kAlgorithmIVSize]. They’re available in the sample code. HTTPS protects it on the network but that doesn’t help if you don’t trust the server. break. it generates the key from the password and creates the CCCryptor object. it reads or writes the IV and salt at the beginning of the stream. } Next. It also prevents you from decrypting as the data is read from the network. based on the operation parameter (kCCEncrypt or kCCDecrypt). First.m (CryptPic) switch (operation) { case kCCEncrypt: // Generate a random IV for this file. you use these to handle encryption and decryption with NSStream objects.. @”Unknown operation: %d”. operation).Data methods are helpers for dealing with NSStream. This is the object that performs the encryption or decryption. CCCrypt is just a convenience function around the normal CommonCrypto routines: CCCryptorCreate. if (! [outStream _CMwriteData:iv error:error] || ! [outStream _CMwriteData:salt error:error]) { return NO.232 Part III: The Right Tool for the Job You can save half the memory by reusing the buffer in CCCrypt.
Now the routine reads a block of data. CCCryptorGetOutputLength returns the size of the buffer required to process the requested number of bytes. &cryptor). // dataInLength  .length. // cryptor srcBytes. size_t dstLength = 0. // Create the cryptor CCCryptorRef cryptor = NULL. while ((srcLength = [inStream read:srcBytes maxLength:kMaxReadSize]) > 0 ) { result = CCCryptorUpdate(cryptor. There’s no problem with allocating a little too much memory here. If you use padding and call CCCryptorUpdate multiple times. even if there’s an error. kCCOptionPKCS7Padding. The important call is CCCryptorUpdate. encrypts or decrypts it. dstBufferSize = CCCryptorGetOutputLength(cryptor. but there is a bug in CCCryptorUpdate that prevents this (radar://9930555). which are always greater than or equal to the result of CCCryptorGetOutputLength. // input length true). iv. That isn’t a major problem in this case because the buffer size is small. key. NSMutableData * srcData = [NSMutableData dataWithLength:kMaxReadSize].  // // // // // // //  operation algorithim options key keylength IV OUT cryptorRef  Next. According to the documentation. and writes it to the output stream.mutableBytes. you should be able to use a single buffer to manage the plaintext and ciphertext. // cryptor kMaxReadSize.bytes. CCCryptorStatus result. you can’t do “in place” encryption. // dataIn srcLength. it allocates some buffers to use.mutableBytes. process Result:bytes:length:toStream:error: just checks the result and handles the file writing in a way that simplifies error handling. key. Using NSMutableData rather than malloc lets ARC take care of the memory management for you. kAlgorithm. including any extra data that may be needed for the final block.bytes. ssize_t srcLength. result = CCCryptorCreate(operation. This reads data from srcBytes and writes them to dstBytes. // final NSMutableData * dstData = [NSMutableData dataWithLength:dstBufferSize]. It updates dstLength with the number of bytes written. You could also use kMaxReadSize + kAlgorithmBlockSize. uint8_t *dstBytes = dstData.Chapter 11: Batten the Hatches with Security Services 233 NSData *key = [self AESKeyForPassword:password salt:salt]. uint8_t *srcBytes = srcData.
but it’s generally not worth writing special code to avoid it.. // dataOutMoved if (![self processResult:result bytes:dstBytes length:dstLength toStream:outStream error:error]) { CCCryptorRelease(cryptor). If padding was enabled. There is no retain counting on CCCryptor.Release functions. // dataOut dstBufferSize. You would normally wrap it in a method like this one: + (BOOL)encryptFromStream:(NSInputStream *)fromStream toStream:(NSOutputStream *)toStream  . You can use this routine to encrypt and decrypt from any NSStream. and the source is available from http://opensource. dstBytes. or NSData. } } When you’ve read the entire file (srcLength == 0). // dataOutAvailable &dstLength). CCCryptorUpdate only processes data in block-sized units (16 bytes for AES). return NO. if (![self processResult:result bytes:dstBytes length:dstLength toStream:outStream error:error]) { CCCryptorRelease(cryptor). Unlike other .234 Part III: The Right Tool for the Job dstBytes.h. not the iOS tree. dstBufferSize. If you did not enable padding. URLs. which is good security practice for sensitive data structures. // // // // cryptor dataOut dataOutAvailable dataOutMoved  The fact that CCCryptorRelease overwrites the memory with zeros is not documented in CCCommonCryptor. &dstLength). CommonCrypto is open source. then you can skip this step. return NO. Look in the OS X tree. Note the calls to CCCryptorRelease. result = CCCryptorFinal(cryptor. this immediately frees the memory. you need to call CCCryptorFinal to deal with whatever’s left over. but can be verified in the source code. } CCCryptorRelease(cryptor)..com/. return YES. CCCryptorRelease also overwrites the memory with zeros. there may still be some unprocessed data in the CCCryptor. which can handle file paths.apple.
[pictureStream close]. The important thing to remember is that you must compress before you encrypt. [outputStream open].Chapter 11: Batten the Hatches with Security Services 235 password:(NSString *)password error:(NSError **)error { return [self applyOperation:kCCEncrypt fromStream:fromStream toStream:toStream password:password error:error]. Securing your application requires a few extra lines of code. You also learned how to properly validate certificates so that you can ensure your application only communicates with trusted sources. files.  Summary iOS provides a rich collection of security frameworks to make it as easy as possible to secure your users’ data. You can’t compress encrypted data.m (CryptPic) NSInputStream *pictureStream = [NSInputStream inputStreamWithData:data]. that would suggest patterns in the ciphertext. If you could. encrypting and then compressing leads to a larger output than the original plaintext. [pictureStream open]. which would indicate a poor encryption algorithm. [outputStream close]. NSOutputStream * outputStream = [NSOutputStream outputStreamToFileAtPath:encryptedPath append:NO]. but taking care of the basics is generally not difficult using the code provided in this chapter. This chapter showed you how to secure network communications. There is a theoretical security benefit to doing this. but generally it’s just to make the data smaller. BOOL result = [RNCryptManager encryptFromStream:pictureStream toStream:outputStream password:password error:error].  Combining Encryption and Compression It’s sometimes a good idea to compress data before encrypting it.  . and passwords. } You would then use it like this to encrypt an NSData directly to disk. In most cases.  CPCryptController.
Read this book as a fascinating. Fifteen years later.apple.  .com or through the Xcode Documentation and API Reference.apple. 1996.” 1996. The main problem is that after reading it. you may think you can create your own cryptography implementations. issue 49. this is still one of the best introductions to buffer overflows available. WWDC 2010. Phrack vol. Applied Cryptography. “Session 208: Securing iOS Applications”  Other Resources Aleph One. Certificate. “Smashing The Stack For Fun And Profit. Then put it down and use a well-established implementation. introduction to cryptography.org/issues. “Session 204: Creating Secure Applications” WWDC 2011.236 Part III: The Right Tool for the Job  Further Reading Apple Documentation The following documents are available in the iOS Developer Library at developer. You shouldn’t. with examples. Key. www. Bruce. and Trust Services Programming Guide iOS Application Programming Guide. 7.html?issue=49&id=14#article Schneier.com.phrack. Anyone interested in the guts of cryptography should read this book. “The Application Runtime Environment” Secure Coding Guide (/usr/lib/CommonCrypto)  WWDC Sessions The following session videos are available at developer. if dated.
to name a few. multitasking. Every year. Similarly every version of the SDK comes with powerful new features: In App Purchases. Core Data. it’s easier to depend on Cocoa framework APIs to detect capabilities than writing code assuming that a certain sensor would be present on a given hardware. the magnetometer—a sensor used to show the direction of magnetic north (more commonly known as a compass)—debuted in iPhone 3GS. most users (more than 75%)  . The iPad was introduced later with a whole new UI. and these new devices often come with additional sensors.  Developing for Multiple Platforms The iOS debuted with a public SDK in version 2. For that purpose. iPad 2. The GPS sensor debuted with iPhone 3G. and MapKit support in iOS 3. Apple has since been innovating vigorously and in 2010. Who knows what the future might hold—Apple might even announce an SDK for Apple TV development and may even enable running games from Apple TV controlled by your iPhone on iPod touch.0. In 2010. and add methods that check for features that are not readily exposed by the framework. This chapter looks at some strategies that can help you write code that adapts easily to multiple platforms and devices using the various APIs provided by Cocoa framework. and Grand Central Dispatch in iOS 4.Chapter 12  Running on Multiple iPlatforms and iDevices  The iOS SDK was announced to the public in February 2008. Keep in mind. it introduced another bigger brother to the family. iCloud. a far bigger screen than the iPhone. In the course of this chapter. iPad added a couple of cameras (including a front-facing camera) in the second iteration. a new version of the SDK comes out along with at least two or three new device updates. Push Notification Service. you might be interested in providing backward compatibility to users running an older version of the operating system. and version 5. At that time there were only two devices using it: iPhone and iPod touch. and Storyboards in iOS 5. blocks. because the updates are free of charge.0 is the fourth iteration that is available for developers. you must either forget about old users (not a good idea) or write code that adapts to both users (either by supporting an equivalent feature for older users or by prompting them that additional features are available if they run a newer version). One important advantage of iOS over competing platforms is that users don’t have to wait for carriers to “approve” their OS updates and. When you use one of these features. you write a category extension on the UIDevice class. developers should avoid making assumptions about hardware capabilities based on device model strings. but without a camera. As a developer you should know how to write code that easily adapts to any device (known or unknown) and platform. another new device running iOS was introduced: the Apple TV. however. the iPad. In short. Twitter integration. and the gyroscope (for lifelike game play) in iPhone 4. that if you are using a feature available in a newer version of the SDK.
follow these steps: 1. and Methods There are three cases that you need to handle when you support multiple SDKs: frameworks. stick to this default value. That makes life easier for developers.  . You can set the Deployment Target on the same Build Settings tab as the Base SDK setting. Classes.  Configuring the Base SDK Setting The first configurable setting is called Base SDK. it’s usually fine to support just the two latest iterations of the SDK. To cater to a wider audience. it was enough to support iOS 4 and iOS 3. which governs the minimum required OS version necessary for using your app. By default. some frameworks and features might not be available. You can configure this setting by editing your target. select the target and select the Build Settings tab. and methods.  Considerations for Multiple SDK Support: Frameworks.0. It’s your responsibility as a developer to adapt your app to work properly without crashing. On the editor pane. when your app is running on iOS 4 devices. Xcode provides two configurable settings for the target you build. Open your project and select the project file on the project navigator. As an iOS developer. now. new projects created with Xcode always use the latest-available SDK and Apple handles API deprecation. you learn about the ways to make this possible. classes. That is. but still want to support older versions. your Base SDK setting should be set to the latest SDK (or iOS 5) and your Deployment Target should be set to at least iOS 4. For example. if iOS 5 is the latest version. You can change the value to “Latest iOS SDK” or any version of SDK installed on your development machine. it should be enough to support iOS 5 and iOS 4. In the following sections. I recommend providing backward compatibility for at least one previous version of the OS. If you set this to a particular version.238 Part III: The Right Tool for the Job get the latest available OS within a month. you should also support at least iOS 4. 2. say 5. However. but the easiest way to look for a setting in this pane is to search for it in the search bar.  Configurable Target Settings: Base SDK Versus Deployment Target To customize all features your app can use and all devices and OS versions your app can run. When you are using a feature available in iOS 5 SDK. The Base SDK setting instructs the compiler to use that version of SDK to compile and build your app and this means it directly controls which APIs are available for your app. in late 2010 and early 2011. The Base SDK setting is usually the third option here. the AppStore app automatically prevents users running previous operating systems from downloading or installing your app. in late 2011–early 2012. The first is your base SDK setting and the second is the iOS Deployment Target.  Configuring the Deployment Target Setting The second setting is the Deployment Target. Unless you have very specific reasons not to. To do so.
If not. Click the Required combo box and change it to Optional. not all symbols would be available to you on older operating systems. When you use the built-in Twitter framework for sending tweets. An example from iOS 4 is the UILocalNotification class defined in UIKit. Another method to check for class availability is to use the class method instead of NSClassFromString.Chapter 12: Running on Multiple iPlatforms and iDevices 239 Framework Availability Sometimes a new SDK might add a whole new framework. When you use a symbol that’s defined in a framework that is not available on older versions. This means that even if the framework gets linked. This framework is available only to users running iOS 4 and above. You have two choices here. your app will not load. you should check for its presence by instantiating an object using the NSClassFromString method. If you are using this class. An example on iOS 5 is the Twitter. you have to show your own Tweet Composer UIs instead. Either set the deployment target to iOS 4 and build your app only for customers running iOS 4 and above. This framework is linked with every iOS app. missing symbols automatically become null pointers and you can use this null check to enable or disable UI elements. Clearly.  When you link a framework that is present only on a newer version of the SDK. you must weak-link it.Framework. You will see a list of frameworks that are currently linked to your target. you should weak-link it and do a runtime check to see if it is available. all the frameworks are set to Required by default. Then open the Build Phases tab and expand the fourth section (Link Binary With Libraries).  . that class is not present on the target device. but still specify the iOS Deployment target to a SDK older than that.framework. When you weak-link a framework.Framework. This will cause your app to be rejected. To weak-link a framework. which will weak-link a framework.  Class Availability Sometimes a new SDK might add new classes to an existing framework. the second choice is the optimal. To avoid this and to selectively load a framework. If you haven’t yet changed a setting here. which means that a complete framework is not available on older operating systems. your application will fail to launch and crash almost immediately. An example from iOS 5 is the UIStepper control. An example from iOS 4 is the EventKit. If it returns nil. open the target settings page from the project settings editor. or check if the given framework is present on the user’s operating system and hide necessary UI elements that invoke a call to this framework. check for its existence. When you receive a crash report from the Apple review team stating that the app crashes immediately on launch (mostly without any useful crash dumps). so when you are using this class. this is what you have to look for. as shown in the following code.
it can be challenging to remember the availability of every single class and method.240 Part III: The Right Tool for the Job Checking for Availability of the UIStepper Control if ([UIStepper class]) { // Create an instance and add it to the subview } else { // create instance of a equivalent control and add it to subview }  To use the class method. you can use the method you checked for. and Methods Although it should quite easy to remember framework availability. you should equate it to NULL instead. The following code checks for this class.1 or later. use the respondsToSelector: method.  Checking the Availability of Frameworks. Equally difficult is reading through the complete iOS  . Classes. you should use the LLVM Clang compiler and the deployment target should be 3. A classic example from iOS 4 is multitasking support. Implicitly assuming pointers as nil or NULL will not work.  Checking Availability of a C Function if (CFunction != NULL) { CFunction(a).isMultitaskingSupported) { // Code to support multitasking goes here } } To check if a method is available in a given class.  Code for Checking Whether a Method Is Available in a Class if ([[UIDevice currentDevice] respondsToSelector:@selector(isMultitasking Supported)]) { if([UIDevice currentDevice]. new methods are added to an existing class in the new SDK.  Method Availability In some cases. If it returns YES. If the method you are checking is a global C function. }  You have to equate the function name explicitly to NULL. The class UIDevice has a method called isMultiTaskingAvailable. as shown in the following code.
Figure 12-1 is a screenshot from the developer documentation showing how to look for multitasking availability.  Figure 12-1 Multitasking availability in developer documentation  Macros in iOS Header Files The other method for checking the availability of a method or class is to read through the header files. Most newly added methods have either one of the macro decorations shown in Figure 12-2:  Availability Macros UIKIT_CLASS_AVAILABLE __OSX_AVAILABLE_STARTING __OSX_AVAILABLE_BUT_DEPRECATED  Figure 12-2 Multitasking availability in header file  It’s usually easier and faster to check availability of a class or method for a given SDK version from the header file. it probably means that the method was added ages ago to the SDK and you normally don’t have to worry if you are targeting the two most recent SDKs. I recommend two different ways to check the availability of a framework.  .Chapter 12: Running on Multiple iPlatforms and iDevices 241 documentation to learn which method is available and which method is not. class. Just command-click the symbol from your source code and Xcode opens the header file where it’s defined.  Developer Documentation The straightforward way to check the availability of symbols or frameworks is to search in the Availability section of the developer documentation. If it doesn’t. I find this easier than fiddling through the documentation. you have to look at the developer documentation. But not all methods will have this macro decoration. or method.  If a method doesn’t have a macro decoration.
these methods are scattered around on various frameworks. let’s focus on the meat of the chapter: supporting multiple devices. } {  The problem with the preceding code is that the developer has made a broad assumption that only iPhones will ever have microphones. users can add one by connecting an external microphone/ headset. when Apple added external microphone capability to iPod touch. say iPad. For example.  Detecting Device Capabilities The first and most common mistake that developers made in the past. you learn about the subtle differences between the devices and learn the right way to check for availability of a particular feature.2 update. If your code assumes device capabilities based on model name. you should check for the presence of the exact hardware or sensor you need. you also write a category extension class on UIDevice that adds methods and properties for checking features not exposed by the framework. In the next section.  Detecting Hardware and Sensors The first thing to understand is that instead of assuming capabilities. when new devices with new hardware sensors became available.  Detecting Devices and Assuming Capabilities Consider the following code fragment. but it’s not correct and not the right thing to do. after the iPhone OS 2. But soon. This code worked well initially. the initial version of the iPod touch didn’t have a microphone. In parallel. which assumes the capabilities of the iPhone. You should instead use some other method for detecting hardware or sensor availability than assuming devices’ capabilities. instead of assuming that only iPhones have a microphone. was to detect the model name and check if it was an “iPhone. it will still work. [alertView show]. use APIs to check for the presence of a microphone. This worked well for a year or so. Fortunately or unfortunately. however. But with the iOS software 2. when there were only two devices (iPod touch and iPhone).242 Part III: The Right Tool for the Job Now that you know how to support multiple SDK versions. Another problem is that this code shows an error for any new device introduced later. Let's now start looking at various methods for checking device capabilities the right way and grouping them under a UIDevice category class.  .” thereby assuming capabilities. The first advantage of the following code is that it automatically works for new devices to be introduced in the future and for externally connected microphones.  Detecting a Microphone the Wrong Way if(![[UIDevice currentDevice].model isEqualToString:@”iPhone”]) UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@”Error” message:@”Microphone not present” delegate:self cancelButtonTitle:@”Dismiss” otherButtonTitles: nil]. the method became highly error prone.2 software update. the above code prevents users from using the app. For example.
It is actually far easier to use the API. All this means that you should not write code with device-based assumptions. you should also consider detecting input device change notifications. return session. BOOL micAvailable = (isAvailable > 0). In the example above. // update your UI here } . because you added the property listener in viewDidLoad. Next you extend this for other hardware and sensors.  Detecting Camera Types The iPhone shipped with a single camera originally and added a front-facing camera later in iPhone 4. When you add a property listener to a class. That is. With just few extra lines of code. right? Here’s how to do that. the iPad 1 (its bigger brother) doesn’t have one.(BOOL) microphoneAvailable { AVAudioSession *session = [AVAudioSession sharedInstance].Chapter 12: Running on Multiple iPlatforms and iDevices 243 What’s the second advantage? The code is a one-liner. AudioSessionPropertyID inID. While the iPhone 4 has a front-facing camera. AudioSessionAddPropertyListener( kAudioSessionProperty_AudioInputAvailable. The iPod touch had no camera until the fourth generation.  Detecting Whether a Microphone Is Being Plugged In void audioInputPropertyListener(void* inClientData.  . {  AudioSessionPropertyListeners behave much like observing NSNotification events. audioInputPropertyListener. in addition to viewDidAppear. } All you need to do here is to add a property listener for kAudioSessionProperty_AudioInput Available and on the call back check for the value.  Correct Way to Check for Microphone Availability . UInt32 inDataSize. you should remove it in viewDidUnload.inputIsAvailable. while the newer iPad 2 has both a front-facing and a back-facing camera. you are able to write the correct version of device detection code. Sounds cool. nil). } In the case of a microphone.(void)viewDidLoad { [super viewDidLoad]. const void *inData) UInt32 isAvailable = *(UInt32*)inData. it’s your responsibility to remove it at the right time. enable your Record button on the UI when the user plugs in a microphone.
(BOOL) cameraAvailable { return [UIImagePickerController isSourceTypeAvailable: UIImagePickerControllerSourceTypeCamera].244 Part III: The Right Tool for the Job The UIImagePickerController class has class methods to detect source type availability. } This enumerates the available media types for a given camera and determines if it contains kUTTypeMovie. if (![sourceTypes containsObject:(NSString *)kUTTypeMovie]){ return NO. Cameras on iPhone 3GS and above can record videos. } return YES.(BOOL) videoCameraAvailable { UIImagePickerController *picker = [[UIImagePickerController alloc] init]. Similarly. you should be running on iOS 4 and above. #endif } For detecting a front-facing camera. The enumeration UIImage PickerControllerCameraDeviceFront is available only on iOS 4 and above because any device that has a front-facing camera (iPhone 4 and iPad 2) always runs iOS 4 and above.  . NSArray *sourceTypes = [UIImagePickerControlleravailableMediaTypesFor SourceType: UIImagePickerControllerSourceTypeCamera]. you can check if the camera attached has video-recording capabilities. // First call our previous method to check for camera presence.  Checking for a Video-Recording Capable Camera . So you use a macro and return NO if the device runs iOS 3 or below. You can check that using the following code. #else return NO.(BOOL) frontCameraAvailable { #ifdef __IPHONE_4_0 return [UIImagePickerController isCameraDeviceAvailable: UIImagePickerControllerCameraDeviceFront]. if(![self cameraAvailable]) return NO. }  Checking for a Front-Facing Camera .  Checking for Camera Presence .
you will almost always use the user’s photo library.Chapter 12: Running on Multiple iPlatforms and iDevices 245 Detecting Whether a Photo Library Is Empty If you are using a camera. you have to design your app with alternative input methods. In coming years. more and more devices will have this. can measure only force.  Code to Detect the Presence of a Gyroscope . It’s easy to check for camera flash presence using UIImagePickerController’s class method:  Checking for a Camera Flash . By comparison. Just pass UIImagePickerControllerSourceTypePhotoLibrary or UIImagePickerControllerSourceTypeSavedPhotosAlbum for the source type. You learn more about this key later in the chapter. preventing devices without a gyroscope from installing the app. You can check this the same way as you check for camera presence.  . or you can specify them in the UIRequiredDeviceCapablities key in your app’s info. You can detect the presence of a gyroscope using an API provided in the CoreMotion.(BOOL) cameraFlashAvailable { #ifdef __IPHONE_4_0 return [UIImagePickerController isFlashAvailableForCameraDevice: UIImagePickerControllerCameraDeviceRear].  Detecting the Presence of a Camera Flash So far. #endif }  Detecting a Gyroscope The gyroscope is an interesting addition to the iPhone 4. It allows developers to measure relative changes to the physical position of the device. #else return NO.framework. you should ensure that there are photos in it. BOOL gyroAvailable = motionManager.gyroAvailable. the only device to have a camera flash is the iPhone 4.plist.(BOOL) gyroscopeAvailable { #ifdef __IPHONE_4_0 CMMotionManager *motionManager = [[CMMotionManager alloc] init]. it’s possible for game developers to implement 6-axis control like that found in Sony’s PlayStation 3 controller or Nintendo’s Wii controller. Using a gyroscope. Before calling UIImagePicker to show the user’s photo album. #endif }  If a gyroscope is a core feature of your app but your target device doesn’t have a gyroscope. return gyroAvailable. Twisting movements cannot be measured by accelerometer. #else return NO. an accelerometer.
Call the method headingAvailable in CLLocationManager and if it returns true.0f) return YES.  . Unfortunately.scale. else return NO.  Detecting Alert Vibration Capability As of this writing.0. there is no public API for checking if the device is vibration capable. However. you already know that catering to a retina display is as easy as adding an @2x image file for every resource you use in the app. if(scale == 2.  Retina Display Capable . Instead. A good example of this is a photo browser app like. If you are developing a game that vibrates the device to signify danger or a Labyrinth game where you want to vibrate whenever the player hits the wall. they don’t do anything. A compass is more useful in a location-based application and augmented reality-based applications. When your user launches the app in iPhone 4 (the only device with a retina display as of this writing) you should be downloading images of double the resolution you do for non-retina display devices. On devices not capable of vibrating. download higher-resolution files after determining that the device has a retina display. which includes vibration plus beeps while the second is just for vibrations.246 Part III: The Right Tool for the Job Detecting a Compass or Magnetometer Compass availability can be checked using the CoreLocation. UIScreen *screen = [UIScreen mainScreen].  Detecting a Retina Display As an iOS developer. But in cases where you download the image from a remote server. a Flickr viewer or Instagram.framework class CLLocationManager.(BOOL) retinaDisplayCapable { int scale = 1. AudioServicesPlayAlertSound(kSystemSoundID_Vibrate). if Apple introduces an external retina display (maybe the newer Apple Cinema Displays) and allows the current generation iPads to project to it in retina mode.framework has methods (shown below) to selectively vibrate only iPhones. The first method is for alerting the user. AudioServicesPlaySystemSound(kSystemSoundID_Vibrate). if([screen respondsToSelector:@selector(scale)]) scale = screen. but that is a waste of bandwidth and might even be slower to download over EDGE. you should download images at twice the resolution on devices with retina display. only iPhones are capable of vibrating to alert the user. Some developers choose to ignore this and download higher resolution images for all devices. This way. } With this code you look for the mainScreen of the device and check if the device is capable of showing highresolution retina display-capable graphics. you can use compass in your app. The second method just vibrates the iPhone. The first method vibrates the iPhone and plays a beep sound on iPod touch. you should use the second method. your app will still work without changes. say. the AudioToolbox. Checking for this is easy.
. Although MFMessageViewController and MFMailComposeViewController are available from iOS 4. and even if your app’s minimum deployment target is set to iOS 4.Chapter 12: Running on Multiple iPlatforms and iDevices 247 Detecting Remote Control Capability iOS apps can handle remote control events generated by buttons pressed on the external headset. The UIApplication class’s canOpenURL: method is handy for checking if a device has an app that can handle URLs of a specific type. tel: URLs are handled by the phone app on iPhone. For example. The same method can also be used to check if a specific app that can handle a given URL is installed on a device. not every device can send emails or SMSs.(BOOL) canMakePhoneCalls { return [[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:@”tel://”]]. }  A word about usability: Developers should completely hide features specific to phones on iPod touch devices. Implement the following method in your firstResponder: remoteControlReceivedWithEvent: Be sure to turn this off when you no longer need the events by calling [[UIApplication sharedApplication] endReceivingRemoteControlEvents]. use the following method to start receiving notifications: [[UIApplication sharedApplication] beginReceivingRemoteControlEvents]. Do not simply disable it (because nothing can be done by the user to enable it) or show an error alert. There have been cases where showing a “Not an iPhone” error on an iPod touch leads to rejection of the app by the app review team. if you are developing a Yellow Pages app that lists phone numbers from the Internet. To handle this. you still need to know and understand the common pitfalls when using these classes.  Detecting Phone Call Capability You can check if a device can make phone calls by checking if it can open URLs of type tel:. show the button to place a call only on devices that are capable of making phone calls.  Phone Call Capabilities .  In App Email and SMS While In App email and In App SMS are technically not sensors or hardware. This includes iPhones as well—even those that run iOS 4 and above.
Both MFMessageComposeViewController (for In App SMS) and MFMailComposeViewController (for In App email) have class methods canSendText and canSendMail. an iOS device with no configured email accounts cannot send email.  .m. even when it’s technically capable of sending one. If it returns YES.  Checking Multitasking Awareness Checking if a device can multitask is straightforward.  Is Multitasking Available? if ([[UIDevice currentDevice] respondsToSelector: @selector(isMultitaskingSupported)]) { if([UIDevice currentDevice]. An iPhone that doesn’t have a SIM card cannot send text messages.  Obtaining the UIDevice+Additions Category The code fragments you've seen so far in this chapter are available as a UIDevice category addition. It has just two files: UIDevice+Additions. you can write multitasking-related code. You should be aware of this and always check for capabilities before attempting to use this feature.248 Part III: The Right Tool for the Job For example. as shown in the following code. Checking for this capability is easy. respectively. You can download that from the book’s website. your application delegate will not receive the following callbacks. you should remember your app’s state and continue when the app is launched again.h and UIDevice+Additions. the teardown code (including your Core Data-managed context save methods) that you write in applicationDidEnterBackground: should be written in applicationWillTerminate: as well. The same applies to SMS/MMS. On devices that don’t support multitasking. As you saw earlier in this chapter. Similarly. But don’t worry. you have to check if the method isMultitaskingSupported is available.isMultitaskingSupported) // Code to support multitasking goes here } }  {  But there is something more. that can be used. – applicationDidEnterBackground: – applicationWillEnterForeground: This means that any part of your startup code and initialization sequence you write in application WillEnterForeground: should be written in applicationDidFinishLaunchingWithOptions: as well for nonmultitasking capable devices. Otherwise. they are dynamically loaded so they don’t bloat your app. You have to link necessary frameworks to avoid those pesky linker errors because this class links to various Apple library frameworks.
In this case. you need something more than just checking for device capabilities and hiding specific parts of your app. The following values are supported for this key: telephony. front-facing-camera. camera-flash. gamekit. accelerometer. video-camera. Alternatively. opengles-2. armv7. That is. auto-focuscamera.0. gps. your app depends solely on the presence of particular hardware and without that hardware your app will be unusable. wifi.  Summary This chapter discussed various techniques and tricks to help run your app on multiple platforms. Finally. The converse is allowed. You incrementally wrote a category extension on UIDevice that could be used for detecting most device capabilities.  . still-camera. Examples include a camera app like Instagram or Camera+. users cannot even download the app on their iPod touch or iPad. Adding values to the UIRequiredDeviceCapablities key will prohibit your app from being installed on devices without the capabilities you requested. sms. My recommendation is to depend on the methods explained in this chapter and use the UIRequiredDeviceCapablities key sparingly. Apple provides a way to ensure this using the UIRequiredDeviceCapablities key in the Info plist file. armv6. however. you can mandate the presence of video-camera by setting the video-camera key to YES. you can allow installations on it in a subsequent version. location-services. For example. you learned about the UIRequiredDeviceCapablities key and how to completely exclude devices without a required capability. Put another way. It also looked at the various hardware and sensors available for iOS developers and how to detect their presence the right way.Chapter 12: Running on Multiple iPlatforms and iDevices 249  UIRequiredDeviceCapabilities So far. if you have been excluding a device previously. magnetometer. peer-peer. opengles-1. In other words. you cannot introduce a mandate for the presence of particular hardware later in your app’s product life cycle. gyroscope. You normally won’t need devices without a camera to use or download your app. you cannot submit an update that prevents it from running on either device. The submission process on iTunes connect will fail and show you an error. you've learned how to conditionally check a device for specific capabilities and use them if they are present. If you specify that telephony is needed. In some cases. you can submit a version 2 to support all devices. You can explicitly require particular device capabilities or prohibit installation of your app on devices without a specific capability. you can prevent your apps from running on devices with video-camera by setting the video-camera key to NO. if your app supported both iPhone and iPod touch in version 1. You must be certain that this is your expected behavior before using this key. The core functionality of the app doesn’t work without a camera.  Apple doesn’t allow you to submit an update to an existing app and prevent it from running on a specific device that was supported before the update. if version 1 of your app supported only iPhones. For example.
250 Part III: The Right Tool for the Job  Further Reading Apple Documentation The following documents are available in the iOS Developer Library at developer. Understanding the UIRequiredDeviceCapablities key iOS Build Time Configuration Details  Other Resources MKBlog. “MugunthKumar/DeviceHelper” https://github.com or through the Xcode Documentation and API Reference.apple.com/MugunthKumar/DeviceHelper  .com/coding/iphone-tutorial-better-way-to-checkcapabilities-of-ios-devices/ Github.mugunthkumar. “iPhone Tutorial: Better way to check capabilities of iOS devices” http://blog.
“Internationalization is the process of designing and building an application to facilitate localization.” (See “Internationalization Programming Topics” at developer.Chapter 13  Internationalization and Localization  Localization is a key concern for any application with a global market. Users want to interact in their own languages.  . and how to regularly audit your project to make sure it stays localizable. This is one of the hardest things to fix later. is the cultural and linguistic adaptation of an internationalized application to two or more culturally-distinct markets. Apple says. This isn’t difficult on iOS because there aren’t as many complicated things you can do in a nib as you can on Mac. That said. You don’t need to localize these.apple. String localization is much easier to maintain than nib file localization. iOS requires that nib files be localized for each language individually rather than providing an auto-layout framework like Adobe’s Adam and Eve. Even if you’re not ready to localize your application yet. But just remember that every IBOutlet and IBAction connection you make has to be made in every localized nib file. then make it an IBOutlet and set the localized value at runtime rather than localizing the nib file. Russian and German are bigger languages than English. The differences between i18n and L10n aren’t really important or consistently agreed upon. Autolayout tends to create layouts that look mediocre in all languages. ■ Remember right-to-left languages. numbers. ■ Separate nib files that require localization from ones that don’t. After reading this chapter. You learn how to localize strings. Supporting this in your application is called internationalization (sometimes abbreviated “i18n” for the 18 characters between the “i” and the “n”) and localization (“L10n”). you will have a solid understanding of what localization is and how to approach it. ■ Keep nib files simple. this chapter provides easy steps to dramatically simplify localization later. Arabic and Hebrew run right to left. which means laying them out manually and individually rather than by algorithm.com.  What is Localization? Localization is more than just translating strings. Many iOS nib files have no strings or localized images in them at all. Localization. Localization means making your application culturally appropriate to your target audience. dates and nib files. Different languages need different layouts to look their best. If you just need a localized title. in turn. there are many things you can do to make iOS localization easier. This is generally on purpose. especially if you have custom text views. with their familiar formatting.) This chapter uses the terms interchangeably. Chinese is smaller but denser. Apple wants your layouts to look ideal in all languages.
this can be particularly surprising. Remembering that you will often pay by the word for translation may help you focus on reducing the number of words you use.  Localizing Strings The most common tool for localizing strings is NSLocalizedString. A command-line tool called genstrings automatically searches your files for calls to NSLocalizedString and writes your initial Localizeable. This issue is particularly common in Thai. the “action” icon (an arrow coming out of a box) is incomprehensible.strings file for you.” Another frequent localization problem is icons that assume a cultural background. but don’t try to circumvent systems like Core Text when they force you to calculate the number of glyphs in a string rather than using length. even you believe you could create a better one. such as a decorated tree to indicate “winter. as I’ll discuss in Chapter 18). do not use UIBarButtonSystemItemReply to mean “go left” or “go back. This function looks up the given key in Localizeable. it is best to do all of your development up to the point of release and then translate rather than try to translate as you go. For example. particularly on iPhone. but users are used to it. so there is a different version for each language. For example. Apple has trained them in what it means. or the key itself if no value is found. because they are not used in all cultures (French for instance).” Checkmarks can also cause problems. you should line up your localization provider fairly early in the development cycle and prepare for localization throughout the process. however. ■ Glyphs (drawn symbols) and characters do not always map one-to-one. If the icon’s meaning matches your intent.252 Part III: The Right Tool for the Job ■ Don’t assume that comma is the thousands separator or dot is the decimal point. Apple’s done the hard and expensive work for you to make them internationally appropriate. when using a UIToolBarItem. and NSLocalizedString automatically selects the correct one based on the current locale. you should always try to use the system icon. Localizeable. you should use a system item whenever appropriate rather than drawing your own icons. Never use a system icon for something other than its intended meaning. Rely on Apple’s UI elements and icons as much as possible.strings is a localized file. A good localization provider does more than just translate a bunch of strings you send it.strings and returns the value found there. so build your regular expressions using NSLocale. Involving a good localization provider before producing your final artwork can save you a lot of money re-creating your assets. Don’t waste that. In my experience. These are different in different languages. Redesign your UI so it doesn’t need so much text to let the user know what to do. While translation is best done near the time of release. Getting the provider involved early in the process can save expensive rework later if your interface is hard to localize. generally at the end. Translating large blocks of text can play havoc with layout. and in some cultures a checkmark means “incorrect” (Finnish for instance). It’s expensive to retranslate things every time you tweak the UI. If you’re doing custom text layout. In my opinion. Ideally your localization provider will provide testing services to make sure your application “makes sense” in the target culture. The cost of localization is best absorbed at fixed points during development. Apple’s frameworks generally handle this well automatically.  . An example of a “hard-to-localize” application is one that includes large blocks of text. but exists in many languages (even occasionally in English. so you should use it.
This approach simplifies development and helps keep the Localizeable.”.”. # Certain common methods that take nonlocalized strings are # ignored # URLs are ignored # # Exits with 1 if there were strings found use File::Basename.. you should open a terminal.strings file from accumulating keys that are no longer used.m and . this works in the developer’s language because it automatically returns the key as the localized string.string that contains the following: /* Welcome message */ “Welcome to the show.] # # Scans .Chapter 13: Internationalization and Localization 253 The easiest approach is to use the string as its own key (the second parameter is a comment to the localizer): NSString *string = NSLocalizedString(@”Welcome to the show...  . change to your source code directory. # Strings on the same line as NSLocalizedString are # ignored.lproj *. To run genstrings. # String constant assignments of this form are ignored if # they have no spaces in the value: # NSString * const <.. you should periodically audit your program to make sure that you’re using NSLocalizedString as you should. Even if you don’t run genstrings. In most cases I recommend using the string as its own key and automatically generating the Localizeable.. # Lines marked with DNL (Do Not Localize) are ignored. @”Welcome message”). and run it as shown here (assuming an English localization): genstrings -o en..” = “Welcome to the show.m This will create a file called en.mm files for potentially nonlocalized # strings that should be.lproj/Localizeable.> = @”. I recommend a script like this:  find_nonlocalized #!/usr/bin/perl -w # Usage: # find_nonlocalized [<directory> . strings file when you’re ready to hand the project off to localizers. use File::Find.”.  Auditing for Nonlocalized Strings During development.
or you can add it as a script step in your Xcode build.}/) { foreach my $regex (@EXCLUDE_REGEXES) { next LINE if $_ =~ $regex. qr/imageNamed:@”/. qr/fileURLWithPath:@”/. } } close(FILE).“). LINE: while (<FILE>) { if (/@“[^“]*[a-z]{3. qr/NSAssert/. @dirs).254 Part III: The Right Tool for the Job use strict. qr/@”ldap/. $FoundNonLocalized = 1. update the regular expressions to ignore it. qr/NSLocalizedString/. qr/Key(?:[pP]ath)?:@”/. qr/setDateFormat:@”/. my $FoundNonLocalized = 0. # Include the basenames of any files to ignore my @EXCLUDE_FILENAMES = qw(). you can decide whether to fix it. find(\&find_nonlocalized. } my @dirs = scalar @ARGV ? @ARGV : („. exit $FoundNonLocalized ? 1 : 0. qr/predicateWithFormat:@”/. qr/NSLog\(/. or mark the specific line with DNL (Do Not Localize). qr/@”mailto/. qr/pathForResource:@”/. qr/stringByAppendingPathComponent:@“/.  . } print „$File::Find::name:$./. If you use Jenkins (jenkins-ci. # Regular expressions to ignore my @EXCLUDE_REGEXES = ( qr/\bDNL\b/. open(FILE. return if grep($_.:$_“. Periodically run this script over your source to make sure that there are no nonlocalized strings.org) or another continuous-integration tool. qr/NSString\s*\*\s*const\s[^@]*@”[^ ]*”.mm?$/. ). $_). you can make this script part of the build process. sub find_nonlocalized { return unless $File::Find::name =~ /\. Whenever it returns a new string. qr/NibNamed?:@”/. qr/@”http/. qr/fontWithName:@“/. @EXCLUDE_FILENAMES).
RNMoney *money = [[RNMoney alloc] initWithIntegerAmount:100]. Using NSNumberFormatterPercentStyle will behave correctly. If you only leave room for seven characters for one hundred thousand (“100. NSLog(@”Local display of local currency: %@”. First.com. [euro localizedStringForLocale:russiaLocale]). formatters are needed for input as well as output. This is generally straightforward using NSDateFormatter and NSNumberFormatter. The decimal point is not universally used to separate whole from fractional digits on input.  For an introduction to NSDateFormatter and NSNumberFormatter. If your user switches locale from the U.  main. euro). There are a few things to keep in mind. see the “Data Formatting Guide” in Apple’s documentation at developer. Always store currency as an NSDecimalNumber.00. RNMoney *euro =[[RNMoney alloc] initWithIntegerAmount:200 currencyCode:@”EUR”]. China sometimes groups ten thousands (four digits). Don’t guess. Most developers remember to use a formatter for date input. NSLog(@”Russian display of local currency: %@”.apple. Remember that this can impact the length of your string. you shouldn’t switch his $1 purchase to €1. Be especially careful with currency. which uses eight (“1. or apostrophe. It’s best to validate number input using an NSDateFormatter rather than custom logic.S.Chapter 13: Internationalization and Localization 255  Formatting Numbers and Dates Numbers and dates are displayed differently in different locales.000”) you may overflow in India. Keep track of the currency you’re working in. Don’t store currency as a float because that can lead to rounding errors as you convert between binary and decimal. Digit groupings have a bewildering variety. money). Percentages are another place that you should be careful because different cultures place the percent sign at the beginning or end of the number. NSLog(@”Local display of Euro: %@”. First. but may forget to use one for numeric input. Some countries split thousands groups with space.000” or one lakh).  . to France. [money localizedStringForLocale:russiaLocale]). Some countries use a comma or an apostrophe. Generally you need to persist what currency a given value is expressed in. which you are likely already familiar with. NSLog(@”Russian display of Euro: %@”.m (Money) NSLocale *russiaLocale = [[NSLocale alloc] initWithLocaleIdentifier:@”ru_RU”]. comma. Use a formatter. which does its math in decimal. however. and some use a slightly different symbol. the following code demonstrates how to use the class to store Rubles and Euros. The RNMoney class is an example of how to do this.
static NSString * const kRNMoneyAmountKey = @”amount”.(NSString *)localizedStringForLocale:(NSLocale *)aLocale. strong) NSString *currencyCode. . . Here is the code.  .m (Money) #import “RNMoney. and format.(RNMoney *)initWithAmount:(NSDecimalNumber *)anAmount.h (Money) #import <Foundation/Foundation. it defaults to the current locale’s currency. .(RNMoney *)initWithIntegerAmount:(NSInteger)anAmount currencyCode:(NSString *)aCode.(NSString *)localizedString. readonly. } else { currencyCode_ = aCode. . strong) NSDecimalNumber *amount. serialize.256 Part III: The Right Tool for the Job RNMoney is an immutable object that stores an amount and a currency code.(RNMoney *)initWithAmount:(NSDecimalNumber *)anAmount currencyCode:(NSString *)aCode.(RNMoney *)initWithIntegerAmount:(NSInteger)anAmount. static NSString * const kRNMoneyCurrencyCodeKey = @”currencyCode”.  RNMoney. It is a very simple data class designed to be simple to initialize. If you do not provide a currency code. @end  RNMoney. .(RNMoney *)initWithAmount:(NSDecimalNumber *)anAmount currencyCode:(NSString *)aCode { if ((self = [super init])) { amount_ = anAmount.h> @interface RNMoney : NSObject <NSCoding> @property (nonatomic. } } return self.h” @implementation RNMoney @synthesize amount=amount_. if (aCode == nil) { NSNumberFormatter *formatter = [[NSNumberFormatter alloc] init]. currencyCode_ = [formatter currencyCode]. readonly. @property (nonatomic. @synthesize currencyCode=currencyCode_. . .
(void)encodeWithCoder:(NSCoder *)aCoder { [aCoder encodeObject:amount_ forKey:kRNMoneyAmountKey].  . return [formatter stringFromNumber:self.Chapter 13: Internationalization and Localization 257 } .amount]. } . } . [aCoder encodeObject:currencyCode_ forKey:kRNMoneyCurrencyCodeKey].(NSString *)localizedStringForLocale:(NSLocale *)aLocale { NSNumberFormatter *formatter = [[NSNumberFormatter alloc] init]. [formatter setLocale:aLocale].(RNMoney *)initWithIntegerAmount:(NSInteger)anAmount { return [self initWithIntegerAmount:anAmount currencyCode:nil].(NSString *)localizedString { return [self localizedStringForLocale: [NSLocale currentLocale]].(RNMoney *)initWithIntegerAmount:(NSInteger)anAmount currencyCode:(NSString *)aCode { return [self initWithAmount: [NSDecimalNumber decimalNumberWithDecimal: [[NSNumber numberWithInteger:anAmount] decimalValue]] currencyCode:aCode]. } . } . return [self initWithAmount:amount currencyCode:currencyCode].(id)initWithCoder:(NSCoder *)coder { NSDecimalNumber *amount = [coder decodeObjectForKey: kRNMoneyAmountKey]. } . } . NSString *currencyCode = [coder decodeObjectForKey: kRNMoneyCurrencyCodeKey]. [formatter setNumberStyle:NSNumberFormatterCurrencyStyle]. [formatter setCurrencyCode:self.currencyCode].(RNMoney *)initWithAmount:(NSDecimalNumber *)anAmount { return [self initWithAmount:anAmount currencyCode:nil].(id)init { return [self initWithAmount:[NSDecimalNumber zero]]. } .
UILabel generally requires individual localization because the label will almost certainly need to be resized. intro. then you only need one copy. and you don’t discover this until someone clicks on the button in another language and the application crashes. If the localizable parts of a nib file don’t require layout changes. iOS will automatically load your master nib file if there is no localized version available. ■ You send your nib file off to be translated and receive back a dozen versions of it. *str = [NSString stringWithFormat:@”%@ %@ %@”. About that time you start to think that nib files are a terrible idea and swear you’ll never use them again. num. } @end  Localizing Nib Files Localizing nib files is one of the most tedious and risky parts of localization.(NSString *)description { return [self localizedString]. They’re worth the trouble once you learn some best practices for managing them. but that’s the wrong conclusion. Instead. This means that you can almost never safely compose a string from parts like this: NSString NSString NSString NSString *intro = @”There was an error deleting”. Sentence structure is radically different between languages. Consider the following common case: ■ Your project has a nib file with a button connected to the method doThis:. ■ Now you want to change the button’s action to doThat:. This is particularly good for handling titles and items such as UINavigationItem and UITabBarItem that are automatically sized. // Wrong  The problem with this code is that when you translate “There was an error deleting” and “objects” into other languages. If there’s nothing to localize. Nib files are incredibly powerful and an important part of iOS development. tail]. you need to localize the entire string together like this:  . You can usually get away with this technique for UIButton if it stretches across the entire view. then you may want to use an IBOutlet and plug in the localized value in viewDidLoad. but now you have 11 other versions of the nib file that are incorrect. *num = [NSString stringWithFormat:@”%d”. don’t localize a nib file if you don’t have to. you may not be able to glue them together in the same order. *tail = @”objects. First.”. It’s easier to localize programmatic strings than nib files. 5]. You open your master nib file (usually English) and make the change.258 Part III: The Right Tool for the Job } .
so try to avoid it instead. Don’t assume you can check for greater-than-one and easily determine linguistic plurals. Testing  6a. Solving this well can be very difficult. Don’t have special code that tries to add an s to the end of plurals because this is almost impossible to translate.”). A good translator will help you word your messages in ways that translate better in your target languages. Some languages have more complex plurals than English. UI Freeze  3. there may be special word forms for describing two of something versus more than two. For instance.Chapter 13: Internationalization and Localization 259 NSString *format = NSLocalizedString( @”There was an error deleting %d objects”. NSString *str = [NSString stringWithFormat:format. Figure 13-1 demonstrates a good approach. Version Control  5.  1. Talk with your localization provider early on to understand its process and how to adjust your development practice to facilitate working with it. 5]. @”Error when deleting objects. Localize  4. L1ON changes  Figure 13-1 Localization workflow  . Merge logic changes  6b. PseudoLocalize  2.
UI Freeze—There should be a clear point in the development cycle that you freeze the UI. After that point. this works quite well for nonlayout changes.nib --incremental-file ${OLD}/fr. You can merge the localized nib files like this: ibtool --previous-file ${OLD}/en. 6b. 4. For example. Pseudo-localization is the process of localizing into a nonsense language. These are logic changes rather than localization (L10N) changes. You can reuse the previous string translations.nib --strings-file ${NEW}/fr.260 Part III: The Right Tool for the Job 1.nib ${NEW}/en. Merge Logic Changes—Certain nib file changes do not affect localization.  . but it is still a lot of work so avoid making these changes late in the development cycle. You will need a language code for this localization. L10N Changes—If you make localization changes such as changing the layout of a localized nib file or changing a string. Figure 13-2 shows the lock option in Interface Builder. class names.lproj/MyNib. it is not good at discovering strings that are pieced together from other strings.lproj/MyNib. you should strongly avoid any changes that affect localizable resources. which makes things much cheaper. you will need to keep track of the original files your localizer sent to you.nib This computes the nonlocalization changes between the old and new English MyNib. it is particularly useful to use the British English slot for this purpose because you’ll still be able to easily read the rest of the iPhone’s interface. and other nonvisible attributes of the nib file. but it can find many simple problems before you pay for real translation services. Then put these into a version control system or save them in a separate directory. 2. “Press here to continue” would become “Prxss hxrx tx cxntxnxx. Many teams ship a monolingual version of their product at this point and then ship a localization update. Lock the localizable properties in the nib files (unlocking the nonlocalizable properties).lproj/MyNib. Pick a language that you do not plan to localize your application for. That’s the easiest approach if your market is tolerant of the delay. Nib files can be locked in Xcode to prevent changing localizable. 3. it’s a good idea to start doing experimental localization to work out any localization bugs early in the process. If you’re an American English speaker and don’t plan to localize for British English. A good localizer can assist in this.nib. 5. Testing—You’ll need to do extensive testing to make sure that everything is correct. you’ll need to start the process over and send the changes to the localizer.strings --localize-incremental --write ${NEW}/fr. and can be scripted fairly easily. A common nonsense language is one that substitutes all vowels with the letter x. Version Control—As you make changes to your nib files. and will make it more obvious where you have used nonlocalized strings. generally with a simple Perl script. or all properties. Localize—You will send your resource files to your localizers and they will send you back localized files. As long as you keep track of the original files you were sent by the localizer. 6a. Changes to connections or class names don’t change the layout or the resources.lproj/Localizeable. This won’t find every problem.lproj/MyNib. Pseudo-Localize—During development.” This kind of “translation” can be done by developers.nib and writes it as the new French nib file. Before sending nib files to a localizer. In particular. lock nonlocalizable properties to protect your nib files against changes to connections. It then applies these changes to the old French MyNib. nonlocalizable. Ideally you will have native speakers of each of your localized languages test all your UI elements to ensure they make sense and that there aren’t any leftover nonlocalized strings.
com or through the Xcode Documentation and API Reference. Data Formatting Guide Internationalization Programming Topics Locales Programming Guide  .  Further Reading Apple Documentation The following documents are available in the iOS Developer Library at developer.Chapter 13: Internationalization and Localization 261  Figure 13-2 Interface Builder localization locking option  Summary Localization is never an easy subject.apple. you can greatly expand the market for your applications. but if you work with a good localization partner early and follow the best practices detailed here.
262 Part III: The Right Tool for the Job  .
Chapter 14
Selling Past the Sale with In App Purchases
The iOS SDK makes it possible for many developers to make a living independently, and there are a variety of business models from which to choose. The first model is easily understandable (and arguably the most profitable): Make an app and sell it on the App Store. Another model is to release two versions—a free lite version and a pro (paid) version of the same app. Yet another model, probably pioneered by Web 2.0, is advertisement based. Developers use a third-party advertiser’s SDK (or iAds) to show advertisements and developers get paid for impressions or click-throughs. While all these augment the earnings of a developer, the first model, selling apps on the App Store, has been by far the most successful model. In App Purchases offer yet another unique way to sell premium content or features on your iOS app. Some apps take advantage of this and make money only through In App Purchases. They fall into a category called freemium apps and they have been quite successful, at least when you look at the top-grossing apps list on the U.S. App Store. This chapter introduces you to Apple’s In App Purchase framework, StoreKit.framework, and moves on to a wrapper framework, the MKStoreKit. You learn how to use it to integrate a mini In App Store within your app. This chapter also provides solutions to the problems that developers most commonly face while integrating StoreKit within their apps.
Before You Start
The chapter is broadly divided into two major sections. The first half focuses on creating and customizing products on iTunes Connect, and the second half tackles the programming aspects. You will use MKStoreKit and will go through the features it offers, including how to customize it for every allowed business model. At the end of the chapter you look at the most common issues and problems faced by developers and at solutions to get around them. Throughout the chapter, pay special attention to the shaded boxes, which offer helpful tips and important warnings. The information in those boxes explains what could go awry during implementation when you do something wrong. Let’s start the journey.
In App Purchase Products
Products that can be sold using In App Purchases broadly fall under the following four categories: content, functionality, service, and subscription. The latest SDK provides support for all of these. Apple allows four different product types, namely: consumable, non-consumable, auto-renewable subscriptions, and nonrenewable subscriptions. In a generic sense, a consumable is a product that depletes when it is used. A
264 Part III: The Right Tool for the Job
nonconsumable, on the other hand, is a product that is available for use any number of times after purchase. Your printer is an example of a non-consumable while the ink it uses is a common example of a consumable. Subscriptions, both auto-renewable and non-renewable, are analogous to real world subscriptions. You should match the following category of product to one of these four based on your business model. ■ Content—Products that are categorized as content include digital books, magazines, additional level packs, music, ringtones, and a variety of other data. Content can be sold as either consumable or nonconsumable depending on your business model. Thinking from the user’s perspective, content is generally considered non-consumable. For example, when a user gets a book, it’s your responsibility as a developer to remember his purchase and make it available to him for free. The SDK, in most cases, provides this feature for free. ■ Functionality—Products that are categorized as functionality mainly include locked features. For example, a task manager app can allow users to create a maximum of n tasks; to create tasks after that limit, the user has to unlock by paying a fee. Functionality is almost always considered non-consumable. ■ Service—Products that are categorized as service are mostly functionality that incurs a recurring expense to the developer. Service is very similar to the functionality category, except that it involves serious computation power and is done on a remote server. A classic example of this is push notifications. A Twitter client, for instance, may provide push notifications as a consumable selling, say a 1,000 notifications for a dollar. Service can also be subscription based if your business model requires it to be so. ■ Subscription—Products that are categorized as subscription are mostly content or service. Subscriptions usually provide the said content or service over a period of time as opposed to at the time of purchase. For example, a Twitter client may provide unlimited push notifications as a subscription costing 99 cents every three months. Treating a product as a consumable or a subscription or a non-consumable is up to the business owner.
Subscriptions were originally available in iOS 3.0, but they were complicated to use and the burden of renewing and/or restoring them to other devices relied on the developer. As such, adoption was low and very few developers used this. With iOS 4.3, Apple introduced a new kind of product called autorenewable subscription, for which restoring and renewing subscriptions happens automatically and is taken care of by Apple. From now on, you should almost always use auto-renewable subscriptions. Use the older subscription style only if your business already has proper server-side subscription handling in place and customers are already using it.
Prohibited Items
The previous section explained about the products that you can sell via In App Purchase. While Apple is okay with most kinds of business models, there are a couple kinds of items that you cannot sell via the App Store as of this writing.
Chapter 14: Selling Past the Sale with In App Purchases 265
The first kind of item (and this is arguably the most important point to remember) you cannot sell through In App Purchases is physical goods or services. For example, if you develop a wallpaper app, you can sell digital wallpapers, but you cannot sell printed posters of the same wallpapers through In App Purchase. Similarly, if you are a hotel owner and make an app for booking reservations, you cannot collect reservation fees or booking fees through In App Purchase. The second kind of item that is not allowed is intermediate currency. If you make a music subscription app, you have to sell music directly. You cannot sell “points” and allow the user to download music for those points. Subscription passes, prepurchasable coupons, and anything that is not offering the product at the time of purchase is not allowed.
Warning: There might be some app that already does this on the App Store. That doesn’t automatically entitle you. You run the risk of being rejected by Apple. If you see an app that sells an item that is prohibited by rule, chances are that it slipped past the App Store review. Such apps risk the chance of getting approved during every subsequent product update. Lotteries or sweepstakes are allowed in some cases, if the developer is permitted by law to run a lottery business. Again, you can only sell those apps in countries where you have the legal right to do so. Having a lottery app on the U.S. App Store doesn’t automatically entitle you to sell the same app on the U.K. App Store or the Australian App Store. You might need to submit additional documents to the Apple review process along with your app.
Apple’s developer documentation doesn’t contain any information on what is allowed and what is not allowed. Read the App Store Review Guidelines on developer.apple.com and your iOS developer license agreement to understand what is and is not permitted.
Rethinking Your Business Model
All items that you are planning to sell through In App Purchase (especially content) have to go through Apple’s formal review process, which usually take a week and sometimes longer. Remember this when coming up with your business plan. If you are making an app that provides premium wallpapers for download, you probably won’t be able to sell a “wallpaper of the day” through In App Purchases—at least not easily. You can, however, think of different business plans, like offering a free download for any wallpaper of the day if the user is subscribed to a premium membership. Another suggestion is to submit your app’s “wallpaper of the day” for at least the next 30 days so that you have full control of releasing it on the correct dates. Ensure that your buffer is bigger than the worstcase approval times.
266 Part III: The Right Tool for the Job
Finally, every product you submit to the App Store needs to be configured on iTunes Connect. This configuration might take anywhere from a couple of minutes to an hour (if complex screenshots are needed). If you are selling digital books or any other digital content like wallpapers, it might not be feasible (timewise) to configure every product on iTunes Connect. Moreover, there is a limit of 5,000 Stock Keeping Units (SKUs) that you can add to your product via In App Purchases. A recommended alternative in such a case is to make them consumable. At this point you should have decided whether to sell your In App product as a consumable, non-consumable, or subscription.
Setting Up Products on iTunes Connect
Implementing In App Purchases in your app is 20% configuration, 10% getting the right business model for your app, and 70% implementation. With MKStoreKit that 70% coding reduces to somewhere near zero. However, the addition of new types of products has made configuration confusing and changes to rules and lack of proper documentation on what is acceptable and what is not acceptable has made choosing the right business model difficult, so configuration remains the most challenging aspect of the integration. This section walks you through the steps involved in setting up products on iTunes Connect. I assume that you are already signed up with the iOS developer program and have the necessary credentials to log in to various portals like iOS developer program portal and iTunes Connect.
I refer to the iOS developer program portal and iTunes Connect throughout the next few pages. The following links will be of help. The URLs are pretty easy to remember: iOS developer program portal—http://developer.apple.com/devcenter/ios/index. action iTunes Connect—http://itunesconnect.apple.com
Step 1: Create a New App ID for Your App
Every app that requires In App Purchases should have an App ID that is unique to the application. The ID cannot include a wild card character (*). The recommended convention for this is reverse DNS notation. Here are a couple of examples: com.mycompany.myapp.levelpack1 org.mycompany.myapp.levelpack2
Chapter 14: Selling Past the Sale with In App Purchases 267
To create a new App ID, log in to iOS Developer Program portal and navigate to the iOS Provisioning Portal, as shown in Figure 14-1.
Figure 14-1 iOS Provisioning Portal
Click the New App ID button and follow the wizard to create an App ID. Ensure that you use a fully qualified App ID without any wild card characters.
Warning: A wild card character in your App ID will prevent you from adding products for In App Purchase later. If you already have a product on App Store and want to integrate In App Purchases in the next release, but the live app isn’t using a unique App ID, it will still work, but your users will not be notified about this update automatically through the App Store; they have to download it again. To push update notifications, the App Store relies on the fact that subsequent updates to a product use the same App ID and incrementing version numbers. While there are workarounds to associate a new App ID to an existing Bundle ID (Apple Technical Note QA1680), I would still recommend using a unique product ID for each app you develop. As of this writing, with iOS 5, there are several features that rely on a unique App ID including but not limited to push notifications, Game Center integration, and iCloud integration. If your app might use any one of these features (even in a future release), you should use a unique App ID from the beginning.
Step 2: Generate Provisioning Profiles
In App Purchases cannot be run on a simulator; you need a device to run and test them. This means you should create a provisioning profile for running your app on a device. That’s the second step. Go to the fifth link on the left navigation pane in the iOS Provisioning Portal. This step is done in exactly same way as for any other app. Remember to choose the same App ID that you created in step 1.
268 Part III: The Right Tool for the Job
Step 3: Create the App’s Product Entry
Before you create In App Purchase products, you need to have an app that sells your In App Purchase products. Let’s start by creating an application on iTunes Connect. Open iTunes Connect and click Manage Your Applications. That’s the first link in the right column, as shown in Figure 14-2.
Figure 14-2 iTunes Connect home page
Create a new application from the Manage Your Applications link. It’s most important for you to choose your Bundle ID correctly. Choose the App ID you created in step 1 as your Bundle ID here, as shown in Figure 14-3.
The Bundle ID and App ID are the same. Apple just uses a different name here. Later in your app you query the App Store for information about your product. This information includes the price in the currency of the user’s App Store account, the localized product name, and the product description. Making a mistake in this step means that you will not be able to get detailed information about an In App Product programmatically later. The product identifiers will be returned as Invalid Product Ids, described later in this chapter. This is because your In App Purchase products are tied to an app using the Bundle ID (App ID).
An app with a specific Bundle ID cannot sell In App Purchase products that are meant for a different app that uses a different Bundle ID.
Chapter 14: Selling Past the Sale with In App Purchases 269
Figure 14-3 New application form
Step 4: Create the In App Purchase Product Entries
Click on the app and you will see a screen like that shown in Figure 14-4.
Figure 14-4 App information
270 Part III: The Right Tool for the Job
Click the Manage In-App Purchases link to create your first In App Purchase product.
If you don’t see the Manage In-App Purchases option on your iTunes Connect, be sure your iTunes Connect account has Admin privileges. Then, check that your Contract Tax and Banking information is correct. If this is your first app and you haven’t yet submitted your tax documents and/or haven’t accepted the Paid Applications Contract, you will not see this link on the page. In that case, correct the situation appropriately and wait; Apple normally takes a week or two to approve your documents, depending on your location. On the first page, you see four different types of products available for you to create. You should know what kind of product you are creating (discussed earlier in the chapter). Choose that product type and proceed.
To create the Product ID for your In App products, I recommend suffixing the product identifier with your Bundle ID. For example, if your Bundle ID is com.mycompany.myapp, your In App product ID would be com.mycompany.myapp.inapp. This will ensure that product IDs across your other apps don’t clash with each other.
Consumables, Non-consumables, Non-renewing Subscriptions
For all product types except auto-renewable subscriptions, you have to enter a product identifier and choose its price tier. Add a description that shows up when the user buys your product. If your product is multilingual, add descriptions in all supported languages in this page. You now have to add a screenshot of the product (yes, that’s for the product you have not yet created) before you can submit the form. For the time being, upload a 320×480 iPhone screenshot. This screenshot is only for iOS App Store review purposes. In most cases, you need this only for content. For features or other consumables, it’s okay to upload a screenshot displaying the In App Store.
Nonrenewing subscriptions are not recommended after Apple announced the new auto-renewing subscriptions. Functionally, auto-renewing subscriptions offer everything that nonrenewing subscriptions offer and add features like automatic renewal without user intervention, and restoring subscriptions on customers’ other devices.
Auto-renewable Subscriptions
Auto-renewable subscriptions are slightly different. You create a subscription family and add duration of the subscription to that family. This allows you to create the same magazine subscription with different durations. For instance, you can create a weekly subscription at $5 or a monthly subscription at $20 or a yearly subscription at $300. Other options within a subscription family are similar to consumables.
Chapter 14: Selling Past the Sale with In App Purchases 271
Step 5: Generating the Shared Secret
For auto-renewable subscriptions, you need to do one more very important step: Generate a shared secret. In the App Information page (shown in Figure 14-4), click the Manage In App Purchases link. On this page, you will see a link titled, “View or generate a shared secret.” Copy the shared secret safely. You will need it when you write the real code.
Step 6: Creating Test User Accounts
The final step is to create user accounts that you will use for testing In App Purchases after implemention. You can do this later, after implementation, but doing it now completes all steps needed for configuring In App Purchases. To create test user accounts, open the iTunes Connect home page (see Figure 14-2) and click Manage Users. You will see two links, one for creating an iTunes Connect user and another for creating a Test User. Click the second link and create a Test User. This should be fairly simple. That completes the configuration part of In App Purchasing. If you have done all the steps correctly, you have completed 30% of the In App Purchase integration. The remaining 70% is the real code, which you dive into next.
In App Purchase Implementation
The configuration of In App Purchases was hard, and so is the programming involved in the implementation. In App Purchase implementation requires you to complete some tedious coding. The following is a comprehensive list of the important tasks that you have to do for implementing In App Purchases in your app. ■ First and foremost, your app could be closed (probably by a phone call) while a transaction is in progress. Given that transactions can continue outside of your app, you should have a Store Observer class that initializes at application launch and receives any purchases made while the app is in the background. ■ Remember the actual number of consumable items purchased. ■ Remember the non-consumable purchase and allow the user to restore it on his other devices. ■ Remembering these purchases should be done securely using iOS keychain. ■ Post nonrenewing subscriptions to your server and “remember” them there. You should also have the capability to restore them on any other device when the user logs into your app from another device. ■ Consumable contents can be occasionally delivered digitally from your server. In that case, your server should be able to verify the authenticity of the receipt and provide content. This also means that your iOS app should post App Store purchase receipts to your server before it starts downloading content. ■ Verify whether auto-renewing subscription receipts are still valid. Even though auto-renewing subscriptions are renewed automatically without manual user intervention, you are still required to check this because a user might have cancelled the subscription. A cancelled subscription remains valid only until the end of the current subscription period. This means that you as a developer should remember purchases, purchase receipts, and verify the receipts’ validity, probably during app launch. If they are no longer valid, stop providing the content.
272 Part III: The Right Tool for the Job
■ To validate auto-renewing subscriptions, post your receipt and the shared secret you generated in step 5 of the previous section to the App Store, parse the returned JSON (JavaScript Object Notation), and get the subscription’s latest purchase date. ■ The StoreKit.framework doesn’t tell you when an auto-renewable subscription ends. Instead, the API returns the actual date of the latest receipt. From this date, you should calculate the actual date of expiry. ■ Display localized product prices and descriptions on your Store View Controller. While this might sound complicated, MKStoreKit wraps most of these functionalities. Next you see how to add MKStoreKit into your app and build it.
Introduction to MKStoreKit
MKStoreKit is an open source framework (In App Purchases Tutorial | MKBlog, 2011) that makes integrating In App Purchases simpler. As of this writing, the latest version is 4.0 and that’s the version used in this chapter. You can download the source code for this from the book’s website or from Github (see the "Further Reading" section at the end of this chapter).
Why MKStoreKit?
MKStoreKit automatically takes care of the following items you saw in the list in the preceding section. ■ When your app is closed while a transaction is in progress, MKStoreKit automatically tracks this, continues to observe StoreKit delegates, and remembers any purchases made outside of your app. This takes care of the first item. ■ For consumables and nonconsumables, MKStoreKit automatically remembers your purchases in iOS keychain. Purchases are remembered using your product identifiers as the key so in most cases you don’t have to customize anything here. Items 2, 3, and 4 are thus taken care of automatically. ■ The MKSKProduct class posts nonrenewing subscriptions to your server. So the fifth item is taken care of, if you do the server customization with the PHP code that comes with MKStoreKit. You learn about this later in the “Customizing MKStoreKit” section. ■ For consumables or any content you deliver digitally from your server, you have to post the App Store receipt to your server. The server should verify the receipt and validate it. If it’s valid, it should deliver the content to your app. The MKSKProduct class takes care of this in tandem with some server configuration, which you learn about later in this chapter. This handles item 6. ■ For auto-renewing subscriptions, you need to verify the latest receipt when your app is launched and disable access to content when the user has cancelled the subscription. The MKSKSubscriptionProduct class does this automatically, including parsing the response JSON from the App Store and verifying that the subscriptions are still valid; it notifies you via NSNotificationCenter. You should tell MKStoreKit how many days a subscription is valid. You learn how to do this later in this chapter. This takes care of items 7, 8, and 9. ■ MKStoreKit has helper methods that return your product descriptions and price formatted in the local currency of the user. That takes care of the last item.
Chapter 14: Selling Past the Sale with In App Purchases 273
Customizing MKStoreKit to work with your app takes less than 25 lines of code. In some cases it should be less than ten lines of code. Now, before you actually integrate the framework, it’s always good to know how it works internally. The next section explains this.
Design of MKStoreKit
MKStoreKit uses blocks instead of delegates to notify you of product purchases. (You learn more about blocks in Chapter 16.) Other notifications like subscription expiry are posted to NSNotificationCenter. The framework comprises a main singleton class, the MKStoreManager, and several other support classes listed here: ■ MKStoreManager.h and MKStoreManager.m—This is the main singleton class that handles most of the implementation. You have to initialize this singleton in your AppDelegate’s applicationDidFinish LaunchingWithOptions: method. ■ MKStoreObserver.h and MKStoreObserver.m—This is the class that implements of the StoreKit. framework’s SKPaymentTransactionObserver. It notifies product purchases, or restores notifications to MKStoreManager singleton. ■ MKSKProduct.h and MKSKProduct.m—This is an internal class used by MKStoreKit to validate purchases. MKStoreManager uses this class to communicate with your server to check whether the receipt is valid and the actual product can be downloaded. This is used only for Server Product Model, where you verify receipts on server and deliver content digitally. ■ MKSKSubscriptionProduct.h and MKSKSubscriptionProduct.m—This is another internal class used by MKStoreKit to validate your auto-renewable subscription purchases. MKStoreManager uses this class to communicate with your server to check if the latest subscription receipts are still valid. If the user has cancelled his subscription, this class notifies MKStoreManager that the subscription is no longer valid and MKStoreManager posts a notification. You have to observe these notifications (shown below) on your view controller and enable or disable your Subscribe buttons accordingly. If your app doesn’t use auto-renewable subscriptions, you don’t have to do this. kSubscriptionsPurchasedNotification kSubscriptionsInvalidNotification ■ MKStoreKitConfigs.h and MKStoreKitConfigs.plist—These two files in the framework require customization based on your app. You will learn about customizing them later in this chapter. ■ Remembering purchases—MKStoreKit uses iOS keychain to remember a purchase automatically when it’s purchased.
Customizing MKStoreKit
Two important files in MKStoreKit that you should change are ■ MKStoreKitConfigs.h ■ MKStoreKitConfigs.plist
274 Part III: The Right Tool for the Job
The plist file contains the list of products that you configured on iTunes Connect. You add your products under the corresponding keys in the plist depending on the product type. You should add your consumables under the consumable key, nonconsumables under the nonconsumable key, and subscriptions under the subscriptions key. Every type of key has its own suboptions. You learn how to configure them later in this chapter.
Initializing MKStoreKit
Before you configure MKStoreKit, initialize it in your AppDelegate’s applicationDidFinishLaunching WithOptions: method. This ensures that the StoreObservers are initialized properly to receive transactions completed outside of the app. Just initialize the singleton by calling the following in your AppDelegate: [MKStoreManager sharedManager];
Configuring for Use with Server Product Model
When you sell content in your app and allow users to stream or download the content from your server, you should use the Server Product Model. In the Server Product Model, the iOS app makes a purchase and sends the transaction receipt over to the server for verification. The server then verifies the receipt with Apple’s receipt verification server and if the receipt is valid, redirects the request to the requested content.
Server Setup
MKStoreKit comes with server code in PHP ready to verify receipts from the server. Copy the Server Code directory and open it up for access. Copy the public URL for this directory. Let’s assume that it can be accessed at this location: http://api.example.com/servercode Now go back to your iOS source, open the file MKStoreKitConfigs.h, and locate these lines: #define SERVER_PRODUCT_MODEL 0 #define OWN_SERVER nil #define REVIEW_ALLOWED 1 Set the OWN_SERVER value to @”http://api.example.com/servercode”. You are all set. MKStoreKit will ping the featureCheck.php endpoint in this directory to verify receipts and remember the purchase only when the server says receipts are valid. Receipt validation is done by posting the receipt to Apple’s receipt validation URL: https://buy.itunes.apple.com/verifyReceipt For sandbox testing, you should use https://sandbox.itunes.apple.com/verifyReceipt The server code automatically switches this based on the configuration you defined. The default implementation of featureCheck.php returns plain strings—YES or NO—based on whether the receipts are valid or not. You might need to modify it to return in JSONs along with the URL of the content location.
Chapter 14: Selling Past the Sale with In App Purchases 275 Configuring for Use with Consumables
In a generic sense, a consumable is a product that depletes when it is used. Printer ink is a common example. In App Purchases consumables behave the same way. When a user purchases a consumable product, it’s stored on the device and stays there until he uses it. You are not obliged to restore consumables on other devices. When implementing consumables, you often encounter a business case where bulk purchases are subsidized to the user, just like real world consumables. For example, you might have two products in your game, a small
