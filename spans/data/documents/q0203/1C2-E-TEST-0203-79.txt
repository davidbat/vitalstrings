The Automated Garbage Collection Process
Java Tutorials - Herong's Tutorial Notes
Dr. Herong Yang, Version 6.00
∟ Garbage Collection and the gc() Method
∟The Automated Garbage Collection Process
This section a tutorial example on how to find out when the garbage collector automatically performing the garbage collection process.
To understand when the JVM will ask the garbage collector to perform the garbage collection process, I wrote the following tutorial example to run a loop of many steps. In each step, a new 1-MB object is  created and an old 1-MB object is freed up, except for the first 32 steps:
/** * GarbageCollection.java * Copyright (c) 2003 by Dr. Herong Yang */ class GarbageCollection {    public static void main(String[] a) {       int steps = 10000;       int size = 32;       Object[] queue = new Object[size];       Runtime rt = Runtime.getRuntime();       System.out.println("Memory: Maximum   Total   Free   Used");       for (int m=0; m<steps; m++) {          for (int n=0; n<size-1; n++)              queue[size-n-1] = queue[size-n-2];          queue[0] = getOneMega();          System.out.println(m+"   "+rt.maxMemory()             +"   "+rt.totalMemory()+"   "+rt.freeMemory()             +"   "+(rt.totalMemory()-rt.freeMemory()));          try { Thread.sleep(1000/10);          } catch (InterruptedException e) {             System.out.println("Interreupted...");          }       }    }    private static Object getOneMega() {       return new long[1024*128]; // 1MB    } }
Note that:
The method getOneMega() is used to create a 1-MB object, which is an array of "long"  with 1024*128 = 131072 elements. Since size of data type "long" is 8 bytes, the total size  of the array is 131072 * 8 = 1048576 bytes (1MB).
"queue" is an array to hold 32 object references.
The outer loop, "for (int m=0; m<steps; m++) {...}" controls testing steps.
At each step, the inner loop, "for (int n=0; n<size-1; n++) {...}" shifts all references by one position towards right.
At each step, the inner loop, "for (int n=0; n<size-1; n++) {...}" shifts all references in the "queue"  by one position.
After shifting operation, the reference of a new 1-MB object is added to the beginning of the "queue".
For the first 32 steps, the shifting operation will remove references  to any existing objects, since the "queue" is not full yet.
After the first 32 steps, the shifting operation will remove the reference of the oldest object from the "queue".
Running this sample program with JDK 1.6, I got the following output:
Memory:        Maximum      Total       Free       Used  0   66650112    5177344    3948480    1228864  1   66650112    5177344    2899888    2277456  2   66650112    5177344    1832880    3344464  3   66650112    6410240    2087472    4322768   //Total increased  4   66650112    6410240    1038880    5371360  5   66650112    9908224    3488272    6419952   //Total increased  6   66650112    9908224    2439680    7468544  7   66650112    9908224    1391088    8517136  8   66650112   15347712    5778048    9569664   //Total increased  9   66650112   15347712    4740368   10607344 10   66650112   15347712    3695672   11652040 11   66650112   15347712    2649648   12698064 12   66650112   15347712    1602736   13744976 13   66650112   15347712     555248   14792464 14   66650112   26546176   10708152   15838024   //Total increased 15   66650112   26546176    9659648   16886528 16   66650112   26546176    8611056   17935120 17   66650112   26546176    7562464   18983712 18   66650112   26546176    6513872   20032304 19   66650112   26546176    5465280   21080896 20   66650112   26546176    4416688   22129488 21   66650112   26546176    3368096   23178080 22   66650112   26546176    2319504   24226672 23   66650112   26546176    1270912   25275264 24   66650112   45334528   19010672   26323856   //Total increased 25   66650112   45334528   17962080   27372448 26   66650112   45334528   16913488   28421040 27   66650112   45334528   15864896   29469632 28   66650112   45334528   14816304   30518224 29   66650112   45334528   13767712   31566816 30   66650112   45334528   12719120   32615408 31   66650112   45334528   11670528   33664000 32   66650112   45334528   10621936   34712592 33   66650112   45334528    9573344   35761184 34   66650112   45334528    8524752   36809776 35   66650112   45334528    7476160   37858368 36   66650112   45334528    6427568   38906960 37   66650112   45334528    5378976   39955552 38   66650112   45334528    4330384   41004144 39   66650112   45334528    3281792   42052736 40   66650112   45334528    2233200   43101328 41   66650112   45334528    1184608   44149920 42   66650112   58486784   24822784   33664000   //Total increased                                                  //Garbage collected 43   66650112   58486784   23774192   34712592 44   66650112   58486784   22725600   35761184 45   66650112   58486784   21677008   36809776 46   66650112   58486784   20628416   37858368 47   66650112   58486784   19579824   38906960 48   66650112   58486784   18531232   39955552 49   66650112   58486784   17482640   41004144 50   66650112   58486784   16434048   42052736 51   66650112   58486784   15385456   43101328 52 66650112   58486784   14336864   44149920 53   66650112   58486784   13288272   45198512 54   66650112   58486784   12239680   46247104 55   66650112   58486784   11191088   47295696 56   66650112   58486784   10142496   48344288 57   66650112   58486784    9093904   49392880 58   66650112   58486784    8045312   50441472 59   66650112   58486784    6996720   51490064 60   66650112   58486784    5948128   52538656 61   66650112   58486784    4899536   53587248 62   66650112   58486784    3850944   54635840 63   66650112   58486784   24822784   33664000   //Garbage collected ...
Several notes about the output:
Between step 0 and 31, no garbage collection happened, because there was no unused objects. JVM increased the total memory 5 times to 45334528 bytes, to have enough space for 32 new objects.
From step 32 to 41, unused object are available for garbage collection. But JVM decided to use its free memory for new objects.
At step 42, the free memory was very low, 1184608 bytes.  JVM decided to increase the total memory, and call for garbage collection.
After step 43, JVM stopped to increase total memory. It called for garbage collection  when its free memory is too low.
Table of Contents
